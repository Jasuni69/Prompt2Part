function catenary(width, droop, n=100, angle) =
    assert(one_defined([droop, angle],"droop,angle"))
    let(
        sgn = is_undef(droop)? sign(angle) : sign(droop),
        droop = droop==undef? undef : abs(droop),
        angle = angle==undef? undef : abs(angle)
    )
    assert(is_finite(width) && width>0, "Bad width= value.")
    assert(is_integer(n) && n>0, "Bad n= value.  Must be a positive integer.")
    assert(is_undef(droop) || is_finite(droop), "Bad droop= value.")
    assert(is_undef(angle) || (is_finite(angle) && angle != 0 && abs(angle) < 90), "Bad angle= value.")
    let(
        catlup_fn = is_undef(droop)
          ? function(x) let(
                p1 = [x-0.001, cosh(x-0.001)-1],
                p2 = [x+0.001, cosh(x+0.001)-1],
                delta = p2-p1,
                ang = atan2(delta.y, delta.x)
            ) ang
          : function(x) (cosh(x)-1)/x,
        binsearch_fn = function(targ,x=0,inc=4)
            inc < 1e-9? lookup(targ,[[catlup_fn(x),x],[catlup_fn(x+inc),x+inc]]) :
            catlup_fn(x+inc) > targ? binsearch_fn(targ,x,inc/2) :
            binsearch_fn(targ,x+inc,inc),
        scx = is_undef(droop)? binsearch_fn(angle) :
            binsearch_fn(droop / (width/2)),
        sc = width/2 / scx,
        droop = !is_undef(droop)? droop : (cosh(scx)-1) * sc,
        path = [
            for (x = lerpn(-scx,scx,n))
            let(
                xval = x * sc,
                yval = approx(abs(x),scx)? 0 :
                    (cosh(x)-1) * sc - droop
            )
            [xval, yval]
        ],
        out = sgn>0? path : yflip(p=path)
    ) out;