module hingedbox_half( bd, topflag=false ) {

    dx = bd.x; dy=bd.y; dz=bd.z; dxc = dx/2;
    
    // object height   
    lz = (topflag) ? (dz * top_rat) : (dz * bot_rat);

    // hinge lengths
    bhl = (hinge_xrat>1)? hinge_xrat : hinge_len * hinge_xrat;
    thl = ( (hinge_len -bhl) -(CLEAR*2) ) /2;
    // hinge y offset
    hy = (0-hinge_standoff)-(hinge_od/2);
    // hinge local z
    hlz = (topflag) ? (dz * (1.0 - hinge_zrat)) : (dz * hinge_zrat) ;
    hinge_root_d = (hinge_root_d !=false)? hinge_root_d : hinge_id;

    // rim
    lip_h = dz * lip_rat;
    
    // box_def for cutout / decorate 
    side_d = [ dy-wt2, lz-wt2, wt ];
    front_d = [ dx-wt2, lz-wt2, wt ];
    top_d = [dx-wt, dy-wt, wt];
    
    // inserts
    ins_d=[ dx-wt2, dy-wt2, lz-wt2];
    
    // screw towers
    screw_id_bottom = (screw_id_bottom !=false)? screw_id_bottom : (screw_id*0.80);
    stsz = screw_od;
    
    // magwart
    // if the user hasn't set this, calculate
    magwart_box = (magwart_box != false)? magwart_box : ([ 
        round( (magnet_d*1.0)+(wall_thick*2) ), 
        round( (magnet_d*1.0)+(wall_thick*2) ),
        round( magnet_h+(wall_thick*2) )]);
    magwart_offset = (magwart_offset != false)? magwart_offset : 0-CLEAR;
    mgw_z = (topflag?dz*(1.0-magwart_zrat):dz*magwart_zrat) - magwart_box.x;

    // catch clasps
    catch_thick = (catch_thick != false)? catch_thick : (wall_thick*2) ;
    catch_inner_thick = (catch_inner_thick != false )? catch_inner_thick : wall_thick ;
    catch_hole_xtra = (catch_hole_xtra != false)? catch_hole_xtra : CLEAR*2;
    catch_offset = (catch_offset !=false )? catch_offset : CLEAR;
    catch_foot_thick = (catch_foot_thick != false)? catch_foot_thick : catch_thick * 1.5;
    // width and bottom width
    ctw = (catch_wide>1)? catch_wide : (catch_wide * dx);
    ctbw = (catch_wide_bottom>1)? catch_wide_bottom : (catch_wide_bottom * ctw) ;
    // catch tooth z point (on bottom)
    ctzp =  (topflag)? (dz*top_rat)+( (dz*bot_rat)*(1.0-catch_tooth_zrat)) : (dz*bot_rat)*catch_tooth_zrat ;
    // top catch height
    ctth = 0-ctzp;
    // catch tooth length
    ctl = catch_tooth_xrat* (ctbw -(catch_thick*2)); 
    cfl = catch_foot_xrat* (ctbw -(catch_thick*2)); 
    

    // build thing
    difference () {
        gang(){ chopd_body(); body_build(); }
        // final cutouts
        if (topflag) { 
            translate ( [wt,wt,0] ) rotate([0,0,180]) translate([0-dx,0-dy,0]) cutout_top( top_d );
            translate([dx-wt,dy,lz]) rotate([-90,0,0]) rotate([0,90,0]) cutout_top_right( side_d );
            translate([wt,0,lz]) rotate([-90,0,90]) cutout_top_left( side_d );
            translate([0,dy,lz]) rotate([90,180,180]) cutout_top_front( front_d );
            translate([dx,wt,lz]) rotate([90,180,0]) cutout_top_back( front_d );
            // screwtower lid holes
            if (screwtower_top) {for (i=screw_points) { 
                translate( [ dx-(dx*i), (dy-wt)-(stsz/2), 0-CS] ) gang() {
                    cylinder( d=hnut_d, h=hnut_t+CS2, $fn=6);
                    cylinder( d=screw_id, h=(lz-CLEAR)+CS2, $fn=screw_ifn);
                }
            }}
        } else {
            translate( [dx-wt,dy-wt,0] ) rotate([0,0,180]) cutout_bottom( top_d );
            translate([wt,dy,0]) rotate([-90,180,0]) rotate([0,90,0]) cutout_right( side_d );
            translate([dx-wt,0,0]) rotate([90,0,90]) cutout_left( side_d );
            translate([dx,dy-wt,0]) rotate([90,0,180]) cutout_front( front_d );
            translate([0,wt,0]) rotate([90,0,0]) cutout_back( front_d );
            // screwtower
            if (screw_punchbottom) { for (i=screw_points) { 
                translate( [ (dx*i), (dy-wt)-(stsz/2), 0-CS] ) gang() {
                    cylinder( d=hnut_d, h=hnut_t+CS2, $fn=6);
                    cylinder( d=screw_id, h=(lz-CLEAR)+CS2, $fn=screw_ifn);
                }}
            }//punchbottom
        }//topflag
    }// top level difference
    
    // sub modules
    module body_build() { // build interior after first cutout
        if (topflag) {
            // decorate callbacks
            translate([wt,wt,wt]) decorate_top( top_d ); 
            // top sides
            translate([0,0,lz]) rotate([-90,0,90]) decorate_top_left( side_d );
            translate([dx,dy,lz]) rotate([90,180,90]) decorate_top_right( side_d );
            translate([0,dy,lz]) rotate([90,180,180]) decorate_top_front( front_d );
            translate([dx,0,lz]) rotate([90,180,0]) decorate_top_back( front_d );
            // insert
            translate([wt,wt,wt]) rotate([0,0,0]) insert_top( ins_d ); 
            // catch clasps
            for (i=catch_points) {
                translate( [(dx*i)-(ctw/2), dy, catch_thick*2] ) rotate([-90,0,0]) 
                  catch_clasp( ctw, ctbw, ctth, catch_thick );
            }
            // screwtower top inside lid
            if (screwtower_top) {for (i=screw_points) { 
                translate( [ dx-(dx*i), (dy-wt)-(stsz/2), 0] ) 
                difference() {
                    screw_tower( lz, false ); // not doing taper doesnt matter :)
                    cylinder( d=screw_id, h=(lz-CLEAR)+CS2, $fn=screw_ifn);
                }
            }}
            // magwarts
            for (i=magwart_points) {
                translate( [ dx- ((i<1)?(dx*i):i) , dy, mgw_z] ) 
                magwart( magwart_box, 0-magwart_slotra, magwart_offset ) ;
            }
        } else { // bottom
            // decorate callbacks
            translate([wt,wt,wt]) rotate( [0,0,180]) translate( [0-dx,0-dy,0] )
              decorate_bottom( top_d );
            translate([0,dy,0]) rotate([-90,180,0]) rotate([0,90,0]) translate([0,0,0]) decorate_right( side_d );
            translate([dx,0,0]) rotate([90,0,90]) decorate_left( side_d );
            translate([dx,dy,0]) rotate([90,0,180]) decorate_front( front_d );
            translate([0,0,0]) rotate([90,0,0]) decorate_back( front_d );
            // insert
            rotate([0,0,180]) translate( [0-dx,0-dy,0] ) translate([wt,wt,wt]) insert_bottom( ins_d );
            // catch clasps' teeth
            for (i=catch_points) {
                translate( [(dx*i)-(ctl/2), dy, ctzp - ((catch_thick*2)-catch_offset) ] ) 
                rotate([0,90,0]) //translate([0-catch_thick ,0,0]) 
                  catch_tooth_shape( catch_thick*2, ctl, catch_fn );
            }
            // screwtowers bottom inside body
            if (screwtower_bottom) {for (i=screw_points) {
                translate( [ (dx*i), (dy-wt)-(stsz/2), 0] ) screw_tower( lz-(lip_h+CLEAR) );
            }}
            // magwarts
            for (i=magwart_points) {
                translate( [ ((i<1)?(dx*i):i) , dy, mgw_z] ) 
                magwart( magwart_box, magwart_slotra, magwart_offset ) ;
            }
        }
    }// body_build
   
    module chopd_body() {
        difference () {
            base_body();
            // inside hollow
            translate( [wt,wt,wt] ) base_box( [dx - wt2, dy - wt2, lz+dz] );
            if (topflag) { 
                // clean lid inside (trim hinge towers)
                translate( [0,0,lz+lip_h] ) base_box( [dx, dy, lz-(lip_h-wt)] );
                // cutout rim
                rotate([0,180,0]) translate( [0-dx,0,0-(lz+lip_h)] )
                base_box( [dx, dy, lip_h], corner_radius-wt );
            }
        }
    }//chopd_body

    module base_body() {
        // bottom gets lip added later, top gets lip cut out (inside); they do overlap.
        base_box( [dx, dy, ( topflag? lz+lip_h : lz-lip_h )] );
        // hinges
        for (i=hinge_points) {
            hcp = (dx * i);
            if (topflag) { 
                hxofs = (bhl/2) + (CLEAR);
                translate( [hcp + hxofs +thl, hy , hlz] ) rotate([0,-90,0]) hinge( thl, 1 ) ;
                translate( [hcp - hxofs , hy , hlz] ) rotate([0,-90,0]) hinge( thl, -1 ) ;
            } else {
                translate( [hcp - (bhl/2) , hy ,hlz ] ) rotate([0,90,0]) hinge( bhl,  0)  ;
            }
        }
        // rim
        if (!topflag) { translate([0,0,lz-lip_h]) rim( [dx, dy, lip_h] ); }
    }//base_body
    
    module hinge(cl,  ntf=0) {
        // ntf is which face to take nut inset out of
        ofn = hinge_ofn; ifn = hinge_ifn;
        ztn = hinge_ztnotch;
        hbs = (hinge_basepoint_bottom>1)? hinge_basepoint_bottom : hinge_basepoint_bottom * hlz;
        tbs = (hinge_basepoint_top>1)? hinge_basepoint_top : hinge_basepoint_top * hlz;
        lbtm = (hlz - (hinge_id/2));
        lp1 = (topflag) ? (0- (lbtm -tbs)) : lbtm -hbs ;
        module hingept() {
            hull() {
                cylinder( d=hinge_od, h=cl, $fn=ofn); // pin through here
                translate( [lp1* hinge_midpoint,0,0] ) cylinder( d=hinge_od, h=cl ); // middle leg point
            }
            hull () {
                translate( [lp1* hinge_midpoint,0,0] ) cylinder( d=hinge_od, h=cl ); //middle leg point
                translate( [lp1,0,0] ) cylinder( d=hinge_root_d, h=cl ); // bottom outer
                translate( [lp1,0-hy,0] ) cylinder( d=hinge_root_d, h=cl ); //bottom inner
            }
        }
        difference(){
            hingept();
            // hinge pin hole
            translate( [0,0,0-CS]) cylinder( d=hinge_id, h=cl+CS2, $fn=ifn);
            // nut holes
            if (topflag) { 
                if (ntf >0) {translate( [0,0,0-CS] ) cylinder( d=hnut_d, h=hnut_t+CS2, $fn=6 ); }
                if (ntf <0) {translate( [0,0,cl-hnut_t] ) cylinder( d=hnut_d, h=hnut_t+CS2, $fn=6 ); }
            }
            // hinge mid hole
            if (hinge_mid_hole && !topflag) {
                translate( [lp1* hinge_midpoint,0,0-CS] ) cylinder( d=hinge_mid_hole, h=cl+CS2 );
            }
            // hinge ziptie notches
            if ((ztn !=0) && topflag) {
                if (ntf >0) { translate( [0-CS,0-(ztn/2),0] ) cube( [ztn+CS2,ztn,ztn] ); }
                if (ntf <0) { translate( [0-(ztn+CS), 0-(ztn/2), cl-(ztn)] ) cube( [ztn+CS2,ztn,ztn] ); }
            }
        } // difference
    }// hinge

    module screw_tower( tz, dotaper=true ) {
        sh = (screw_od*screw_bspread)/2;
        sb = screw_od/2;
        hdp = max(screw_deep,tz);
        hd1 = dotaper?screw_id_bottom:screw_id;
        difference() {
            hull(){
                cylinder( d=screw_od, h=tz, $fn=screw_ofn );
                translate( [0-sh,0+sb,0] ) cube( [screw_od*screw_bspread,wt,tz] );
            }
            translate([0,0,tz-hdp] ) 
              cylinder( d1=hd1, d2=screw_id, h=hdp+CS, $fn=screw_ifn );
            // magnet slots
            translate([0,0,tz - (wt + screw_slot_xdepth + screw_slot_h )] )
              hull(){
                  cylinder( d=screw_slot_d, h=screw_slot_h );
                  translate([0,0-screw_od,0])
                  cylinder( d=screw_slot_d, h=screw_slot_h );
              }
        } // difference
    }// screw_tower

    module catch_clasp( cw, cwb, ch, ccr ) {
        cfn=catch_fn;
        //base inset
        bi = (cw - cwb) /2;
        zp = 0;
        ym = ch- (ccr*2);
        xm = cw - (ccr*2);
        bir = (cw - (cwb-ccr)) /2;
        points = [ [0,0], [xm, 0],  [(xm - bi), ym], [bi, ym],   ];
        module clbody () {
            // outer
            spbar( points[0], points[1] );
            spbar( points[0], points[3] );
            spbar( points[2], points[1] );
            spbar( points[2], points[3] );
            // cross members
            spbar( points[0], points[2] );
            spbar( points[1], points[3] );
            // fill
            if (catch_inner_thick) {
                translate([ccr,ccr,0]) 
                  linear_extrude( height=catch_inner_thick ){ 
                    polygon(points);
                }
            }
            // nose
            if (catch_foot_thick) {
                cft=catch_foot_thick*2;
                translate( [(cw/2)-(cfl/2),ym,cft/2] ) rotate([0,90,0]) 
                   capsule_qtr( cft, cfl, cfn);
            }
        }//clbody
        module spbar( p1, p2 ) {
            hull() { 
                translate( [ p1[0], p1[1], zp] )  sphalf( ccr );
                translate( [ p2[0], p2[1], zp] )  sphalf( ccr );
            }
        }
        module sphalf( sr ) {
            intersection(){
                cube( [sr*2, sr*2, sr] );
                translate([sr,sr,0]) sphere( r=sr, $fn=cfn );
            }
        }
        // cutout
        il = catch_tooth_xrat* (cwb -(ccr*2));
        ip= (cw/2)-(il/2);
        difference(){
            clbody();
            translate([ip,ch-ccr,0-CS]) cube( [il, ccr+catch_hole_xtra ,ccr+CS2]);
        }
    } // catch_clasp

    module magwart(td, ra=0, bttm=wall_thick ) {
        hfn = 32; // hole fn
        rotate( [-90,90,0] ) translate([0-td.x,0-td.y/2,0]) 
        gang(){ // color("white") %sphere(1); // where's that corner at now?
        difference(){
            magwart_shape( td );
            translate([bttm,0,wt]) 
              bs_shape( [td.x, td.y, td.z], magnet_d, magnet_h, magnet_slot_d, ra, hfn ) ;
        }//diff
        if (VIS){     
            translate( [(magnet_d/2),(td.y/2),wt] ) 
            color("red") %cylinder( d=magnet_d, h=magnet_h ); 
        }} // gang
    }//magwart

}// box_half

// =========================
// =========================