module KnurlTri(e=[16,9],r=10,h=30,depth=[1,+1],deltaH=[0,0],scale=1,lambda,center=false,name,help){
lambda=is_num(lambda)?[lambda,lambda*(sqrt(3)/2)]:lambda;
e=is_undef(lambda)?is_list(e)?e:[e,round(h/sqrt((sehne(r=r,n=e)*sqrt(3)/2)^2 - (r-Inkreis(e,r))^2  ) )]
                  : [round(360/gradS(s=lambda.x,r=r)),round(h/lambda.y)];
s=sehne(r=r,n=e[0]);
depth=is_list(depth)?depth:is_undef(depth)?s*sqrt(6)/3*[1,1]:[depth,depth];
deltaH=is_list(deltaH)?deltaH:[deltaH,deltaH];
winkel1=360/e[0];
levelH=h/e[1];


ir=Inkreis(e[0],r);
InfoTxt("KnurlTri",["Sehne",s,"winkel",2*atan2(s/2,norm([r-ir,levelH])),"Triangle Radius",str(norm([r-ir,levelH])/1.5,"/",s*sqrt(3)/3),"depth",depth,"e",e,"levelH",levelH],name);
HelpTxt("KnurlTri",["e",e,"r",r,"h",h,"depth",depth,"deltaH",deltaH,"scale",scale,"lambda",lambda,"center",center],help);

points=[
for(level=[0:e[1]])
let(
ri=r+r*(scale-1)/e[1]*level,
hCell=norm([ri - Inkreis(e[0],r+r*(scale-1)/e[1]*(level+1)) , levelH] ),
//hCell2=norm([Inkreis(e[0],ri) - r+r*(scale-1)/e[1]*(level+1) , levelH] ),
depth=depth+depth*(scale-1)/e[1]*level,
tilt1=atan2( Inkreis(e[0],ri)-(r+r*(scale-1)/e[1]*(level+1)),   levelH ),
tilt2=atan2( ri - Inkreis(e[0],(r+r*(scale-1)/e[1]*(level+1))), levelH ),
zero1=[-sin(tilt1)*(hCell/3+deltaH[0]),cos(tilt1)*(hCell/3+deltaH[0])],
zero2=[-sin(tilt2)*(hCell/1.5+deltaH[1]),cos(tilt2)*(hCell/1.5+deltaH[1])],
extr1=[cos(tilt1)*depth[0],sin(tilt1)*depth[0]],
extr2=[cos(tilt2)*depth[1],sin(tilt2)*depth[1]]
)

each[
  each arc(r=ri,fn=e[0]-1,deg=360-winkel1,z=level*levelH,rot=level%2?+0:winkel1/2),
 if(level<e[1]) each arc(r=Inkreis(e[0],ri)+extr1[0]+zero1[0],fn=e[0]-1,deg=360-winkel1,z=level*levelH+zero1[1]+extr1[1],rot=(level%2?+0:winkel1/2)+winkel1/2),
 if(level<e[1]) each arc(r=ri+extr2[0]+zero2[0],fn=e[0]-1,deg=360-winkel1,z=level*levelH+zero2[1]+extr2[1],rot=(level%2?+0:winkel1/2))
]
];

facesFloor=[for(i=[0:e[0]-1])i];
facesTop=[for(i=[-1:-1:-e[0]+0])i+len(points)];

facesTri1=[
 for(lev=[0:e[1]-1],i=[0:e[0]-1])
  each[
   [(i +1)%e[0],i,i+e[0]]+[1,1,1]*lev*e[0]*3,
   [i,(i+ (lev%2?+0:1))%e[0]+e[0]*3,i+e[0]]+[1,1,1]*lev*e[0]*3,
   [(i +(lev%2?+0:1))%e[0]+e[0]*3,(i+1)%e[0],i+e[0]] +[1,1,1]*lev*e[0]*3
  ]
];

facesTri2=[
 for(lev=[0:e[1]-1],i=[0:e[0]-1])
  each[
  [(i+ (lev%2?+1:+0))%e[0],i+e[0]*3,(i+ (lev%2?+1:+0))%e[0]+e[0]*2]+[1,1,1]*lev*e[0]*3,
  [(i+ (lev%2?+0:1))%e[0]+e[0]*3,i,i+e[0]*2]+[1,1,1]*lev*e[0]*3,
  [(i+1)%e[0]+e[0]*3,(i+ (lev%2?+1:0))%e[0]+e[0]*2,i+e[0]*3]+[1,1,1]*lev*e[0]*3,
  ]
];

faces=[
facesFloor,
facesTop,
each facesTri1,
each facesTri2
];

translate([0,0,center?-h/2:0])polyhedron(points=points,faces=faces,convexity=15);

}
/**
\name FlatKnurl
\page Objects
FlatKnurl() creates a knurled surface
\param s size [x,y,z]
\param lambda knurl size
\param base  base
\param opt  knulr pattern straight or diag and positive or negative single or cross knurl
\param center center
\param help help

*/

//FlatKnurl(opt=7,h=2,lambda=4);