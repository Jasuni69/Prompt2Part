module RSternFill( // needs checking
  
e=8,  //elements
d1=2,  // diameter nipples(convex) 
d2,  // diameter nipples(concave)
r1=5,  // radius 1
r2,  //radius 2
grad1=180, // angle nipples 1
grad2, // angle nipples 2
fn=fn,
messpunkt=false,
help
){
winkel=360/(e*2);



    //grad1=is_undef(grad)?grad1:grad; // konvex
    grad2=is_undef(grad2)?grad1-winkel*2:grad2; // konkav
    d2=is_undef(d2)?d1:d2;
        

    sekD1X=sin(grad1/2)*d1/2;
    sekD1Y=cos(grad1/2)*d1/2;     
    sekD2X=sin(grad2/2)*d2/2;
    sekD2Y=-cos(grad2/2)*d2/2;
    r=norm([sekD1X,r1+sekD1Y]);//connectionpoint radius
    r2=is_undef(r2)?Kathete(r,sekD2X)-sekD2Y:r2;
  if(messpunkt)rotate(-90){
      Pivot(p0=[sekD1X,r1+sekD1Y],txt="D1",active=[0,0,0,1,0,1]);    
      rotate(-winkel) Pivot(p0=[-sekD2X,r2+sekD2Y],txt="D2",active=[0,0,0,1,0,1]);
      //Tz(.1)Color()circle(r,$fn=200);
  }
    

    
    wk=[for(i=[0:e-1]) each concat(
    kreis(r=-d2/2,rot=90-winkel/2+i*winkel*2,rand=0,grad=-grad2,sek=true,t=RotLang(-winkel/2+i*winkel*2,r2),fn=fn)
    , kreis(r=d1/2,rot=90+winkel/2+i*winkel*2,rand=0,grad=grad1,sek=true,t=RotLang(winkel/2+i*winkel*2,r1),fn=fn)
    )];

  rotate(winkel/2-90)polygon(wk,convexity=5);
    
if(help)echo(str("<H3> <font color=",helpMColor,">Help RSternFill(e=",e,",r1=",r1,", r2=",r2," ,d1=",d1," ,d2=",d2, ",grad1=",grad1," ,grad2=",grad2," ,fn=",fn,", messpunkt=",messpunkt," help);"));
}





}//fold // Basic Objects ΔΔ
{//fold // \∇∇ Products ∇∇/ //

/** \page Products \name Bayonet
Bayonet() creates a bayonett mount in out
\param d diameter (out side + spiel*2)
\param l length of groove ([l,l] lock z pos between)
\param h length to cut above
\param lock z lower to lock
\param e number of nibs/grooves
\param nibH height of nib
\param nibR radius [top,out]
\param nibMitte nib center
\param spiel changes outer diameter and nibR
\param lap overlapping nib
\param invert switch nib from inside to outside
\param part [0:nib, 1: groove]
\param fs segmentsize of groove
\param name help name help
*/

/*
Bayonet(part=0,invert=1,pos=+0);
Bayonet(part=1,invert=1,pos=+0);
//*/