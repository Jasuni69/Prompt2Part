module sp_neck(diam,type,wall,id,style="L",bead=false, anchor, spin, orient)
{
    assert(num_defined([wall,id])==1, "Must define exactly one of wall and id");
    
    table = struct_val(_sp_specs,type);
    dum1=assert(is_def(table),"Unknown SP closure type.  Type must be one of 400, 410, or 415");
    entry = struct_val(table, diam);
    dum2=assert(is_def(entry), str("Unknown closure nominal diameter.  Allowed diameters for SP",type,": ",struct_keys(table)))
         assert(style=="L" || style=="M", "style must be \"L\" or \"M\"");

    T = entry[0];
    I = entry[1];
    H = entry[2];
    S = entry[3];
    tpi = entry[4];

    // a is the width of the thread 
    a = (style=="M" && tpi==12) ? 1.3 : struct_val(_sp_thread_width,tpi);

    twist = struct_val(_sp_twist, type);

    profile = _sp_thread_profile(tpi,a,S,style);

    depth = a/2;
    taperlen = 2*a;

    beadmax = type==400 ? (T/2-depth)+depth*1.25
            : diam <=15 ? (T-.15)/2 : (T-.05)/2;
    
    W = type==400 ? a*1.5      // arbitrary decision for type 400
                  : entry[6];  // specified width for 410 and 415

    beadpts = [
                [0,-W/2],
                each arc(16, points = [[T/2-depth, -W/2],
                                       [beadmax, 0],
                                       [T/2-depth, W/2]]),
                [0,W/2]
              ];

    isect400 = [for(seg=pair(beadpts)) let(segisect = line_intersection([[T/2,0],[T/2,1]] , seg, LINE, SEGMENT)) if (is_def(segisect)) segisect.y];

    extra_bot = type==400 && bead ? -min(column(beadpts,1))+max(isect400) : 0;
    bead_shift = type==400 ? H+max(isect400) : entry[5]+W/2;  // entry[5] is L

    attachable(anchor,spin,orient,r=bead ? beadmax : T/2, l=H+extra_bot){
        up((H+extra_bot)/2){
            difference(){
                union(){
                    thread_helix(d=T-.01, profile=profile, pitch = INCH/tpi, turns=twist/360, lead_in=taperlen, anchor=TOP);
                    cylinder(d=T-depth*2,h=H,anchor=TOP);
                    if (bead)
                      down(bead_shift)
                         rotate_extrude()
                            polygon(beadpts);
                }
                up(.5)cyl(d=is_def(id) ? id : T-a-2*wall, l=H-extra_bot+1, anchor=TOP);
            }
        }
        children();
    }
}



// Module: sp_cap()
// Synopsis: Creates an SPI threaded bottle cap.
// SynTags: Geom
// Topics: Bottles, Threading
// See Also: sp_neck()
// Usage:
//   sp_cap(diam, type, wall, [style=], [top_adj=], [bot_adj=], [texture=], [$slop]) [ATTACHMENTS];
// Description:
//   Make a SPI (Society of Plastics Industry) threaded bottle neck.  You must
//   supply the nominal outer diameter of the threads and the thread type, one of
//   400, 410 and 415.  The 400 type neck has 360 degrees of thread, the 410
//   neck has 540 degrees of thread, and the 415 neck has 720 degrees of thread.
//   You can also choose between the L style thread, which is symmetric and
//   the M style thread, which is an asymmetric buttress thread.  Note that it
//   is OK to mix styles, so you can put an L-style cap onto an M-style neck.  
//   .
//   The 410 and 415 caps have very long unthreaded sections at the bottom.
//   The bot_adj parameter specifies an amount to reduce that bottom extension, which might be
//   necessary if the cap bottoms out on the bead.  Be careful that you don't shrink past the threads,
//   especially if making adjustments to 400 caps which have a very small bottom extension.  
//   These caps often contain a cardboard or foam sealer disk, which can be as much as 1mm thick, and
//   would cause the cap to stop in a higher position.
//   .
//   You can also adjust the space between the top of the cap and the threads using top_adj.  This
//   will change how the threads engage when the cap is fully seated.
//   .
//   The inner diameter of the cap is set to allow 10% of the thread depth in clearance.  The diameter
//   is further increased by `2 * $slop` so you can increase clearance if necessary. 
//   .
//   Note: there is a published SPI standard for necks, but absolutely nothing for caps.  This
//   cap module was designed based on the neck standard to mate reasonably well, but if you
//   find ways that it does the wrong thing, file a report.  
// Arguments:
//   diam = nominal outer diameter of threads
//   type = thread type, one of 400, 410 and 415
//   wall = wall thickness
//   ---
//   style = Either "L" or "M" to specify the thread style.  Default: "L"
//   top_adj = Amount to reduce top space in the cap, which means it doesn't screw down as far.  Default: 0
//   bot_adj = Amount to reduce extension of cap at the bottom, which also means it doesn't screw down as far.  Default: 0
//   texture = texture for outside of cap, one of "knurled", "ribbed" or "none.  Default: "none"
//   $slop = Increase inner diameter by `2 * $slop`.  
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
// Examples:
//   sp_cap(48,400,2);
//   sp_cap(22,400,2);
//   sp_cap(22,410,2);
//   sp_cap(28,415,1.5,style="M");