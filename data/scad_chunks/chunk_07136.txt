T(15,15)PolyRund(p1,r=1,ir=2,ofs=1,delta=0,messpunkt=true);
T(30,15)PolyRund(p1,r=1,ir=2,ofs=0,delta=1,messpunkt=true);
T(45,15)PolyRund(p1,r=[0.5,0.5,2,3,2],ofs=0,delta=1,messpunkt=true,fn=[0,5,10,10,10],fs=undef);

}

// polyRund for 3D points offset chamfer and rounding corners
T(80,30){
fn=8;
p2=[for(z=[0:10]) each polyRund([for(p=p1)[p.x,p.y,z]],r=z/5,ofs=z==10?-1:0, fn=fn)];
PolyH(p2,loop=5*(fn+1));

}
// list of points (make sure to flatten with "each"

pointsList= [for (i =[0:15]) each kreis( r= 10 , z= i, fn= 6 ,rand=0)];
T(-20)PolyH(pointsList);

// single point ends 

sPointsList = [
               [0,0,-15],  // bottom end
               for (i=[-10:10] ) each quad(x=10+sin(i*18)*2,z=i,fn=12), // quad points from z = -10 ⇒ 10
               [0,0, 5]  // top end
];
T(-20,-20)PolyH(sPointsList,pointEnd=true,loop=12+4);  // loop = 4 corner arc with 4 points or 4× 3 fraqments + 4 sides between

// translating points 
dist=20;
rot=90;
pointsListTrans= [for (i =[0:5:rot]) each mPoints(
                                                 kreis( r= 10 , rand= 0 , z= 0, fn= 6 )
                                                ,r=[i],t=[0,dist])];

T(-50){
  PolyH(pointsListTrans, loop = 7);
  Points(pointsListTrans,hull=false,start=18*7,loop=7,center=false);
}

//  modified
union(){
  fn=5;

pointsListMOD= [for (i =[0:5:360]) each mPoints(
                                                 mPoints(kreis( r= 10 +sin(i)*5, rand= 0 ,grad= 90,rot=270, z= 0, fn= fn ),r=i)
                                                ,r=[i,0,0],t=[0,20])];

T(-85) {
  PolyH(pointsListMOD, loop = fn+1,end=false);
  Points(pointsListMOD,hull=false,loop=fn+1,start=30*(fn+1),mark=[0,len(pointsListMOD)-1]);