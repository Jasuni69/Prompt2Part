function path_torsion(path, closed=false) =
    assert(is_path(path,3), "Input path must be a 3d path")
    assert(is_bool(closed))
    let(
        d1 = deriv(path,closed=closed),
        d2 = deriv2(path,closed=closed),
        d3 = deriv3(path,closed=closed)
    ) [
        for (i=idx(path)) let(
            crossterm = cross(d1[i],d2[i])
        ) crossterm * d3[i] / sqr(norm(crossterm))
    ];


// Function: surface_normals()
// Synopsis: Estimates the normals to a surface defined by a {{point}} array
// Topics: Math, Geometry
// See Also: path_tangents(), path_normals()
// Usage:
//   normals = surface_normals(surf, [col_wrap=], [row_wrap=]);
// Description:
//   Numerically estimate the normals to a surface defined by a 2D array of 3d {{points}}, which can
//   also be regarded as an array of {{paths}} (all of the same length).  
// Arguments:
//   surf = surface in 3d defined by a 2D array of points
//   ---
//   row_wrap = if true then wrap path in the row direction (first index)
//   col_wrap = if true then wrap path in the column direction (second index)