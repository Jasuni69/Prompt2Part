module scs_bearing_block(type) { //! Draw the specified SCS bearing block
    vitamin(str("scs_bearing_block(", type[0], "): ", type[0], " bearing block"));

    T = type[1];
    h = scs_hole_offset(type);
    E = type[3];
    W = scs_size(type)[0];
    assert(W == 2 * E, str("W or E wrong for scs_bearing_block", type[0]));
    L = scs_size(type)[2];
    F = scs_block_center_height(type);
    G = scs_block_side_height(type);
    B = scs_screw_separation_x(type);
    C = scs_screw_separation_z(type);
    K = type[10];
    S1 = scs_screw(type);
    S2 = type[12];
    L1 = type[13];
    bearing = scs_bearing(type);
    clip = scs_circlip(type);

    boltHoleRadius = screw_clearance_radius(S1);
    footHeight = min(0.75, (G - bearing_dia(bearing) - 1.5) / 2); // estimate, not specified on drawings

    color(sks_bearing_block_colour) {
        linear_extrude(L, center = true) {
            bearingRadius = bearing_dia(bearing) / 2;
            // center section with bearing hole
            difference() {
                union() {
                    translate([-(B - 2 * boltHoleRadius) / 2, -h + footHeight])
                        square([B - 2 * boltHoleRadius, G - footHeight]);
                    for(m = [0, 1])
                        mirror([m, 0, 0])
                            translate([0 , G - h])
                                right_trapezoid(bearingRadius, bearingRadius -F + G, F - G);
                }
                circle(r = bearingRadius);
            }
            // add the sides
            for(m = [0, 1])
                mirror([m, 0, 0]) {
                    trapezoidX = boltHoleRadius - 0.5; // estimate, not specified on drawings
                    sideX = 2 * (K - boltHoleRadius - trapezoidX);
                    chamfer = 0.5;
                    assert(sideX > chamfer, "trapezoidX too large in scs_bearing_block");
                    translate([B / 2 + boltHoleRadius, -h]) {
                        square([sideX - chamfer, G]);
                        translate([sideX, 0])
                            rotate(90)
                                right_trapezoid(G - chamfer, G, chamfer);
                        translate([sideX, 0]) {
                            right_trapezoid(trapezoidX - footHeight, trapezoidX, footHeight);
                            translate([trapezoidX, footHeight])
                                rotate(90)
                                    right_trapezoid(T - footHeight, L1 - footHeight, trapezoidX);
                        }
                    }
                    translate([B / 2 - boltHoleRadius, -h])
                        mirror([1, 0, 0])
                            right_trapezoid(boltHoleRadius,  boltHoleRadius + footHeight, footHeight);
                }
        }
        // side blocks with bolt holes
        for(x = [-B / 2, B / 2])
            translate([x, G / 2 - h, 0])
                rotate([90, 0, 0])
                    linear_extrude(G, center = true)
                        difference() {
                            square([boltHoleRadius * 2, L], center = true);
                            for (y = [-C / 2, C / 2])
                                translate([0, y])
                                    circle(r = boltHoleRadius);
                        }
    }
    not_on_bom() no_explode() {
        spacer = scs_spacer(type);
        for(end = spacer ? [-1, 1] : 0)
            translate_z(end * (bearing_length(bearing) + spacer) / 2)
                    linear_bearing(bearing);

        for(end = [-1, 1])
            translate_z(end * ((spacer ? 2 * bearing_length(bearing) + spacer : bearing_length(bearing)) + circlip_thickness(clip)) / 2)
                rotate(180)
                    internal_circlip(clip);
    }
}