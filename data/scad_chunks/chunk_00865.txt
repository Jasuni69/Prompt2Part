module pin_header(type, cols = 1, rows = 1, smt = false, right_angle = false, cutout = false, colour) { //! Draw pin header
    pitch =  hdr_pitch(type);
    base_colour = colour ? colour : hdr_base_colour(type);
    h = pitch;
    ra_offset = 2.4;
    width = pitch * rows;

    module cutout()
        dogbone_rectangle([cols * pitch + 2 * panel_clearance, rows * pitch + 2 * panel_clearance, 100], center = false);

    if(cutout) {
        if(right_angle)
            translate_z(width / 2)
                rotate([-90, 0, 180])
                    cutout();
        else
            cutout();
    }
    else {
        vitamin(str("pin_header(", type[0], ", ", cols, ", ", rows,
                    arg(smt, false, "smt"), arg(right_angle, false, "right_angle"), "): Pin header ", cols, " x ", rows, right_angle ? " right_angle" : ""));

        translate_z(smt ? 3.5 - h : 0) {
            for(x = [0 : cols - 1], y = [0 : rows - 1]) {
                py = pitch * (y - (rows - 1) / 2);
                pin = [pitch * (x - (cols - 1) / 2), py, py + width / 2]; // Position of pin joint

                // Vertical part of the pin
                translate([pin.x, pin.y])
                    if(right_angle)
                        pin(type, hdr_pin_below(type) + (y + 0.5) * pitch);
                    else
                        pin(type);

                if(right_angle) {
                    w = hdr_pin_width(type);
                    // Horizontal part of the pin
                    translate([pin.x, pin.y - hdr_pin_below(type), pin.z])
                        rotate([-90, 0, 180])
                            let($solder = undef)
                                pin(type, hdr_pin_length(type) - hdr_pin_below(type) + ra_offset + y * pitch);

                    // corner
                    translate([pin.x, pin.y - w / 2, pin.z - w / 2])
                        rotate([0, -90, 0])
                            color(hdr_pin_colour(type))
                                rotate_extrude(angle = 90, $fn = fn)
                                    translate([0, -w / 2])
                                        square(w);
                }
            }
            // Insulator
            translate([0, right_angle ? -ra_offset - (rows - 1) * pitch / 2 : 0, right_angle ? width / 2 : 0])
                rotate([right_angle ? 90 : 0, 0, 0]) {
                    color(base_colour)
                        linear_extrude(h)
                            for(x = [0 : cols - 1], y = [0 : rows - 1])
                                translate([pitch * (x - (cols - 1) / 2), pitch * (y - (rows - 1) / 2), pitch / 2])
                                    hull() {
                                        chamfer = pitch / 4;
                                        square([pitch + eps, pitch - chamfer], center = true);

                                        square([pitch - chamfer, pitch + eps], center = true);
                                    }
                    if(show_plugs && hdr_pin_length(type) > 7)
                        color(housing_colour)
                            translate_z(h + eps)
                                linear_extrude(housing_height)
                                    square([cols * pitch , rows * pitch], center = true);
                }
        }
    }
}