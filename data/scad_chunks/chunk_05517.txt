function _prism_fillet_prism(name, basepoly, bot, top, d, k, N, overlap, uniform, smooth_normals,inside, debug)=
    let(
         inside=sign(inside), 
         top = yrot(-90,top),
         bot = yrot(-90,bot),
         basepoly = clockwise_polygon(basepoly),
         segpairs = pair(basepoly,wrap=true),
         isect_ind = [for (i=idx(top))
                         let(isect = _prism_line_isect(segpairs, [top[i], bot[i]], inside*top[i]))
                         assert(isect, str("Prism doesn't fully intersect prism (",name,")"))
                         isect
                     ],
         isect=column(isect_ind,0),
         index = column(isect_ind,1),
         uval = column(isect_ind,2),
         tangent = path_tangents(isect,closed=true)
     )
     d==0 ? yrot(90,[ 
                    isect,
                    if (overlap!=0) isect,
                    if (overlap!=0) 
                         [for(i=idx(isect))
                             let(normal = point3d(_getnormal(basepoly,index[i],uval[i],smooth_normals)))
                             isect[i]-unit(point3d(normal))*overlap
                         ]
                   ])
   : let(
         mesh = transpose([for(i=idx(top))
           let(
               normal = point3d(_getnormal(basepoly,index[i],uval[i],smooth_normals)),
               dir = inside*unit(cross(normal,tangent[i])),
               zpart = d*dir.z,
               length_needed = d*norm(point2d(dir)),
               edgept2d = _polygon_step(basepoly, index[i], uval[i], sign(cross(point2d(dir),point2d(normal))), length_needed),
               edgepoint = point3d(edgept2d[0],isect[i].z+zpart),
               corner = plane_line_intersection(plane_from_normal(point3d(_getnormal(basepoly, edgept2d[1],edgept2d[2],smooth_normals)),edgepoint),
                                                [top[i],isect[i]],
                                                bounded=false), // should be true, but fails to intersect sometimes at isect[i] end
               d_step = abs(d)*unit(top[i]-isect[i])+(uniform?isect[i]:corner),
               within_top = is_point_on_line(corner, [top[i],isect[i]], RAY),
               within_bottom = is_point_on_line(corner, [isect[i],top[i]], RAY, 1e-1),   // Not sure what epsilon should be here, but 0.1 units under the object seems OK
               dummy = within_bottom ? 0
                     : echo(str("Warning: fillet appears to be inside the ",name,
                                " object.  If so you can try changing 'smooth_normals' or 'uniform'"))
           )
           assert(within_top,str("Fillet does not fit.  Decrease size of fillet (",name,")."))
           assert(debug  || (top[i]-d_step)*(d_step-isect[i])>=0,
                   str("Unable to fit fillet, probably due to steep curvature of the prism (",name,").",
                     d_step," ",corner," ", edgepoint," ", isect[i], " ", top[i]
                     ))
           let(
                bez = _smooth_bez_fill([d_step,corner,edgepoint], k)
           )
           [ 
             each bezier_curve(bez, N, endpoint=true),
             if (overlap!=0) edgepoint-unit(point3d(normal))*overlap*inside
           ]
          ])
         )
        yrot(90,mesh);



// Module: prism_connector()
// Synopsis: Construct a filleted prism that connects objects
// SynTags: Geom
// Topics: Rounding, Extrusion, Sweep, Descriptions
// See Also: parent(), join_prism(), linear_sweep()
// Usage:
//   prism_connector(desc1, anchor1, desc2, anchor2, [spin_align=]);
// Description:
//   Given descriptions and anchors for two objects, construct a filleted prism that connects the
//   anchor points on those objects, with a filleted joint at each end.  This is an alternative interface
//   to {{join_prism()}}, and the arguments which describe the prism are the same.  You obtain the
//   object descriptions using {{parent()}}, which can enable prisms to be constructed between objects
//   at different levels in the object tree.  You can also connect an object with itself, for example to
//   create a hole through an object, or to create an interior connection through a hole.
//   If you specify a CENTER anchor for an object then the prism will be aimed at the object's CENTER anchor
//   and joined at a shifted anchor located on the object's surface.  
//   .
//   The prism will connect anchor points described by the two descriptions you supply.  The supported object
//   types are prismoids, VNFs, cylinders, spheres, and linear sweeps.  For prismoids and VNFs you can use any anchor on a face
//   or edge anchors that include edge geometry.  For spheres you can use any anchor.  In the case of cylinders and linear sweeps you can
//   attach to the flat top or bottom in any case, but for side attachments, the shape must not have scaling (so it cannot
//   be conical) and it must not have any shift.  Only right angle cylinders and extrusions are supported.
//   Anchors on the top and bottom edges are also not supported.  When connecting to an extrusion the selected anchor
//   point must lie on the surface of the shape.  This may requires setting `atype="intersect"` when creating the extrusion.
//   Because of how {{join_prism()}} works, the prism will always make a joint to the shape, but it may be in the wrong location
//   when the anchor point is not on the surface, something that may be particularly puzzling with CENTER anchors.  
//   .
//   If you want to shift the prism away from the anchor point you can do that using the `shift1` and `shift2` parameters.
//   For anchoring to a flat face, the shift is a 2-vector where the y direction corresponds to the direction of the anchor's spin.
//   For a cylinder or extrusion the shift must be a scalar and shifts along the axis.  For spheres, shift is not permitted.
//   .
//   You can rotate the prism by applying {{zrot()}} to your profile, but the `spin_align` option will enable you to rotate it
//   relative to the spin directions of the two descriptions you supply.  If you set `spin_align=1` then the Y direction of the
//   profile will align with the spin direction on object 1.  If you set `spin_align=2` then it will align with the spin direction on object 2.
//   You can also set `spin_align` to either 12 or 21 to get an average value between the spins of the two shapes.  The 12 and 21 options
//   produce the same result except when the spins are exactly 180 degrees apart.  The default is to align the spin with object 1.
//   .
//   When you connect to a flat surface, the prism may extend beyond the edge of the surface if it doesn't fit, and the same thing happens if
//   a connector runs off either end of a cylinder.  But if you connect to a sphere the prism must fully intersect it and if you connect to the curved side
//   of a cylinder or extrusion the prism must fully intersect the infinite extension of that object.  If the prism doesn't intersect
//   the curved surface in that required fashion, it will not be displayed and you will get an error.  You can debug errors
//   like this by setting `debug_pos=true` which debugs the prism position by displaying an unfilleted prism to help you understand why
//   your prism did not work.  Children are not rendered when `debug_pos=true`.  
//   .
//   Another failure can occur if your fillet is too large to accomodate the requested fillet size.  The fillet is constructed by offsetting every point
//   in the profile separately and for a large enough fillet size, concave profiles will cross each other, resulting in an invalid self-intersecting fillet.
//   Normally {{join_prism()}} will issue an error in this situation.  The `debug` parameter is passed through to {{join_prism()}} and
//   tells that module to display invalid self-intersecting geometry to help you understand the problem.
//   .
//   When connecting to an edge, artifacts may occur at the corners where the prism doesn't meet the object in the ideal fashion.
//   Adjsting the points on your prism profile so that a point falls close to the corner will achieve the best result, and make sure
//   that `smooth_normals` is disabled (the default for edges) because it results in a completely incorrect fillet in this case.
//   If you connect to an extrusion object, the default value for `smooth_normals` is true, which generally works better when
//   for a uniformly sampled smooth object, but if your object has corners you may get better results by setting `smooth_normals=false`.  
// Arguments:
//   profile = path giving cross section to extrude to create the connecting prism
//   desc1 = description of first object to connect
//   anchor1 = connection on point first object
//   desc2 = description of second object to connect
//   anchor2 = connection point on second object
//   ---
//   shift1 = shift connection point on object1, a scalar for cylinders, extrusions, or edges, a 2-vector for faces, not permitted for spheres
//   shift2 = shift connection point on object2, a scalar for cylinders, extrusions, or edges, a 2-vector for faces, not permitted for spheres
//   spin_align = align the spin of the connecting prism to specified object (1 or 2) or if you give 12 or 21, the average of the two spins.  Default: 1
//   scale = scale the profile by this factor at anchor2.  Default: 1
//   n = number of facets to use for the fillets.  Default: 15
//   n1 = number of facets at object1
//   n2 = number of facets at object2
//   fillet = fillet for both ends of the prism.  Default: 0
//   fillet1 = fillet for the joint at object1
//   fillet2 = fillet for the joint at object2
//   k = fillet curvature parameter for both ends.   Default: 0.7
//   k1 = fillet curvature parameter at object1
//   k2 = fillet curvature parameter at object2
//   uniform = set to false to get non-uniform filleting at both ends.  Default: true
//   uniform1 = set to false for non-uniform filleting at object1
//   uniform2 = set to false for non-uniform filleting at object2
//   overlap = amount of overlap of the prism fillet into both objects.  Default: 1
//   overlap1 = amount of overlap of the prism fillet into object1
//   overlap2 = amount of overlap of the prism fillet into object2
//   smooth_normals = controls whether normals are smoothed when the object is a prism or edge; no effect otherwise.  Default: false if object is an edge, true otherwise
//   smooth_normals1 = controls whether normals are smoothed when the object1 is a prism or edge; no effect otherwise. 
//   smooth_normals2 = controls whether normals are smoothed when the object2 is a prism or edge; no effect otherwise. 
//   debug = pass-through to the {{join_prism()}} debug parameter.  If true then various cases where the fillet self intersects will be displayed instead of creating an error.  Default: false
//   debug_pos = if set to true display an unfilleted prism instead of invoking {{join_prism()}} so that you can diagnose errors about the prism not intersecting the object.  Default: false
// Named Anchors:
//   "root" = Root point of the connector prism at the desc1 end, pointing out in the direction of the prism axis (anchor inherited from {{join_prism()}}
//   "end" = Root point of the connector prism at the desc2 end, pointing out in the direction of the prism axis (anchor inherited from {{join_prism()}}
// Example(3D,NoAxes,VPT=[11.5254,0.539284,6.44131],VPR=[71.8,0,29.2],VPD=113.4): A circular prism connects a prismoid to a sphere.  Note different fillet sizes at each length.  
//   circ = circle(r=3, $fn=48);
//   prismoid(20,13,shift=[-2,1],h=15) let(prism=parent())
//     right(30) zrot(20)spheroid(r=10,circum=true,$fn=48) let(ball=parent())
//       prism_connector(circ,prism,RIGHT,ball,LEFT,fillet1=4,fillet2=1);
// Example(3D,NoAxes,VPT=[17.1074,4.56034,8.8345],VPR=[71.8,0,29.2],VPD=126): Here we attach a rounded rectangular prism to a prismoid on the left and a regular prism (vnf geometry type) on the right.  Note that the long direction of the rectangle which was is the Y axis in the profile specification is aligned with the spin direction of the first object, the prismoid.  This is the default alignment for the prism and is equivalent to `spin_align=1`.  Note also that we can get away with having long rectangle sides that are not subdivided because the mating surfaces are flat.  
//   bar = rect([1,12],rounding=.4, $fn=32);
//   prismoid(20,15,h=19) let(p1=parent())
//     back(15)right(33)zrot(62)xrot(37)zrot(0) regular_prism(n=5, h=30, side=13) let(p2=parent())
//       prism_connector(bar, p1, RIGHT, p2, FACE(2), fillet=1);
// Example(3D,NoAxes,VPT=[17.1074,4.56034,8.8345],VPR=[71.8,0,29.2],VPD=126): Here is the same example with `spin_align=2` which aligns the connecting prism on the second object.  Note how it is now aligned parallel to the sides of the face where it attaches on the second object.  
//   bar = rect([1,12],rounding=.4, $fn=32);
//   prismoid(20,15,h=19) let(p1=parent())
//     back(15)right(33)zrot(62)xrot(37)zrot(0) regular_prism(n=5, h=30, side=13) let(p2=parent())
//       prism_connector(bar, p1, RIGHT, p2, FACE(2), fillet=1, spin_align=2);
// Example(3D,NoAxes,VPT=[17.1074,4.56034,8.8345],VPR=[71.8,0,29.2],VPD=126): Here the connector prism is aligned midway between the spins on the two described objects using `spin_align=12`.
//   bar = rect([1,12],rounding=.4, $fn=32);
//   prismoid(20,15,h=19) let(p1=parent())
//     back(15)right(33)zrot(62)xrot(37)zrot(0) regular_prism(n=5, h=30, side=13) let(p2=parent())
//       prism_connector(bar, p1, RIGHT, p2, FACE(2), fillet=3, spin_align=12);
// Example(3D,NoAxes,Med,VPT=[17.2141,0.995544,-0.788367],VPR=[55,0,25],VPD=140): Here we apply a shift on object 1. Since this object has a planar connection surface the shift is a 2-vector.  Note that the prism has shifted a little too far and is poking out of the cube it connects to.  When connecting to a planar surface there is no constraint on the extent of the connecting prism.  It may be much larger than the object it connects to.  Note also that the connection on the sphere has shifted to accomodate the change in direction of the prism. If you shift it just a little bit farther forward (perhaps to fit onto a larger cube) the connection to the sphere will fail because the prism doesn't fully intersect the sphere.  
//  circ = circle(r=3, $fn=64);
//  cuboid(21) let(cube=parent())
//    right(40) spheroid(r=15, circum=true,$fn=32) let(ball=parent()){
//      prism_connector(circ,cube,RIGHT, ball, [-1,0,.4], fillet=2);
//      %prism_connector(circ,cube,RIGHT, ball, [-1,0,.4], fillet=2,shift1=[-6,0]);
//    }
// Example(3D,NoAxes,VPT=[17.2141,0.995544,-0.788367],VPR=[55,0,25],VPD=140): In this case because of how the connecting prism is shifted, it does not fully intersect the sphere and you will get an error message stating this.  To understand what is happening you can enable the `debug_pos` option which displays an unfilleted prism. You can inspect the result and see that the edge of the prism will not intersect the sphere, especially after a fillet is added.   
//  circ = circle(r=3, $fn=64);
//  cuboid(25) let(cube=parent())
//    right(40) spheroid(r=15, circum=true,$fn=32) let(ball=parent())
//      prism_connector(circ,cube,RIGHT, ball, [-1,0,.4], fillet=4, shift1=[0,-6],debug_pos=true);
// Example(3D,Big,NoAxes,VPT=[15.9312,-2.44829,-4.47156],VPR=[55,0,25],VPD=155.556): Here two cylinders are connected using a prism shift a shift at each end.  Note that the shift is always along the axis of the cylinder.  Note that the prisms are a little above the faceted cylinders, exposing a small edge that is visible as a kind of dotted line where the fillet meets the cylinder.  Using the circum option to enlarge the cylinders will hide this edge inside the cylinders.
//   circ = circle(r=3, $fn=64);
//   zrot(-20)
//   ycyl(l=40,d=20) let(x=parent())
//     right(40) back(9) cyl(l=40,d=20) let(z=parent()){
//       prism_connector(circ, x, RIGHT, z, LEFT+FWD, fillet=2);
//       %prism_connector(circ, x, RIGHT, z, LEFT+FWD, fillet=2, shift1=-9, shift2=8);
//   }
// Example(Med,NoAxes,VPT=[18.1393,-0.425481,0.777083],VPR=[64.1,0,8.2],VPD=113.4): Here the model has an error and attachment point on the cylinder is on the wrong side so the prism passes through the cylinder.  The shape you see on the front is the base of the prism connector that would usually be buried inside an object.  Later we will see that this can be used for making holes.  
//   circ = circle(r=3, $fn=64);
//   prismoid(20,13,shift=[-2,1],h=15) let(a=parent())
//     right(30) fwd(9) rot([20,15,17]) cyl(r=10,h=30)
//       prism_connector(circ,parent(),FWD,a,RIGHT,fillet=2);
// Example(3D,NoAxes,VPT=[16.5169,0.0116901,1.07281],VPR=[79.5,0,336.7],VPD=91.854): Using the CENTER anchor lets you create a connection, especially for spheres and cylinders, that puts the connecting prism in the best spot, without the need to figure out what the right anchor is.  
//  circ = circle(r=3, $fn=64);
//  cuboid([18,10,20],anchor=LEFT) let(cube=parent())
//    move([11,-23,14])
//      sphere(d=10) let(ball=parent())
//        prism_connector(circ,cube,CTR,ball,CTR,fillet=2);
// Example(3D,NoAxes,VPT=[-3.84547,-8.36131,0.0624037],VPR=[71.1,0,15.9],VPD=113.4): You can still apply shifts with CENTER anchors.  In this case we shift the two connectors outward so that their fillets don't interfere on the cube.  Note that we give shift as a scalar, which is interpreted as shift in just the x direction.  
//  circ = circle(r=3, $fn=64);
//  cuboid([30,10,20]) let(cube=parent())
//    fwd(22)
//      xcopies(n=2,spacing=45)
//        cyl(d=10,h=10,circum=true,$fn=64) let(cyl=parent())
//          prism_connector(circ,cube,CTR,cyl,CTR,fillet1=3,fillet2=2,shift1=2*(2*$idx-1));
// Example(3D,NoAxes,VPT=[2.5679,-1.74152,15.5561],VPR=[72.5,0,14.5],VPD=113.4): Here is a center anchor connection using an extrusion
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   linear_sweep(flower, height=29,scale=1,atype="intersect")
//   let(sweep=parent())
//     move([24,-22,20]) sphere(d=10)
//       prism_connector(circle(r=2.2,$fn=32), sweep, CTR, parent(),CTR, fillet=2);
// Example(3D,NoAxes,VPT=[2.96309,-4.73627,6.77988],VPR=[55,0,25],VPD=113.4): The {{rounded_prism()}} module supplies anchors for its faces and edges that you can use with this module.  It also has an `atype="prismoid"` anchor type, which provides a prismoid geometry object.  This prismoid geometry is sometimes not accurate enough to find center anchors of rounded prism objects.  It will work properly only if your object could be constructed (without rounding) by the {{prismoid()}} module.  Here is an example where it works correctly.  Note that the top and bottom are rectangular and parallel to the XY plane.  If you instead use `atype="intersect"` with {{rounded_prism()}} then the CENTER anchor will be more robust, but the model below doesn't work in that case because the resulting object has VNF geometry, which {{attach()}} may not properly align.  
//  ellipse = ellipse([2,1.5],$fn=64);
//  cuboid([40,40,5]) let(cubeframe=parent())
//    align(TOP,LEFT)
//      rounded_prism(top=rect([10,15]), bottom=rect([14,21]), height=13,
//                    joint_sides=3, joint_top=3, atype="prismoid",anchor=BOT) 
//      let(first=parent())
//      restore(cubeframe)
//      align(TOP,RIGHT+BACK)
//        rounded_prism(top=rect([10,15]), bottom=rect([14,21]), height=17,
//                      joint_sides=3, joint_top=3, atype="prismoid",anchor=BOT) 
//        let(second=parent())
//          prism_connector(ellipse, first, CTR, parent(), CTR, fillet=2);
// Example(3D,NoAxes,VPT=[60.3443,19.0185,6.2929],VPR=[50.8,0,8.9],VPD=263.435): Here arbitrary rounded prisms are connected using CENTER anchors with `atype="intersect"`.  
//   shape1 = [[0,0],[22,-5],[41,27], [-3,21]];
//   shape2 = scale(1.5,[[-12,0],[14,0],[6,8],[0,30]]);
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]]/2;
//   rounded_prism(bottom=shape1,top=move([5,7],shape1), h=40, joint_top=5, joint_bot=5, joint_sides=7, atype="intersect")
//   let(first=parent())
//     move([70,15,12])
//     zrot(-72)
//     rounded_prism(bottom=shape2,top=move([9,11],shape2), h=37, joint_top=5, joint_bot=5, joint_sides=3, atype="intersect")
//     let(second=parent())
//       prism_connector(flower, first, CTR, second, CTR, fillet=2);
// Example(3D,NoAxes,Med,VPT=[21.6303,-17.7214,-1.32542],VPR=[25.8,0,344.4],VPD=60.2654):  Connecting to edges is possible but problems may arise.  In this example the skinny rectangular connector prism connects to edge anchors on the two cubes.  By default as usual it aligns its direction with the spin of the first object, so the prism lines up with the edge on the left hand cube.  Since the edges are not parallel, the prism does **not** align with the second edge.  When aligning a skinny object like this with an edge, artifacts are likely to occur if the connector doesn't align neatly with the edge, as happens on the second object.  
//   bar = subdivide_path(rect([2,12],rounding=.5, $fn=32),maxlen=.5,closed=true);
//   cuboid(30) let(big=parent())
//     move([35,-30,0]) rot(a=35,v=[-1,1,0]) cuboid(20)  let(small=parent())
//       prism_connector(bar, big, RIGHT+FWD, small, BACK+LEFT, fillet=1);
// Example(3D,NoAxes,Med,VPT=[21.6303,-17.7214,-1.32542],VPR=[25.8,0,344.4],VPD=60.2654):  Here with `spin_align=2` the prism now aligns neatly with the edge on the right hand cube.  In this case the artifacts that arise have lead to problems that prevent the shape from rendering in CGAL, but this can be worked around by decreasing `overlap` from its default of 1 to 0.5.  When the edges are not parallel, it is impossible to line the prism up with both at the same time: that would require the connecting prism to twist.  Setting `spin_align=12` will simply result in the prism aligning with **neither** edge.  
//   bar = subdivide_path(rect([2,12],rounding=.5, $fn=32),maxlen=.5,closed=true);
//   cuboid(30) let(big=parent())
//     move([35,-30,0]) rot(a=35,v=[-1,1,0]) cuboid(20)  let(small=parent())
//       prism_connector(bar, big, RIGHT+FWD, small, BACK+LEFT, fillet=1, spin_align=2, overlap=0.5);
// Example(3D,VPR=[80.9,0,55.8],VPT=[11.9865,-12.0228,4.48816],VPD=15.3187): As noted above, attaching to edges doesn't always produce a good looking result, and sometimes you may get unexpected errors about the fit of the fillet, or failure to render.  These things happen because the implementation assumes an approximately smooth shape, which is a bad assumption for edges.  You can even get artifacts when shapes appear neatly aligned with the edges.  For example, if you connect a circular prism to an edge you definitely want an even number of points so the top and bottom can line up with the edge.  But you may find that artifacts appear when you increase the point count like in this example below where the prism's joint to the edge has a little groove:
//   circ = circle(r=3, $fn=64);
//   cuboid(20) let(edge=parent())
//     move([30,-30,-8]) zrot(-45) cuboid(20) let(extra=parent())
//       prism_connector(circ, edge, RIGHT+FWD, extra, LEFT, fillet=2);
// Example(3D,VPR=[80.9,0,55.8],VPT=[11.9865,-12.0228,4.48816],VPD=15.3187): The artifact shown above occurs because of normals to the prism that cross the edge at a small angle.  You can remove it by either decreasing the number of points (32 works in this case) or as shown below, by stretching out the circle so that the top is flatter, which makes the normals parallel to the edge so they don't cross it.  Generally results will be best if you can get a point on the edge and if the top surface is perpendicular to the edge, or at least angled such that the a normal to the prism does not cross the edge when extended by the fillet distance.  
//   circ = xscale(1.2,circle(r=3, $fn=64));
//   cuboid(20) let(edge=parent())
//     move([30,-30,-8]) zrot(-45) cuboid(20) let(extra=parent())
//       prism_connector(circ, edge, RIGHT+FWD, extra, LEFT, fillet=2);
// Example(3D,VPR=[80.9,0,55.8],VPT=[11.9865,-12.0228,4.48816],VPD=15.3187): When no point falls on the edge you can get an artifact like this, where the connector prism is underneath the corner.  
//   circ = xscale(1.2,circle(r=3, $fn=31));
//   cuboid(20) let(edge=parent())
//     move([30,-30,-8]) zrot(-45) cuboid(20) let(extra=parent())
//       #prism_connector(circ, edge, RIGHT+FWD, extra, LEFT, fillet=2);
// Example(3D,NoAxes): We can attach to the top surface of a shifted cone, but when attaching to the curved surface, only a right angle cylinder is supported.
//   $fn=32;
//   flower = scale(.6,[for(theta=lerpn(0,360,90,endpoint=false)) (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]]);
//   cyl(d1=40, d2=30,h=30, shift=[4,9]) let(cone=parent())
//     up(40) back(30)xcyl(d=30,l=30,$fn=64,circum=true)
//       prism_connector(flower, cone, TOP, parent(), FWD+BOT, fillet=2.5);
// Example(3D,NoAxes,VPT=[2.33096,4.77324,9.30076],VPR=[85.8,0,358.4],VPD=102.06): This example scales the end of the prism, has different fillets at each end, and uses shifting to adjust its position.  
//  cyl(d=30,h=8) let(bot=parent())
//    up(20)right(8)xrot(-20)yrot(11)cyl(d=18,h=8) let(top=parent())
//      prism_connector(circle(d=20,$fn=64), bot, TOP, top, BOT, scale=0.4,
//                      fillet1=2.5, shift1=3,fillet2=2, shift2=[-2,-2.2]);
// Example(3D,NoAxes,VPT=[15.0136,12.2965,5.31287],VPR=[62.7,0,25.7],VPD=113.4): Here we connect a prism to a linear sweep.  (Note that you must use {{linear_sweep()}}, not linear_extrude().)
//  circ = circle(r=3, $fn=64);
//  flower = scale(.4,[for(theta=lerpn(0,360,180,endpoint=false)) (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]]);
//  zrot(-90)
//  linear_sweep(flower, h=22) let(sweep=parent())
//    zrot(90)right(40)zrot(15)yrot(12) cuboid(12) let(cube=parent())
//      prism_connector(circ,sweep,BACK,cube,LEFT,fillet=2);
// Example(3D,NoAxes): You can use the same object for `desc1` and `desc2` with different anchors to create a filleted hole.  Note that if you don't enlarge overlap from its default value of 1 then parts of the cylinder don't get removed by the difference.  
//   circ = circle(r=8, $fn=64);
//   back_half()
//   diff()
//     cyl(d=40,h=50,$fn=32)
//        tag("remove") prism_connector(circ,parent(),LEFT,parent(),RIGHT,
//                                      shift1=-8,shift2=7,fillet=6,overlap=3);
// Example(3D,NoAxes,VPT=[1.42957,2.47871,-3.63111],VPR=[40.3,0,29.2],VPD=263.435): You can also use interior connectors to bridge across holes as shown in this example.  Note also that you can apply operations like rotation to the connector.
//   circ = circle(r=3, $fn=64);
//   diff()
//     highlight_this() cyl(d=85,h=39)
//       tag("remove") cyl(d=75,h=40,$fn=128)
//       tag("keep") zrot_copies(n=4)
//         prism_connector(circ,parent(),[-1,.2],parent(),[1,.4],shift1=12,shift2=-12,fillet=2);
// Example(3D,Med,NoAxes,VPT=[1.42957,2.47871,-3.63111],VPR=[40.3,0,29.2],VPD=263.435): Here we use the {{zrot_copies()}} distributor to create copies of objects and create a connector to a non-symmetrically placed object.  All all the connectors are different because we change the anchor point that goes with the second description.
//   circ = circle(r=3, $fn=64);
//   right(4)up(25)xrot(15) cyl(r=20,h=30,circum=true,$fn=64) let(cyl=parent())
//     restore()
//     zrot_copies(n=5) right(40)zrot(45)cuboid(18)
//       prism_connector(circ, parent(), TOP, cyl, [cos(360/5*$idx), sin(360/5*$idx), 0], fillet1=3,fillet2=7);
// Example(3D,Med,NoAxes,VPT=[-4.51969,7.59952,4.54054],VPR=[48.7,0,30.6],VPD=361.364): In the previous example we used a distributor to create copies of an object and build connectors from those copies to a different object.  What if you want to create connectors between copies created by a distributor?  One powerful way to do this is to create an array of descriptions and use that array to make the connectors.  It's convenient to put your object into a module so you don't have to repeat it, but make sure that your module takes children, or the connectors won't run!  Here we create the objects first, and then we separately create the connectors as a child of a single hidden instance of the object.  That second construction is needed so we can get the description of the object, but we don't want it to show up in the model.
//   circ = circle(r=3, $fn=64);
//   module object() cuboid(18)children();
//   T_list = arc_copies(rx=80,ry=60,n=5,sa=0,ea=180);
//   for(T=T_list) multmatrix(T) object();
//   hide_this()object()
//     let(desc = transform_desc(T_list,parent()))
//     for(d=pair(desc))
//       prism_connector(circ, d[0], BACK, d[1], FWD, fillet=5);
// Example(3D,NoAxes,Med,VPT=[-4.51969,7.59952,4.54054],VPR=[48.7,0,30.6],VPD=361.364):  We can change the object in the above example to vary between cube and cylinder.  
//   circ = circle(r=3, $fn=64);
//   T_list = arc_copies(rx=80,ry=60,n=5,sa=0,ea=180);
//   module object(ind)
//       if (ind%2==0) cuboid(18)children();
//       else cyl(d=30,h=18,circum=true) children();
//   for(i=idx(T_list)) multmatrix(T_list[i]) object(i);
//   hide_this() object(0) let(even=parent())
//     hide_this() object(1) let(obj=[even,parent()], p=pair(T_list))
//       for(i=[0:len(T_list)-2])
//         prism_connector(circ, transform_desc(T_list[i],select(obj,i)),BACK,
//                               transform_desc(T_list[i+1],select(obj,i+1)), FWD,
//                         fillet=4);
// Example(3D,NoAxes,Med,VPT=[-0.963453,0.924861,-2.75661],VPR=[34,0,31.3],VPD=401.516): Another way to establish connections between objects is with {{desc_copies()}} which provides functions to access the descriptions of the other objects in the set.  Note that in OpenSCAD 2021.01 you cannot call `$prev()` and `$next()` directly.  In development versions you can call them directly and hence the example could be slightly simplified.  
//   circ = circle(r=3, $fn=64);
//   desc_copies(arc_copies(rx=80,ry=60,n=7,sa=0,ea=360))
//     spheroid(11,circum=true) let(next=$next,prev=$prev)
//        prism_connector(circ, prev(),BACK+LEFT, next(), FWD+LEFT, fillet=5, debug_pos=false);
// Example(3D,Med,NoAxes,VPT=[1.15472,1.59934,-3.16205],VPR=[55,0,25],VPD=361.364): Using CENTER anchors can make a construction like this much easier.  In this example the anchors need to shift around from the pointy end to the flat end of the ellipse, which would be annoying to calculate by hand.  
//   desc_copies(arc_copies(rx=85,ry=45,n=12)) let(next=$next)
//     cyl(d=15,h=27,circum=true,rounding=5,$fn=64) 
//       prism_connector(circle(r=3,$fn=32), parent(), CTR, next(), CTR, fillet=4);
// Example(3D,NoAxes,Med,VPT=[-3.18586,5.10784,4.59099],VPR=[58.5,0,19.4],VPD=325.228): When using {{desc_copies()}} with a varying shape you have to conditionally show only the correct shape for each index, but still specify all the shapes so you can collect their descriptions.  
//  circ = circle(r=3, $fn=64);
//  desc_copies(arc_copies(rx=60,ry=80,n=5,sa=-20,ea=200))
//     hide($idx%2==0?"cyl":"cube")
//     tag_this("cyl")cyl(d=30,h=30) let(cyl=parent())
//     tag_this("cube")cuboid([22,22,30])
//        let(
//             obj=[parent(),cyl],
//             next=$next,
//             shift=$idx%2==0?[0,6]:-6
//        )
//        if($idx<$count-2)
//          prism_connector(scale(.8,circ),
//                          select(obj,$idx),BACK,
//                          next(2,select(obj,$idx+2)), FWD, fillet=4,shift1=shift,debug_pos=false);
// Example(3D,NoAxes,Med,VPT=[15.3147,3.4204,-0.243801],VPR=[78.8,0,352.1],VPD=102.06): Here we create a connected pipe configuration by making the outside assembly of connected cylinders first, and then subtracting the interior assembly.  Note that a correction is needed to the shift in order to create uniform pipe walls because the length of the connector changes, so different shifts are needed to keep everything parallel.  
//  bigpipe_d=15;
//  smallpipe_d=9;
//  wall=1;
//  h=30;
//  fillet=3;
//  sep=30;
//  shift=5;
//  shift_fix=wall/(sep-bigpipe_d)*shift;
//  $fn=128;
//  back_half()
//    difference(){
//      // Pipe exterior 
//      cyl(d=bigpipe_d,h=h,circum=true) let(leftpipe=parent())
//      right(sep)
//        cyl(d=bigpipe_d,h=h,circum=true) let(rightpipe=parent())
//          prism_connector(circle(d=smallpipe_d,$fn=48),
//                          leftpipe, RIGHT, rightpipe, LEFT, fillet=fillet, shift2=shift);
//      // Interior that will be removed
//      cyl(d=bigpipe_d-2*wall,h=h+1,circum=true) let(leftpipe=parent())
//      right(sep)
//        cyl(d=bigpipe_d-2*wall,h=h+1,circum=true) let(rightpipe=parent())
//          prism_connector(circle(d=smallpipe_d-2*wall,$fn=48),
//                          leftpipe, RIGHT, rightpipe, LEFT, fillet=fillet,
//                          shift1=-shift_fix,shift2=shift+shift_fix);
//    }


// Get the object type from the specified geometry and anchor point

// Note that profile is needed just to find its dimensions for making a big enough edge profile