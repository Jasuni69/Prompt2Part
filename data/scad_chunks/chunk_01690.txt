module potentiometer(type, thickness = 3, shaft_length = undef, value = false) {//! Draw a potentiometer with nut spaced by specified thickness
    bh = pot_boss_h(type);
    s = pot_size(type);
    face =  pot_face(type);
    wafer =  pot_wafer(type);
    wafer_z = wafer? wafer.z : 0;
    round = len(pot_body(type)) < 4;
    dia_cast_colour = grey(60);
    thread_d = pot_thread_d(type);
    thread_h = pot_thread_h(type);
    shaft = pot_shaft(type);
    vitamin(str("potentiometer(", type[0], "): ", slice(type[0], start = -8) != "_encoder" ? "Potentiometer " : "", value ? value : type[0]));

    $fa = fa; $fs = fs;

    color(dia_cast_colour) {
        // Boss
        if(bh)
            cylinder(d = pot_boss_d(type), h = bh);

        if(face) {
            if(face.x) {
                linear_extrude(face.z)
                    square([face.x, face.y], center = true);

                linear_extrude(bh)
                    difference() {
                        square([face.x, face.y], center = true);

                        square([face.x - 2 * face.z, s.x], center = true);
                    }
            }
            translate_z(bh - face.z)
                linear_extrude(face.z)
                    intersection() {
                        circle(d = s.x - eps);

                        difference() {
                            square([s.x + eps, face.y], center = true);

                            if(face.x)
                                square([face.x - 2 * face.z, s.x], center = true);
                        }
                    }
        }

        // spigot
        x = pot_spigot_x(type);
        sp = pot_spigot(type);
        if(x)
            translate([x, 0, bh])
                vflip()
                    rounded_rectangle(sp + [0, 0, bh], pot_spigot_r(type));
        // thread
        vflip()
            if(show_threads)
                male_metric_thread(thread_d, pot_thread_p(type), thread_h, center = false, bot = 0, colour = dia_cast_colour);
            else
                cylinder(d = thread_d, h = pot_thread_h(type));
    }

    d = pot_body(type);
    fz = face ? face.z : 0;
    gap = face ? face.z + tab[1] : 0;
    total_h = s.z - bh;
    gangs = pot_gangs(type);
    gang_h = (total_h - (gangs - 1) * gap) / gangs;
    pitch = gang_h + gap;
    for(i = [0 : gangs - 1])
        translate_z(bh + i * pitch) {
            // Wafer that carries the track and contacts
            if(wafer)
                color("sienna") {
                    linear_extrude(wafer.z) round(wafer[3] ? 1 : 0) {
                        if(round)
                            circle(d = s.x - eps);
                        else
                            rounded_square([s.x, s.y], d[3]);

                        intersection() {
                            translate([0, -s.y / 2])
                                square([wafer.x, (wafer.y - s.y) * 2], center = true);

                            if(wafer[3])
                                circle(wafer.y - s.y / 2);
                            else
                                square(100, center = true);
                        }
                    }
                }

            color(silver) {
                // Body
                translate_z(wafer_z)
                    if(round)
                        rounded_cylinder(r = s.x / 2, r2 = d[2], h = gang_h - wafer_z);
                    else
                        rounded_rectangle([s.x, s.y, gang_h - wafer_z], d[3]);

                // Make tabs that hold the face on
                if(face) {
                    translate_z(-tab[1] - fz)
                        linear_extrude(face.z + tab[1] + wafer_z)
                            intersection() {
                                circle(d = s.x);

                                for(x = [-1, 1], y = [-1, 1], a = y * 90 + 90 + x * 30)
                                    rotate(a)
                                        translate([s.x / 2, 0])
                                            slot(r = tab.x / 2, l = (s.x - pot_boss_d(type)) / 2 - tab.x / 2, h = 0);
                            }
                }
            }

            // Face plate between sections
            if(face && i) {
                color(dia_cast_colour)
                    translate_z(-fz)
                        linear_extrude(fz)
                            intersection() {
                                circle(d = s.x - eps);

                            square([s.x + eps, face.y], center = true);
                         }

                color(shaft[4])
                    vflip()
                        cylinder(d = shaft.x, h = gap);
            }
        }

    // Shaft
    color(shaft[4])
        translate_z(-thread_h) vflip() {
                shaft_z = is_undef(shaft_length) ? shaft.z : min(shaft_length, shaft.z);
                flat_h = shaft[3] - (shaft.z - shaft_z);
                plain = shaft_z - flat_h;
                neck = pot_neck(type);
                neck_h = neck[1];

                if(neck_h)
                    cylinder(d = neck.x, h = neck_h);

                if(plain - neck_h > 0)
                    translate_z(neck_h)
                        cylinder(d = shaft.x, h = plain - neck_h);

                if(flat_h)
                    translate_z(plain)
                        linear_extrude(flat_h)
                            difference() {
                                circle(d = shaft.x);

                                if(shaft.y > shaft.x / 2)
                                    translate([0, shaft.x / 2])
                                        square([shaft.x, 2 * (shaft.x - shaft.y)], center = true);
                                else
                                    if(shaft.y)
                                        square([shaft.y, shaft.x + 1], center = true);
                            }
            }
}