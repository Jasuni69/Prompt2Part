function rounded_path(path) = //! Convert a rounded_path, consisting of a start coordinate, vertex / radius pairs and then an end coordinate, to a path of points for sweep.
    let(len = len(path)) assert(len > 3 && len % 2 == 0) [
        path[0],                                        // First point has no radius
        for(i = [1 : 2 : len - 3]) let(                 // Step through the vertices with radii, i.e. not the first or last
            prev = max(i - 2, 0),                       // Index of previous point, might be the first point, which is a special case
            p0 = path[prev],                            // Point before the vertex
            p1 = path[i],                               // Vertex
            r = path[i + 1],                            // Radius of shortcut curve
            p2 = path[i + 2],                           // Point after the vertex
            v1 = assert(Len(p0) == 3, str("expected path[", prev,  "] to be a vertex coordinate, got ", p0))
                 assert(Len(p1) == 3, str("expected path[", i,     "] to be a vertex coordinate, got ", p1))
                 assert(Len(p2) == 3, str("expected path[", i + 2, "] to be a vertex coordinate, got ", p2))
                 assert(is_num(r),    str("expected path[", i + 1, "] to be a radius, got ", r))
            p0 - p1,                                    // Calculate vectors between vertices
            v2 = p2 - p1,
            a = angle_between(v1, -v2),                 // Angle turned through
            d = r * tan(a / 2),                         // Distance from vertex to tangents
            room = min(norm(v1), norm(v2)),             // Maximum distance
            arc_start = assert(d <= room,
                str("Can't fit radius ", r, " into corner at vertex path[", i, "] = ", p1, " only room for radius ", room / tan(a / 2)))
                p1 + unit(v1) * d,                      // Calc the start position
            z_axis = unit(cross(v1, v2)),               // z_axis is perpendicular to both vectors
            centre = arc_start + unit(cross(z_axis, v1)) * r, // Arc center is a radius away, and perpendicular to v1 and the z_axis.
            x_axis = arc_start - centre,                // Make the x_axis along the radius to the start point, includes radius a scale factor
            y_axis = cross(x_axis, z_axis),             // y_axis perpendicular to the other two
            sides = ceil(r2sides(r) * a / 360)          // Sides needed to make the arc
        )
        for(j = [0 : sides], t = a * j / sides)         // For each vertex in the arc
            cos(t) * x_axis + sin(t) * y_axis + centre, // Circular arc in the tiled xy plane.
        path[len - 1],                                  // Last point has no radius
    ];