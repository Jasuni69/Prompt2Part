module iec(type) { //! Draw specified IEC connector
    vitamin(str("iec(", type[0], "): ", iec_part(type)));

    pin_w = 2;
    pin_d = 4;
    pin_h1 = 12;
    pin_h2 = 15;
    pin_chamfer = 1;

    module pin(h)
        color("silver")
            hull() {
                translate_z(h / 2)
                    cube([pin_w - pin_chamfer, pin_d - pin_chamfer, h], center = true);

                translate_z((h - pin_chamfer) / 2)
                    cube([pin_w, pin_d, h - pin_chamfer], center = true);
            }

    socket_w  = 24.5;
    socket_w2 = 14;
    socket_h  = 16.34;
    socket_h2 = socket_h - (socket_w - socket_w2);
    socket_d  = 17;
    socket_r = 3;
    socket_r2 = 0.5;
    socket_offset = iec_bezel_h(type) / 2 - socket_h / 2  - (iec_bezel_w(type) - socket_w) / 2;

    bw = iec_body_w(type);
    bh = iec_body_h(type);
    br = iec_body_r(type);
    can = iec_can(type);

    module socket_shape()
        hull()
            for(side = [-1, 1]) {
                translate([side * (socket_w / 2 - socket_r), -socket_h / 2 + socket_r])
                    circle(socket_r);

                translate([side * (socket_w / 2 - socket_r2), socket_h2 / 2 - socket_r2])
                    circle(socket_r2);

                translate([side * (socket_w2 / 2 - socket_r2), socket_h / 2 - socket_r2])
                    circle(socket_r2);
            }

    module oriffice_shape()
        translate([0, socket_offset])
            if(iec_male(type))
                difference() {
                    offset(2)
                        socket_shape();

                    difference() {
                        offset(-1) socket_shape();

                        translate([0, 2])
                            square([2.4, 5], center = true);

                        for(side = [-1, 1])
                            translate([side * 7, -2])
                                square([2.4, 5], center = true);
                    }
                }
            else
                socket_shape();

    module body_shape() {
        hull() {
            bw2 = iec_body_w2(type);
            bh2 = bh - (bw - bw2);
            br2 = can ? br : 1;

            for(side = [-1, 1]) {
                translate([side * (bw / 2 - br), -bh / 2 + br])
                    circle4n(br);

                translate([side * (bw / 2 - br2), bh2 / 2 - br2])
                    circle4n(br2);

                translate([side * (bw2 / 2 - br2), bh / 2 - br2])
                    circle4n(br2);
            }
        }
    }

    translate_z(can ? can.z : 0) {
        color(grey(20)) {
            // Flange
            flange_t = iec_flange_t(type);
            linear_extrude(flange_t)
                difference() {
                    hull() {
                        rounded_square([iec_flange_w(type), iec_flange_h(type)], iec_flange_r(type));

                        iec_screw_positions(type)
                            circle(d = iec_width(type) - iec_pitch(type));
                    }
                    oriffice_shape();

                    iec_screw_positions(type)
                        circle(socket_r);
                }
            head_r = screw_head_radius(iec_screw(type));
            screw_r = screw_clearance_radius(iec_screw(type));
            iec_screw_positions(type)
                rotate_extrude()
                    difference() {
                        translate([screw_r, 0])
                            square([socket_r - screw_r, flange_t]);

                        translate([0, flange_t - head_r])
                            rotate(45)
                                square(10);
                    }
            // Bezel
            translate_z(iec_flange_t(type))
                linear_extrude(iec_bezel_t(type))
                    difference() {
                        rounded_square([iec_bezel_w(type), iec_bezel_h(type)], iec_bezel_r(type));

                        oriffice_shape();
                    }

            // Body
            h = socket_d - iec_flange_t(type) - iec_bezel_t(type);
            offset = can ? - can.z : 0;
            translate_z(-h)
                linear_extrude(h)
                    difference() {
                        offset(offset)
                            body_shape();

                        oriffice_shape();
                    }
            // Back
            depth_offset = can ? br : 0;
            translate_z(-iec_depth(type) + depth_offset)
                linear_extrude(iec_depth(type) - h- depth_offset)
                    offset(offset)
                        body_shape();
        }
        // Can for filters
        if(can)
            color(silver)
                hflip() {
                    linear_extrude(iec_depth(type) - br)
                        difference() {
                            body_shape();

                            offset(-can.z)
                                body_shape();
                        }

                    translate_z(iec_depth(type) - br)
                        rounded_top_rectangle([bw, bh, br], br, br - 1);

                    linear_extrude(can.z)
                        difference() {
                            hull() {
                                rounded_square([can.x, can.y], iec_flange_r(type));

                                iec_screw_positions(type)
                                    circle(d = can[3] - iec_pitch(type));
                            }
                            offset(1)
                                oriffice_shape();

                            iec_screw_positions(type)
                                circle(socket_r);
                        }
                }

        if(!iec_male(type))
            translate([0, socket_offset, iec_flange_t(type) + iec_bezel_t(type) - socket_d]) {
                translate([0, 2])
                    pin(pin_h2);

                for(side = [-1, 1])
                    translate([side * 7, -2])
                        pin(pin_h1);
            }
        for(spade = iec_spades(type))
            translate([spade[2], spade[3], -iec_depth(type)])
                rotate([180, 0, spade[4]]) {
                    spade(spade[0], spade[1]);

                    if(can && spade[3] < 0)
                        color(grey(20))
                            rounded_rectangle([10, 5.25, 2], 1);
                }
    }
}