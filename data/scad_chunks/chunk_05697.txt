function ring(n,ring_width,r,r1,r2,angle,d,d1,d2,cp,points,corner, width,thickness,start, long=false, full=true, cw=false,ccw=false) =
    let(
        r1 = is_def(r1) ? assert(is_undef(d),"Cannot define r1 and d1")r1
           : is_def(d1) ? d1/2
           : undef,
        r2 = is_def(r2) ? assert(is_undef(d),"Cannot define r2 and d2")r2
           : is_def(d2) ? d2/2
           : undef,
        r = is_def(r) ? assert(is_undef(d),"Cannot define r and d")r
          : is_def(d) ? d/2
          : undef,
        full = is_def(angle) ? false : full
    )
    assert(is_undef(start) || is_def(angle), "start requires angle")
    assert(is_undef(angle) || !any_defined([thickness,width,points,corner]), "Cannot give angle with points, corner, width or thickness")
    assert(!is_vector(angle,2) || abs(angle[1]-angle[0]) <= 360, "angle gives more than 360 degrees")
    assert(is_undef(points) || is_path(points,2), str("Points must be a 2d vector",points))
    assert(!any_defined([points,thickness,width]) || num_defined([r1,r2])==0, "Cannot give r1, r2, d1, or d2 with points, width or thickness")
    is_def(width) && is_def(thickness)?
       assert(!any_defined([cp,points,angle,start]), "Can only give 'ring_width', 'r' or 'd' with 'width' and 'thickness'")
       assert(all_positive([width,thickness]), "Width and thickness must be positive")
       assert(num_defined([r,ring_width])==1, "Must give 'r' or 'ring_width' (but not both) with 'width' and 'thickness'")
       ring(n=n,r=r,ring_width=ring_width,points=[[width/2,0], [0,thickness], [-width/2,0]],full=full)
  : full && is_undef(cp) && is_def(points) ?
       assert(is_def(points) && len(points)==3, "Without cp given, must provide exactly three points")
       assert(num_defined([r,ring_width]), "Must give r or ring_width with point list")
       let(
            ctr_rad = circle_3points(points),
            dummy=assert(is_def(ctr_rad[0]), "Collinear points given to ring()"),
            part1 = move(ctr_rad[0],circle(r=ctr_rad[1], $fn=is_def(n) ? n : $fn)),
            first_r = norm(part1[0]-ctr_rad[0]),
            r = is_def(r) ? r : first_r+ring_width,
            part2 = move(ctr_rad[0],circle(r=r, $fn=is_def(n) ? n : $fn))
       )
       assert(first_r!=r, "Ring has zero width")
       (first_r>r ? [part1, reverse(part2)] : [part2, reverse(part1)])
  : full && is_def(corner) ?
       assert(is_path(corner,2) && len(corner)==3, "corner must be a list of 3 points")
       assert(!any_defined([thickness,width,points,cp,angle.start]), "Conflicting or invalid parameters to ring")
       let(parmok = (all_positive([r1,r2]) && num_defined([r,ring_width])==0) 
                      || (num_defined([r1,r2])==0 && all_positive([r]) && is_finite(ring_width)))
       assert(parmok, "With corner must give (r1 and r2) or (r and ring_width), but you gave some other combination")
       let(
           newr1 = is_def(r1) ? min(r1,r2) : min(r,r+ring_width),
           newr2 = is_def(r2) ? max(r2,r1) : max(r,r+ring_width),
           data = circle_2tangents(newr2,corner[0],corner[1],corner[2]),
           cp=data[0]
       )
       [move(cp,circle($fn=is_def(n) ? n : $fn, r=newr2)),move(cp, circle( $fn=is_def(n) ? n : $fn, r=newr1))]
  : full && is_def(cp) && is_def(points) ?
       assert(in_list(len(points),[1,2]), "With cp must give a list of one or two points.")
       assert(num_defined([r,ring_width]), "Must give r or ring_width with point list")
       let(
           first_r=norm(points[0]-cp),
           part1 = move(cp,circle(r=first_r, $fn=is_def(n) ? n : $fn)),
           r = is_def(r) ? r : first_r+ring_width,
           part2 = move(cp,circle(r=r, $fn=is_def(n) ? n : $fn))
       )
       assert(first_r!=r, "Ring has zero width")
       first_r>r ? [part1, reverse(part2)] : [part2, reverse(part1)]
  : full || angle==360 || (is_vector(angle,2) && abs(angle[1]-angle[0])==360) ?
      let(parmok = (all_positive([r1,r2]) && num_defined([r,ring_width])==0) 
                     || (num_defined([r1,r2])==0 && all_positive([r]) && is_finite(ring_width)))
      assert(parmok, "Must give (r1 and r2) or (r and ring_width), but you gave some other combination")
      let(
          newr1 = is_def(r1) ? min(r1,r2) : min(r,r+ring_width),
          newr2 = is_def(r2) ? max(r2,r1) : max(r,r+ring_width),
          cp = default(cp,[0,0])
      )
      [move(cp,circle($fn=is_def(n) ? n : $fn, r=newr2)),move(cp, circle( $fn=is_def(n) ? n : $fn, r=newr1))]
  :  let(
         parmRok = (all_positive([r1,r2]) && num_defined([r,ring_width])==0) 
                     || (num_defined([r1,r2])==0 && all_positive([r]) && is_finite(ring_width)),
         pass_r = any_defined([points,thickness]) ? assert(!any_defined([r1,r2]),"Cannot give r1, d1, r2, or d2 with a point list or width & thickness")
                                                    assert(num_defined([ring_width,r])==1, "Must defined exactly one of r and ring_width when using a pointlist or width & thickness")
                                                    undef 
                : assert(num_defined([r,r2])==1,"Cannot give r or d and r1 or d1") first_defined([r,r2]),
         base_arc = clockwise_polygon(arc(r=pass_r,n=n,angle=angle,cp=cp,points=points, corner=corner, width=width, thickness=thickness,start=start, long=long, cw=cw,ccw=ccw,wedge=true)),
         center = base_arc[0],
         arc1 = list_tail(base_arc,1),
         r_actual = norm(center-arc1[0]),
         new_r = is_def(ring_width) ? r_actual+ring_width
               : first_defined([r,r1]),
         pts = [center+new_r*unit(arc1[0]-center), center+new_r*unit(arc1[floor(len(arc1)/2)]-center), center+new_r*unit(last(arc1)-center)],
         second=arc(n=n,points=pts),
         arc2 = is_polygon_clockwise(second) ? second : reverse(second) 
     ) new_r>r_actual ? concat(arc2, reverse(arc1)) : concat(arc1,reverse(arc2));


// Function&Module: glued_circles()
// Synopsis: Creates a shape of two circles joined by a curved waist.
// SynTags: Geom, Path
// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable
// See Also: circle(), ellipse(), egg(), keyhole()
// Usage: As Module
//   glued_circles(r/d=, [spread], [tangent], ...) [ATTACHMENTS];
// Usage: As Function
//   path = glued_circles(r/d=, [spread], [tangent], ...);
// Description:
//   When called as a function, returns a 2D path forming a shape of two circles joined by curved waist.
//   When called as a module, creates a 2D shape of two circles joined by curved waist.  Uses "hull" style anchoring.  
// Arguments:
//   r = The radius of the end circles.
//   spread = The distance between the centers of the end circles.  Default: 10
//   tangent = The angle in degrees of the tangent point for the joining arcs, measured away from the Y axis.  Default: 30
//   ---
//   d = The diameter of the end circles.
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
// Examples(2D):
//   glued_circles(r=15, spread=40, tangent=45);
//   glued_circles(d=30, spread=30, tangent=30);
//   glued_circles(d=30, spread=30, tangent=15);
//   glued_circles(d=30, spread=30, tangent=-30);
// Example(2D): Called as Function
//   stroke(closed=true, glued_circles(r=15, spread=40, tangent=45));