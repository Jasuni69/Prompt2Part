module Roof(height,h,base=0,deg=45,opt=1,floor=false,center=false,twist=0,scale=1,fn=0,convexity=5,lap=0.0001,on=true,name,help,slices,segments,fs=fs){


deg=is_list(deg)?deg:[deg,deg];
s=[deg[0]%90?tan(deg[0]):1,deg[1]%90?tan(deg[1]):1];
iopt=is_list(opt)?opt:[opt,opt];
opt=iopt;//[ s[0]<0?0:iopt[0], s[1]<0?0:iopt[1] ];
floor=is_list(h)?true:floor;
h=is_list(h)?h:[floor?h:0,h];
lap=is_list(lap)?lap:[h[0]?lap:0,lap];
//iSize=max(viewportSize,max(printBed)*2);
ifn=$fn;
base=height&&is_num(h[1])&&is_num(h[0])?height-h[0]-h[1]:base;
ofs=[s[0]<0?-h[0]*tan(90-deg[0]):0,s[1]<0?-tan(90-deg[1])*h[1]:0];

on=version()[0]>2021?on:0;
$idxON=false;

InfoTxt("Roof",["h",h,"deg",str(deg,"° (",s,")")],name);
if(twist)InfoTxt("Roof",["twist",str(twist/base,"°/mm"),"base",base],name,$tab=is_undef($tab)?1:$tab+1);


Echo("Roof is experimental - use Dev Snapshot version and activate",color="warning",condition=version()[0]<2022);

  if(base)Tz(on?(center?0:h[0]?h[0]:0):0){
  $tab=is_undef($tab)?1:b($tab,false)+1;
  $idx=is_undef($idx)?0:$idx;
    Tz(center?0:-lap[0])rotate(twist/base*lap[0])linear_extrude(base+(on?vSum(lap):h[0]+h[1]),center=b(center,true),twist=twist/base*(base+(on?vSum(lap):h[0]+h[1])),scale=scale,convexity=convexity,$fn=fn,slices=slices,segments=segments,$fs=fs){
    $fn=ifn;
    children();
    }
  }
  
 if(on){ 
 $idx=is_undef($idx)?base?1:0:$idx;
 $noInfo=true;
 $info=false;
 //top
  if(scale&&(h[1]||is_undef(h[1])))Tz( (center?base/2:base+(h[0]?h[0]:0))+(s[1]<0?h[1]:0) )intersection(){
  scale([1,1,s[1]])roof(method=opt[1]?"voronoi":"straight",$fn=fn,$fs=fs,convexity=convexity)offset(delta=ofs[1]){
  $fn=ifn;
  scale(scale)rotate(-twist)children(); // experimental feature comment out if not activated in preferences
  }
  //if(h[1])translate([0,0,(h[1]+iSize/2)*sign(s[1])])cube([iSize,iSize,iSize],true);// if using difference
  //if(h[1])cube([iSize,iSize,h[1]*2],true); // for intersection
  
  //if(h[1])translate([0,0,(h[1]+iSize/2)*sign(s[1])])rotate(-twist)linear_extrude(iSize,center=true,convexity=convexity)offset(delta=1)scale(scale)children();// if using difference
   if(h[1])translate([0,0,sign(s[1])>0?0:-h[1]])linear_extrude(h[1],center=false,convexity=convexity)offset(delta=1+sign(s[1])>0?0:h[1]*tan(-90+deg[1]))scale(scale)rotate(-twist)children();// if using intersection
  
  }
  
 //bottom
  if(floor&&(h[0]||is_undef(h[0])))Tz((center?-base/2:(h[0]?h[0]:0))+(s[0]<0?-h[0]:0))intersection(){
    scale([1,1,-s[0]])roof(method=opt[0]?"voronoi":"straight",$fn=fn,$fs=fs,convexity=convexity)offset(delta=ofs[0]){
    $fn=ifn;
    $idx=(scale&&(h[1]||is_undef(h[1])))||base?1:0;
    children(); // experimental feature comment out if not activated in preferences
    }
    //if(h[0])cube([iSize,iSize,h[0]*2],true);//for intersection
    //if(h[0])translate([-iSize/2,-iSize/2,-h[0]])mirror([0,0,1])cube(iSize);//for difference 
    //if(h[0])translate([0,0,(-h[0]-iSize/2)]*sign(s[0]))cube(iSize,true);//for difference
    
    //if(h[0])translate([0,0,(-h[0]-iSize/2)]*sign(s[0]))linear_extrude(iSize,center=true,convexity=convexity)offset(delta=1)children();//for difference
    if(h[0])translate([0,0,sign(s[0])>0?-h[0]:0])linear_extrude(h[0],center=0,convexity=convexity)offset(delta=1+sign(s[0])>0?0:h[0]*tan(-90+deg[0]))children();//for intersection
    }
  }


HelpTxt("Roof",["height",height,"h",h,"base",base,"deg",deg,"opt",opt,"floor",floor,"center",center,"twist",twist,"scale",scale,"fn",fn,"convexity",convexity,"lap",lap,"on",on,"name",name,"slices",slices,"segments",segments,"fs",fs],help);
}



/** \page Generator
 \name LinEx
 LinEx()  linear extrudes child  polygon
 \param h height
 \param h2 height bottom
 \param h22 heigt top
 \param scale scale bottom
 \param scale2 scale top
 \param twist twist center
 \param twistcap twist top/bottom
 \param slices slices
 \param $d $r polygon size for angle calculation
 \param grad  calculate scale from $d/$r for angle
 \param grad2 angle (optional) for top
 \param center center result
 \param end   rotate extrude ends
 \param fnEnd   number of fragments for end
 \param lap overlap with center
 \param scaleCenter scale center
 \param gradC angle center ↦ scaleCenter
 \param convexity convexity
 \param name  name to identify
 \param help activate help
*/

 //LinEx(25,2,end=true,gradC=88,$d=5)circle($r);
 //LinEx(25,2,end=true,scaleCenter=[0.8,0.7],scale=[.8,1],$d=[7,9])square($r);