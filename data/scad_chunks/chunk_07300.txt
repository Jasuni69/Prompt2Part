function latch(mirror=[1,1],latch=0.5,dicke=dicke[0],collar=2,l2=l2[0],l0=l[0],flat=flat,d=d[0],d2=d2[0],deg=+45,degC=25,degEnd=degEnd[0],end=end[0],cut=cut[0],center=center,cnt=cnt)=
let(
  fn=fs2fn(r=d/2-dicke,grad=90,fs=fs),
  icollar=collar,
  collarL=tan(degC*sign(d-d2+icollar*2))*((d-d2)/2+icollar),
  step=90/fn,
  flat0=flat[0],
  flat1=collar?flat[1]:0, // for collar 
  flat2=collar?0:flat[1]/2,// no collar
  l0=l2||collar?l0:l0-collarL-flat2,
  l2=max(l2,(d2==d+collar*2?0:collarL)+flat2+flat1),
  end=max(-dicke+.25,end),//end diameter change to d/2
  lEnd=(l0+flat0+abs( tan(degEnd)*(-end+latch) ) ), // length of head section
  cut=is_undef(cut)?lEnd-l0+min(3.5,l2+l0-.5):min(cut,max(0,lEnd+l2-.5) ),
  rad=min(cut/2.5,(d/2-dicke)/PHI),
  cnt=center||min(l)==0?[0,0]:[0,cnt]//l2+lEnd]
  )
  
[
if(half&&min(l)==0)cnt+[0,0],
if(half)cnt+[0,mirror.y * -(l2+lEnd-cut)],
if(cut&&d/2-dicke>=pip/2)for(i=[0:fn])cnt+[mirror.x * (d/2-dicke-rad+rad*sin(i*step)),mirror.y * (rad*cos(i*step)-(rad+l2+lEnd-cut))],// freiraum
cnt+[mirror.x * (d/2-dicke),mirror.y * -(lEnd+l2)],// end freiraum
cnt+[mirror.x * (d/2+end),mirror.y *-(lEnd+l2)],// start chamfer
cnt+[mirror.x * (d/2+latch),mirror.y *-(l2+l0+flat0)],// end chamfer
cnt+[mirror.x * (d/2+latch),mirror.y *-(l2+l0)],// end chamfer
cnt+[mirror.x * (d/2),mirror.y *-(l2+l0+tan(-deg)*abs(latch))],// end chamfer

cnt+[mirror.x * d/2,mirror.y * -l2], // d 
if(collar)cnt+[mirror.x * (d/2+icollar),mirror.y * -l2],// collar
if(collar)cnt+[mirror.x * (d/2+icollar),mirror.y * -(l2-flat1 )],// collar
if(d2!=d||!min(l))cnt+[mirror.x * d2/2,mirror.y * -(l2-flat1- collarL )],// l2 body
if(!min(l))cnt+[mirror.x * d2/2,0]// body
];



points=
half?concat(
      l[0]?latch([1, 1],l0=l[0],flat=[flat[0],flatC[0]],dicke=dicke[0],l2=l2[0],cut=cut[0],collar=collar[0],latch=latch[0],deg=deg[0],degC=degC[0],degEnd=degEnd[0],end=end[0],d2=d2[0],d=d[0]):[],
 l[1]?revP(latch([1,-1],l0=l[1],flat=[flat[1],flatC[1]],dicke=dicke[1],l2=l2[1],cut=cut[1],collar=collar[1],latch=latch[1],deg=deg[1],degC=degC[1],degEnd=degEnd[1],end=end[1],d2=d2[1],d=d[1]) ):[]
):
concat(
      l[0]?latch([ 1, 1],l0=l[0],flat=[flat[0],flatC[0]],dicke=dicke[0],l2=l2[0],cut=cut[0],collar=collar[0],latch=latch[0],deg=deg[0],degC=degC[0],degEnd=degEnd[0],end=end[0],d2=d2[0],d=d[0]):[],
 l[1]?revP(latch([ 1,-1],l0=l[1],flat=[flat[1],flatC[1]],dicke=dicke[1],end=end[1],l2=l2[1],cut=cut[1],collar=collar[1],latch=latch[1],deg=deg[1],degC=degC[1],degEnd=degEnd[1],d2=d2[1],d=d[1]) ):[],
     l[1]? latch([-1,-1],l0=l[1],flat=[flat[1],flatC[1]],dicke=dicke[1],l2=l2[1],cut=cut[1],collar=collar[1],latch=latch[1],deg=deg[1],degC=degC[1],degEnd=degEnd[1],end=end[1],d2=d2[1],d=d[1]):[],
 l[0]?revP(latch([-1, 1],l0=l[0],flat=[flat[0],flatC[0]],dicke=dicke[0],l2=l2[0],cut=cut[0],collar=collar[0],latch=latch[0],deg=deg[0],degC=degC[0],degEnd=degEnd[0],end=end[0],d2=d2[0],d=d[0]) ):[]
);

if(use2D)offset(delta=spiel)polygon(points);
  else {
   
   h=printCut==false?max(d)*3:min(d)*sin(printCut)+spiel*2;
    Tz(print?h/2:0)R(print?-90:0)
      intersection(){
        RotEx(cut=spiel?true:false)Connector(l=l,d=d,l2=l2,d2=d2,dicke=dicke,flat=flat,flatC=flatC,latch=latch,collar=collar,deg=deg,degC=degC,degEnd=degEnd,end=end,cut=cut,center=center,spiel=spiel);
        R(90)LinEx(h,center=true)Connector(l=l,d=d,l2=l2,d2=d2,dicke=printCut==false?d/2-latch-[.5,.5]:min(d)/2*(1-cos(printCut))+.5,flat=flat,flatC=flatC,latch=latch,collar=collar,deg=deg,degC=degC,degEnd=degEnd,end=end,cut=cut,center=center,spiel=spiel);
      }
  }

}


/** \page Polygons
Tesselation creates tilings
\param size size [x,y]
\param d object diameter [x,y] for squares
\param dist spacing between objects
\param dicke line thickness
\param pat pattern 1:grid 2:hex 3:penrose
\param tile 0 none 1 circle  2 square ... 100 children
\param rad rounding tile
\param rot rotation
\param ofs position offset
\param alt alterating rotation angle
\param fn  fraqment number
\param center center
*/

//Tesselation(size=20,d=5,pat=1,fn=6,alt=30);
//Tesselation(size=20,d=4,pat=2,dist=0.6,fn=6);

//Tesselation(size=20,d=5,tile=3,pat=1,dist=.5,fn=6,alt=90);//alternating rectangles
//Tesselation(size=80,pat=4,d=5,tile=12);//pentaTile

/* //TriHex
difference(){
  Tesselation(size=30,pat=2,d=3,rot=60,dist=+0.5,tile=5,fn=6,center=1);//TriHex
  color("lime")Tesselation(size=30,pat=2,d=3,rot=60,dist=+0.5,dicke=.5,tile=5,fn=6,center=1);//TriHex
}//*/

//Tesselation(pat=2,rot=0,tile=5,dist=+0.1,dicke=2,fn=6);// TriHex

/*
HexGrid(es=10/(3/4)+.5)
Tesselation(tile=13,dist=0.5,pat=0);//floral
//*/

 /*//hex tri penta 
difference(){
square(50,true);
Tesselation(tile=11,pat=2,fn=6,dist=.4,dicke=.7,alt=[60,60]);
}//*/

//Tesselation(tile=9,dist=0.75,alt=60,dicke=.5,fn=6,pat=2);

//Tesselation(size=80,tile=0,pat=3,fn=5,d=2,dicke=1);

//Tesselation(pat=5,tile=0);

//Tesselation(pat=2,center=0);