module gear_motor(type, alpha = 1) { //! Draw specified gear motor, can be partially transparent to see what is behind it
    boss = gm_boss(type);
    shaft = gm_shaft(type);
    box = gm_box(type);
    screw = gm_screw(type);
    screw_depth = gm_screw_depth(type);
    screw_boss = gm_screw_boss(type);
    motor = gm_motor(type);
    hub = gm_hub(type);
    motor_boss = gm_motor_boss(type);
    tags = gm_tags(type);

    $fa = fa; $fs = fs;

    module shaft_pos()
        translate(gm_shaft_pos(type))
            children();

    // Shaft
    color(silver) {
        shaft_pos() {
            linear_extrude(shaft.z)
                gm_shaft_shape(type);

            cylinder(d = shaft.x, h = shaft.z - shaft[3]);
        }
    }
    // Shaft boss
    color(boss[3])
        shaft_pos()
            translate_z(-boss.z)
                if(boss.y < 0)
                    hull() {
                        cylinder(d = boss.x, h = boss.z - boss.y);

                        cylinder(r = boss.x / 2 - boss.y, h = boss.z);
                    }
                else
                    rounded_cylinder(r = boss.x / 2, r2 = boss.y, h = boss.z);

    // Gearbox
    color(box[4]) {
        render() difference() {
            translate_z(-box.z - screw_boss[1])
                union() {
                    if(box.y)
                        rounded_top_rectangle(box, box[3], box[3]);
                    else
                        rounded_cylinder(r = box.x / 2, h = box.z, r2 = box[3]);

                    if(screw_boss.x)
                        gm_screw_positions(type)
                            cylinder(d = screw_boss.x, h = box.z + screw_boss[1]);
                }

            gm_screw_positions(type)
                cylinder(r = screw_radius(screw), h = screw_depth * 2, center = true);
        }
        if(motor_boss)
            translate(motor[0] - [0, 0, box.z])
                rounded_cylinder(r = motor_boss.x / 2, h = motor_boss[1], r2 = motor_boss[2]);
    }
    // Motor
    color(motor[4], alpha)
        translate(motor[0] - [0, 0, motor.z + box.z]) {
            rounded_cylinder(r = motor[1] / 2, h = motor.z, r2 = motor[3]);

            vflip()
                rounded_cylinder(r = hub.x / 2, h = hub[1], r2 = hub[2]);

        }

    // Tags
    color(brass)
        for(side = [-1, 1])
            translate(motor[0] + [side * tags[3] / 2, 0, -box.z -motor.z])
                rotate([90, 0, 90])
                    linear_extrude(tags.x, center = true)
                        difference() {
                            hull() {
                                square([tags.y, eps], center = true);

                                translate([0, -tags.z + tags.y / 2])
                                    circle(d = tags.y);
                            }
                            r = tags.y / 4;
                            hull()
                                for(y = [-tags.z + 2 * r, - tags.z / 2])
                                    translate([0, y])
                                        circle(r);
                        }

}