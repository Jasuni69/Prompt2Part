function splitPolygonByPlane(plane, polyh, iface) = 
  let(
    eps = 1e-5,
    COPLANAR = 0,
    FRONT = 1,
    BACK = 2,
    SPANNING = 3,
    NaN = 0/0,
    allpoints = polyh[0],
    face = polyh[1][iface],
    points = [for (pi = face) allpoints[pi] ],
    n = plane[0], w = plane[1],
    l = len(points),
    polyPlane = planeFromPoints(points[0], points[1], points[2]),
    nPoly = polyPlane[0],
    types = [for (i = [0:l-1]) 
      let( t = n*points[i] - w )
      (t < -eps) ? BACK : (t > eps) ? FRONT : COPLANAR
    ],
    // search returns list of length 0 or 1 by default
    polygonType = FRONT * len(search( FRONT, types )) + 
                  BACK * len(search( BACK, types )),
    front = polygonType == SPANNING ? 
      filter_nan(flatten([for (i = [0:l-1])   
        let(
          j = (i + 1) % l,
          ti = types[i], tj = types[j],
          vi = points[i], vj = points[j]
        ) ti+tj == SPANNING ? 
          [ ti != BACK ? i : NaN, vi+(vj-vi)*((w-n*vi)/(n*(vj-vi))) ] :
          [ti != BACK ? vi : NaN]
      ])) : [],
    back = polygonType == SPANNING ? 
      filter_nan(flatten([for (i = [0:l-1])   
        let(
          j = (i + 1) % l,
          ti = types[i], tj = types[j],
          vi = points[i], vj = points[j]
        ) ti+tj == SPANNING ? 
          [ ti != FRONT ? vi : NaN, vi+(vj-vi)*((w-n*vi)/(n*(vj-vi))) ] :
          [ti != FRONT ? vi : NaN]
      ])) : [],
      lf = len(front), lb = len(back)
  )
  (polygonType == FRONT) ? 
    [points, NaN, NaN, NaN] : 
    (polygonType == BACK ? 
      [NaN, NaN, NaN, points] :
      (polygonType == COPLANAR ?
        (n*nPoly > 0 ? 
          [NaN, points, NaN, NaN] : 
          [NaN, NaN, points, NaN]
        ) : 
        // polygonType == SPANNING   
        [lf >= 3 ? front : NaN, NaN, NaN, lb >= 3 ? back : NaN]
      )
    );