function sphere_subdiv(r,d,divs=1, poly) = 
  let(
    R = d == undef ? r : d/2, // optional radius or diameter
    d = divs, // shorthand
    pv = poly[0], // points vector
    tv = poly[1], // triangle index vector
    newpoints = [for (t = tv) let(p = [pv[t[0]], pv[t[1]], pv[t[2]]])
      for (i=[0:1:d], j=[0:1:d-i]) if (i+j!=0 && i!=d && j!=d) // skip original corner points
        let(subv=[for (vi=[0:2]) let(k=d-i-j, ii=[i,j,k],
            j1=ii[(vi+1)%3], n=ii[vi]+j1,
            p0=p[vi], p1=p[(vi+1)%3], p2=p[(vi+2)%3],
            p_i=slerp(p0,p1,n/d), p_j=slerp(p0,p2,n/d)
          ) slerp(p_i,p_j,j1/n)
        ])
        unit(vsum(subv))
    ],
    Tn = function(n) n*(n+1)/2, // triangular numbers
    Td = Tn(d+1), // total points for subdivided face
    np = Td - 3, // new points per original face
    lp = len(pv),
    allpoints = concat(pv, newpoints),
    // Given original triangle point indices t, 
    // and indices i,j for subdivided basis vectors, { i => (tri[0],tri[1]), j => (tri[0],tri[2]) }
    // convert to absolute point index of resulting full point set.
    pij = function(n,t,i,j) i+j==0 ? t[0] : i==d ? t[1] : j==d ? t[2] :
      lp + n*np + Td - Tn(d+1-i) + j - (i==0 ? 1 : 2),
    faces = flatten([for (n = [0:1:len(tv)-1]) let(t = tv[n]) [
      for (i=[0:1:d-1], j=[0:1:d-1-i]) [ pij(n,t,i,j), pij(n,t,i+1,j), pij(n,t,i  ,j+1) ],
      for (i=[1:1:d-1], j=[0:1:d-1-i]) [ pij(n,t,i,j), pij(n,t,i,j+1), pij(n,t,i-1,j+1) ] 
    ] ])
  ) d > 1 ? [R*allpoints, faces] : [R*poly[0],poly[1]];




/****************************************************************************
 ** Less effective, obsolete sphere alternatives kept for reference below. **
 ****************************************************************************/