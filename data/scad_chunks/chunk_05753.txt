function _vnf_centroid(vnf,eps=EPSILON) =
    assert(is_vnf(vnf) && len(vnf[0])!=0 && len(vnf[1])!=0,"\nInvalid or empty VNF given to centroid.")
    let(
        verts = vnf[0],
        pos = sum([
            for(face=vnf[1], j=[1:1:len(face)-2]) let(
                v0  = verts[face[0]],
                v1  = verts[face[j]],
                v2  = verts[face[j+1]],
                vol = cross(v2,v1)*v0
            )
            [ vol, (v0+v1+v2)*vol ]
        ])
    )
    assert(!approx(pos[0],0, eps), "\nThe vnf has self-intersections.")
    pos[1]/pos[0]/4;

// Function: vnf_bounds()
// Synopsis: Returns the min and max bounding coordinates for the VNF.
// Topics: VNF Manipulation, Bounding Boxes, Bounds
// See Also: pointlist_bounds()
// Usage:
//   min_max = vnf_bounds(vnf, [fast]);
// Description:
//   Finds the bounds of the VNF.  By default the calculation skips any points listed in the VNF vertex list
//   that are not used by the VNF.  However, this calculation may be slow on large VNFS.  If you set `fast=true`
//   then the calculation uses all the points listed in the VNF, regardless of whether they appear in the
//   actual object.  The returned list has the form `[[MINX, MINY, MINZ], [MAXX, MAXY, MAXZ]]`.
// Arguments:
//   vnf = vnf to get the bounds of
//   fast = if true then ignore face data and process all vertices; if false, look only at vertices actually used in the geometry.  Default: false
// Example:
//   echo(vnf_bounds(cube([2,3,4],center=true)));   // Displays [[-1, -1.5, -2], [1, 1.5, 2]]