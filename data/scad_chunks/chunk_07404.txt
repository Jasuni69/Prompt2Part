module GewindeV4(
dn=6,// Diameter nominal
p=1,// Pitch per revolution
kern,//  Core diameter (⇐ dn)
breite,// thickness of crest rounding
rad1, // rounding radius 1 (⇐ p g rund breite)
rad2,//  rounding radius 2 (⇐ p g rund breite)
winkel=60,// inclusive thread angle e.g 29 for ACME or 55 for BSW can be list [10,40] for buttress
wand,// wall thickness (⇐ mantel)
dicke=1,// wall thickness (⇐ mantel)
mantel,// inner or outer shell diameter (↦ wand)
h, // height (↦ grad)
gb, // thread path height (⇐ p)
innen=false, // inner or outer thread
grad=180*7,// degres (⇐ h)
start,// Einfädelstrecke//  primed start angle
startL,// length of start
end, // angle for primed End
endL, // length of end
korrektur=true,// verbreiterung durch gangwinkel// correction of profil angle according to pitch
profil=false, // show profile polygon used
fn2=4, // profile roundingfragments
fn,//  thread fragments per revolution
fs=fs,
fa=fa,
cyl=true,// add cylinder (h,d=Kern);
tz=0, //  move thread z
konisch=0,// tapered thread angle
center=true,// center thread
rund=false, // round thread (↦ rad1 rad2)
ratio,// ratio between threads and space (↦ breite)
spiel=.1,//unused used at Gewinde innen=true// clearance only for presets inner threads
g=1,// number thread starts only for  autosizing
name,
help
){
  $p=p;
  konisch=innen?konisch:-konisch;
  halbWinkel=is_list(winkel)?winkel:[winkel/2,winkel/2];
  Kwinkel=[90-halbWinkel[0],90-halbWinkel[1]];// Komplement winkel
    //winkel=is_list(winkel)?[90-winkel[0],90-winkel[1]]:[90-winkel/2,90-winkel/2];
    
    gver=pow(g,1.5);//autocalc for g

    center=is_num(center)?center:center==true?1:0;


    kern=is_undef(kern)?
          winkel==60?innen?round((dn-p*1.08/gver)*100)/100:round((dn-p*1.225/gver*+1)*100)/100
                    :runden(innen?dn-p/g/1.6/tan(max(halbWinkel)):dn-p/g/1.42/tan(max(halbWinkel)),2)
                      :kern;
    $kern=kern;
    dn=is_undef(dn)?innen?round((kern+p*1.08/gver)*100)/100:round((kern+p*1.225/gver)*100)/100:dn;
    $dn=dn;
    fn=is_undef(fn)||fn==0?fs2fn(r=max(kern,dn)/2,fs=fs,minf=36,fa=fa):ceil(fn);
    start=ceil(is_undef(start)?is_num(startL)?fn/360*gradB(b=startL,r=innen?kern/2:dn/2):fn/3:fn/360*start);
    end=is_undef(end)?start:is_num(endL)?fn/360*gradB(b=endL,r=innen?kern/2:dn/2):ceil(fn/360*end);
    dicke=is_undef(wand)?dicke:wand;
    wand=is_undef(mantel)?innen?dicke
                               :dicke>kern/2?0:dicke
                         :max(.001,(innen?mantel-dn:kern-mantel)/2);

    d1=innen?-kern:dn;//Gewindespitzen
    d2=innen?-dn:kern;//Gewindetäler
    grad=max(//windungen
      is_undef(h)?grad-(grad%(360/fn)):(h-p)/p*360-(((h-p)/p*360)%(360/fn)-360/fn),
    360/fn*(start+end))
    ;
  
  
    winkelP=atan(p/((d1+d2)/2*PI));//Steigungswinkel
    profilkorrekturY=korrektur?1/sin(90+winkelP):1;
    gb=is_undef(gb)?p/profilkorrekturY:gb; // gangBreite axial

    //innenloch /aussenmantel
    mantel=(is_undef(mantel)?innen?d2-wand*2
                                 :wand?kern-wand*2
                                      :kern/2+0.0001
                          :innen?-max(mantel,dn+0.0001)
                                :max(mantel,0.0001)) + ( 2*p*tan(abs(konisch)) ) ;
    $mantel=mantel;
    gangH=(d1-d2)/2; // gang Höhe radial (H)
    $gangH=gangH;
    h=grad*p/360+p;
    $h=h;
    flankenBreite=[tan(halbWinkel[0])*gangH,tan(halbWinkel[1])*gangH];
    gi=grad<360/g?1:g;
    breite=runden(
           is_undef(ratio)||!ratio?is_undef(breite)?gb/gi/8:
                                                    breite:
                                   (gb/gi-flankenBreite[0]-flankenBreite[1])/2*(b(ratio,false))
    ,8); // runden


    breite2=gb/gi -breite -flankenBreite[0] -flankenBreite[1];

    rad1Max=min(breite /2/tan(Kwinkel[0]/2),breite /2/tan(Kwinkel[1]/2));
    rad2Max=min(breite2/2/tan(Kwinkel[0]/2),breite2/2/tan(Kwinkel[1]/2))-.005;
    
    Echo(str(name," Gewinde rad1 zu groß ",rad1,">",rad1Max),color="red",
      condition=is_num(rad1)&&rad1>rad1Max);
    Echo(str(name," Gewinde rad2 zu groß ",rad2,">",rad2Max),color="red",
      condition=is_num(rad2)&&rad2>rad2Max);                

    rad1=min(rad1Max,b(rund,false)==1||b(rund,false)==2?rad1Max:
              is_undef(rad1)?p/20/gi:
                             rad1);

    rad2=min(rad2Max,b(rund,false)==1||b(rund,false)==3?rad2Max:
              is_undef(rad2)?p/10/gi:
                             rad2);

    stepStart=180/max(start,1);
    stepEnd=180/max(end,1);



InfoTxt(innen?" Innengewinde ":" Außengewinde ",[
"dn",dn,//"(",innen?d2:d1,")
 "Steigung",p,
 "Kern",kern,
 "Mantel",mantel,
 "Wanddicke",wand,
 "Winkel",winkel[0]==winkel[1]?halbWinkel[0]*2:halbWinkel,
 "Gangwinkel",winkelP,
 "h",h,
str(grad/360," Windungen ("),str(grad,"°)"),
"Ganghöhe",gangH]
,name);

 /*tangYold=[rad1*sin(winkel[0])-tan(90-winkel[0])*(rad1-cos(winkel[0])*rad1), 
           rad1*sin(winkel[1])-tan(90-winkel[1])*(rad1-cos(winkel[1])*rad1)];// */
  tangY=[tan(Kwinkel[0]/2)*rad1,tan(Kwinkel[1]/2)*rad1];


Echo(str(name," Gewinde Überlappung! breite2=",negRed(breite2)),color=breite==0?"warning":"red",condition=0>=breite2);
//Echo(str(name," Gewinde Zero breite2",negRed(breite2)),color="red",condition=0==breite2);

Echo(str(name," Gewinde breite=",breite," is bigger (",(tangY[0]+tangY[1]),
  ") rad1(",rad1,"),rad1 max=",rad1Max,
  " p/16= ",p/16),condition=runden(tangY[0]+tangY[1],8)>breite);
  
//,if (breite==0&&rad1>p/16)echo(str("<b><font color=red>",name," Gewinde breite=0 rad1>p/16= ",p/16));

HelpTxt("Gewinde",
["p",p
,"dn",dn
,"kern",kern
,"breite",breite
,"rad1",rad1
,"rad2",rad2
,"winkel",halbWinkel[0]==halbWinkel[1]?halbWinkel[0]*2:halbWinkel
,"dicke",dicke
,"mantel",abs(mantel)
,"h",h
,"gb",gb // gang breite gesamt
,"innen",innen
,"grad",grad
,"start",start // Einfädelstrecke in grad
,"startL",startL // length start
,"end",end
,"korrektur",korrektur// verbreiterung durch gangwinkel
,"profil",profil // 2D Ansicht
,"fn2",fn2
,"fn",fn
,"fs",fs
,"fa",fa
,"cyl",cyl
,"tz",tz
,"konisch",konisch
,"center",center
,"rund",rund
,"ratio",ratio
,"spiel",spiel
,"g",g
,"name",name   
],help);

pointsStart=[
    for(i=[0:max(start +1,5)])vollwelle(fn=fn2,l=gb,h=start?gangH*(0.5+sin(i*stepStart-90)/2):gangH,r=rad1,r2=rad2,tMitte=breite,
      grad=start?[max(Kwinkel[0]*sin(i*.5*stepStart+0),1),max(Kwinkel[1]*sin(i*.5*stepStart+0),1)]:
                 Kwinkel,
      grad2=[-konisch,konisch],extrude=d2/2,x0=mantel/2,xCenter=-1,minF=fn2)   
    ];
pointsEnd=[
    for(i=[0:max(end +1,5)])vollwelle(fn=fn2,l=gb,h=end?gangH*(0.5+sin(i*stepEnd-90)/2):gangH,r=rad1,r2=rad2,tMitte=breite,
      grad=end?[max(Kwinkel[0]*sin(i*.5*stepEnd+0),1),max(Kwinkel[1]*sin(i*.5*stepEnd+0),1)]:
                 Kwinkel,
      grad2=[-konisch,konisch],extrude=d2/2,x0=mantel/2,xCenter=-1,minF=fn2)   
    ];    
    
points=concat(pointsStart,pointsEnd);
    
 
profilnr=max(start+1,5);
pointskorr=[for(i=[0:len(points[profilnr])-1])[points[profilnr][i][0],points[profilnr][i][1]*profilkorrekturY]];

detail=round(fn*grad/360);