module OctaH(r=1,n=0,d,help){
  
HelpTxt("OctaH",["r",r,"n",n,"d",d],help);
  
  scaling=is_list(r)||is_list(d)?true:false; // if subdiv needs sep scaling
  r=is_list(r)?[for(i=[0:5]) i%2? -abs(r[i%len(r)]):   // neg quadrant
                                   abs(r[i%len(r)])]:  //pos quadrants
              is_undef(d)?[r, -r, r, -r, r, -r]:
                          is_list(d)?[for(i=[0:2]) each[d[i%len(d)] , -d[i%len(d)] ]] /2:
                                //       d.y /2, -d.y /2,
                                //       d.z /2, -d.z /2]:
                                     [d /2, -d /2, d /2, -d /2, d /2, -d /2];
  
  faces=[
  [0,2,4],
  [2,1,4],
  [1,3,4],
  [3,0,4],
  [2,0,5],
  [1,2,5],
  [3,1,5],
  [0,3,5],
  
  ];
  if(n==0)polyhedron(octa(r),faces);
  
  else OctaSphere(r,n,d);
  module OctaSphere(r=10,n=10,d){   
    // based on Hans Loeblich alternative spheres
    // https://github.com/thehans/FunctionalOpenSCAD
    // MIT license
    

  data=sphere_subdiv(divs=max(1,floor(n/4)), poly=OCTAHEDRON(1));
  polyhedron(data[0],data[1]);


  // sum a vector of vectors.  vsum([]) == undef
  function vsum(v,i=0) = len(v)-1 > i ? v[i] + vsum(v, i+1) : v[i];
  // angle between two vectors (use2D or 3D)
  function anglev(v1,v2) = acos( (v1*v2) / (norm(v1)*norm(v2) ) );
  function flatten(l) = [ for (a = l) for (b = a) b ];
  //function unit(v) = v / norm(v); // convert vector to unit vector
  // spherical linear interpolation
  function slerp(p0,p1,t) = let(a = anglev(p0,p1)) (sin((1-t)*a)*p0 + sin(t*a)*p1) / sin(a);

  function OCTAHEDRON(r) = [octa(r),faces];
  
  
//  [ [[0,0,r[5]],[r[0],0,0],[0,r[2],0],[r[1],0,0],[0,r[3],0],[0,0,r[4]]],
//    [ [0,3,4],[0,1,2],[0,2,3],[0,4,1],
//      [5,2,1],[5,3,2],[5,4,3],[5,1,4] ] ];


  // subdivide faces, splitting edges into integer number of divisions
  // input faces must be triangles with vertices on the unit sphere
  function sphere_subdiv(divs=1, poly) = 
    let(
      R = r[0],//d == undef ? r : d/2, // optional radius or diameter
      d = divs, // shorthand
      pv = poly[0], // points vector
      tv = poly[1], // triangle index vector
      newpoints = [for (t = tv) let(p = [pv[t[0]], pv[t[1]], pv[t[2]]])
        for (i=[0:1:d], j=[0:1:d-i]) if (i+j!=0 && i!=d && j!=d) // skip original corner points
          let(subv=[for (vi=[0:2]) let(k=d-i-j, ii=[i,j,k],
              j1=ii[(vi+1)%3], n=ii[vi]+j1,
              p0=p[vi], p1=p[(vi+1)%3], p2=p[(vi+2)%3],
              p_i=slerp(p0,p1,n/d), p_j=slerp(p0,p2,n/d)
            ) slerp(p_i,p_j,j1/n)
          ])
          vsum(subv)
      ],
      Tn = function(n) n*(n+1)/2, // triangular numbers
      Td = Tn(d+1), // total points for subdivided face
      np = Td - 3, // new points per original face
      lp = len(pv),
      allpoints = concat(pv, newpoints/3),
      // Given original triangle point indices t, 
      // and indices i,j for subdivided basis vectors, { i => (tri[0],tri[1]), j => (tri[0],tri[2]) }
      // convert to absolute point index of resulting full point set.
      pij = function(n,t,i,j) i+j==0 ? t[0] : i==d ? t[1] : j==d ? t[2] :
        lp + n*np + Td - Tn(d+1-i) + j - (i==0 ? 1 : 2),
      faces = flatten([for (n = [0:1:len(tv)-1]) let(t = tv[n]) [
        for (i=[0:1:d-1], j=[0:1:d-1-i]) [ pij(n,t,i,j), pij(n,t,i+1,j), pij(n,t,i  ,j+1) ],
        for (i=[1:1:d-1], j=[0:1:d-1-i]) [ pij(n,t,i,j), pij(n,t,i,j+1), pij(n,t,i-1,j+1) ] 
      ] ])
    )[scaling?[for(i=[0:len(allpoints)-1])[
      allpoints[i].x>0?allpoints[i].x*r[0]:allpoints[i].x*-r[1],
      allpoints[i].y>0?allpoints[i].y*r[2]:allpoints[i].y*-r[3],
      allpoints[i].z>0?allpoints[i].z*r[4]:allpoints[i].z*-r[5],
    ]]
      :R*allpoints
        , faces];
   }
}




/** \page Objects
Prisma() rounded cube (square prism)
 \name Prisma
 * \brief creates a prism with optional round edges
 \param x1 size x bottom (can be list)
 \param y1 size y bottom
 \param z size z
 \param c1 vertical corner diameter can be bigger then s
 \param s  edge diameter
 \param rad edge radius (only for simple)
 \param x2,y2 optional size top
 \param x2d,y2d delta to shift top
 \param c2 for tapered vertical corner
 \param fnC fragments vertical corner
 \param fnS fragments corner
 \param fs fragment size
 \param center center [x,y,z]
 \param r corner radius (simple only)
 \param deg edge contact angle [bottom,top]
 \param optimize uses Pill (like in simple), allows deg and rad but slower than hull(simple)
*/

//Prisma(r=[1,2,3,4]);