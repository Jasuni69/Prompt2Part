function bezpath_close_to_axis(bezpath, axis="X", N=3) =
    assert(is_path(bezpath,2), "\nbezpath_close_to_axis() works only on 2D bezier paths.")
    assert(is_int(N))
    assert(len(bezpath)%N == 1, str("\nA degree ",N," bezier path should have a multiple of ",N," points in it, plus 1."))
    let(
        sp = bezpath[0],
        ep = last(bezpath)
    ) (axis=="X")? concat(
        lerpn([sp.x,0], sp, N, false),
        list_head(bezpath),
        lerpn(ep, [ep.x,0], N, false),
        lerpn([ep.x,0], [sp.x,0], N+1)
    ) : (axis=="Y")? concat(
        lerpn([0,sp.y], sp, N, false),
        list_head(bezpath),
        lerpn(ep, [0,ep.y], N, false),
        lerpn([0,ep.y], [0,sp.y], N+1)
    ) : (
        assert(in_list(axis, ["X","Y"]))
    );


// Function: bezpath_offset()
// Synopsis: Forms a closed bezier path loop with a translated and reversed copy of itself.
// SynTags: Path
// Topics: Bezier Paths
// See Also: bezpath_close_to_axis()
// Usage:
//   bezpath = bezpath_offset(offset, bezier, [N]);
// Description:
//   Takes a 2D bezier path and closes it with a matching reversed path that is offset by the given `offset` [X,Y] distance.
// Arguments:
//   offset = Amount to offset second path by.
//   bezier = The 2D bezier path.
//   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3
// Example(2D):
//   bez = [[50,30], [40,10], [10,50], [0,30], [-10, 10], [-30,10], [-50,20]];
//   closed = bezpath_offset([0,-5], bez);
//   debug_bezier(closed);
// Example(2D):
//   bez = [[30,50], [10,40], [50,10], [30,0], [10, -10], [10,-30], [20,-50]];
//   closed = bezpath_offset([-5,0], bez);
//   debug_bezier(closed);