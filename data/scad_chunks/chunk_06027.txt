module grid_copies(spacing, n, size, stagger=false, inside=undef, nonzero)
{
    req_children($children);    
    dummy = assert(in_list(stagger, [false, true, "alt"]));
    bounds = is_undef(inside)? undef :
        is_path(inside)? pointlist_bounds(inside) :
        assert(is_region(inside))
        pointlist_bounds(flatten(inside));
    nonzero = is_path(inside) ? default(nonzero,false)
            : assert(is_undef(nonzero), "nonzero only allowed if inside is a polygon")
              false;
    size = is_num(size)? [size, size] :
        is_vector(size)? assert(len(size)==2) size :
        bounds!=undef? [
            for (i=[0:1]) 2*max(abs(bounds[0][i]),bounds[1][i])
        ] : undef;
    spacing = is_num(spacing)? (
            stagger!=false? polar_to_xy(spacing,60) :
            [spacing,spacing]
        ) :
        is_vector(spacing)? assert(len(spacing)==2) spacing :
        size!=undef? (
            is_num(n)? v_div(size,(n-1)*[1,1]) :
            is_vector(n)? assert(len(n)==2) v_div(size,n-[1,1]) :
            v_div(size,(stagger==false? [1,1] : [2,2]))
        ) :
        undef;
    n = is_num(n)? [n,n] :
        is_vector(n)? assert(len(n)==2) n :
        size!=undef && spacing!=undef? v_floor(v_div(size,spacing))+[1,1] :
        [2,2];
    dummy2 = assert(is_int(n[0]) && is_int(n[1]), "The number of rows/columns must be an integer");
    offset = v_mul(spacing, n-[1,1])/2;

    poslist = 
      stagger==false ? 
               [for (row = [0:1:n.y-1], col = [0:1:n.x-1])
                   let(
                       pos = v_mul([col,row],spacing) - offset
                   )
                   if (
                           is_undef(inside) ||
                           (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||
                           (is_region(inside) && point_in_region(pos, inside)>=0)
                   )
                   [pos,row,col]
               ]
      :
        let(  // stagger == true or stagger == "alt"
            staggermod = (stagger == "alt")? 1 : 0,
            cols1 = ceil(n.x/2),
            cols2 = n.x - cols1
         )
         [for (row = [0:1:n.y-1])
              let(
                rowcols = ((row%2) == staggermod)? cols1 : cols2
              )
              if (rowcols > 0) 
                for (col = [0:1:rowcols-1])
                  let(
                    rowdx = (row%2 != staggermod)? spacing.x : 0,
                    pos = v_mul([2*col,row],spacing) + [rowdx,0] - offset
                  )
                    if (
                        is_undef(inside) ||
                        (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||
                        (is_region(inside) && point_in_region(pos, inside)>=0)
                    )
                    [pos, row, col * 2 + ((row%2!=staggermod)? 1 : 0)]
        ];
    for(i=idx(poslist)){
      $idx=i;
      $pos=poslist[i][0];
      $row=poslist[i][1];
      $col=poslist[i][2];
      translate(poslist[i][0])children();
    }
}