function _textured_point_array(points, texture, tex_reps, tex_size, tex_samples, tex_inset=false, tex_rot=0, triangulate=false, tex_scaling="default",return_edges=false, 
                col_wrap=false, tex_depth=1, row_wrap=false, caps, cap1, cap2, reverse=false, style="min_edge", tex_extra, tex_skip, sidecaps,sidecap1,sidecap2,normals) =
    assert(tex_reps==undef || is_int(tex_reps) || (all_integer(tex_reps) && len(tex_reps)==2), "tex_reps must be an integer or list of two integers")
    assert(tex_size==undef || is_num(tex_size) || is_vector(tex_size,2), "tex_size must be a scalar or 2-vector")
    assert(num_defined([tex_size, tex_reps])==1, "Must give exactly one of tex_size and tex_reps")
    assert(in_list(style,["default","alt","quincunx", "convex","concave", "min_edge","min_area","flip1","flip2"]))
    assert(is_matrix(points[0], n=3),"Point array has the wrong shape or points are not 3d")
    assert(is_consistent(points), "Non-rectangular or invalid point array")
    let(
        cap1 = first_defined([cap1,caps,false]),
        cap2 = first_defined([cap2,caps,false]),
        sidecap1 = first_defined([sidecap1,sidecaps,false]),
        sidecap2 = first_defined([sidecap2,sidecaps,false]),
        tex_inset = is_num(tex_inset)? tex_inset : tex_inset? 1 : 0,
        texture = _get_texture(texture, tex_rot),
        dummy = assert(is_undef(tex_samples) || is_vnf(texture),
                       "You gave the tex_samples argument with a heightfield texture, which is not permitted.  Use the n= argument to texture() instead"),
        ptsize=[len(points[0]), len(points)],
        tex_reps = is_def(tex_reps) ? force_list(tex_reps,2)
                 : let(
                       tex_size = force_list(tex_size,2),
                       xsize = norm(points[0][0]-points[0][1])*(ptsize.x+(col_wrap?1:0)),
                       ysize = norm(points[0][0]-points[1][0])*(ptsize.y+(row_wrap?1:0))
                   )
                   [max(1,round(xsize/tex_size.x)), max(1,round(ysize/tex_size.y))],
        normals = default(normals,surface_normals(points, col_wrap=col_wrap, row_wrap=row_wrap)),
        getscale = tex_scaling=="default" ? function(x,y) (x+y)/2
                 : tex_scaling=="const" ? function(x,y) 1
                 : assert(false, "Unknown tex_scaling value.  Must be either \"default\" or \"const\"")
    )
    !is_vnf(texture) ?  // heightmap case
        let(
            extra = is_def(tex_extra) ? force_list(tex_extra,2)
                  : [col_wrap?0:1, row_wrap?0:1],
            skip = is_def(tex_skip) ? force_list(tex_skip,2) : [0,0],
            texsize = [len(texture[0]), len(texture)],
            fullsize = [texsize.x*tex_reps.x+extra.x-skip.x, texsize.y*tex_reps.y+extra.y-skip.y],
            res_points = _resample_point_array(points,fullsize, col_wrap=col_wrap, row_wrap=row_wrap),
            res_normals= _resample_point_array(normals,fullsize, col_wrap=col_wrap, row_wrap=row_wrap),
            local_scale = [for(y=[0:1:fullsize.y-1])
                             [for(x=[0:1:fullsize.x-1])
                                let(
                                     xlen = [
                                              if(x>0 || col_wrap) norm(res_points[y][x] - select(res_points[y], x-1)),
                                              if(x<fullsize.x-1 || col_wrap) norm(res_points[y][x] - select(res_points[y], x+1))
                                            ],
                                     ylen = [
                                              if(y>0 || row_wrap) norm(res_points[y][x] - select(res_points,y-1)[x]),
                                              if(y<fullsize.y-1 || row_wrap) norm(res_points[y][x] - select(res_points,y+1)[x])
                                            ]
                                 )
                                 getscale(mean(xlen),mean(ylen))
                              ]
                           ],
            tex_surf =
              [for(y=[0:1:fullsize.y-1])
                 [for(x=[0:1:fullsize.x-1])
                    let(yind = (y+skip.y)%texsize.y,
                        xind = (x+skip.x)%texsize.x
                    )
                    res_points[y][x] + _tex_height(tex_depth,tex_inset,texture[yind][xind]) * res_normals[y][x]*(reverse?-1:1)*local_scale[y][x]/local_scale[0][0]
                  ]
              ]
        )  
        vnf_vertex_array(tex_surf, row_wrap=row_wrap, col_wrap=col_wrap, reverse=reverse,style=style,
                         caps=caps, cap1=cap1, cap2=cap2, triangulate=triangulate, return_edges=return_edges)
   : // VNF case
        let(
            local_scale = [for(y=[-1:1:ptsize.y])
                             [for(x=[-1:1:ptsize.x])
                               ((!col_wrap && (x<0 || x>=ptsize.x-1))
                                   || (!row_wrap && (y<0 || y>=ptsize.y-1))) ? undef
                              : let(
                                     dx = [norm(select(select(points,y),x) - select(select(points,y),x+1)),
                                          norm(select(select(points,y+1),x) - select(select(points,y+1),x+1))],
                                     dy = [norm(select(select(points,y),x) - select(select(points,y+1),x)),
                                          norm(select(select(points,y),x+1) - select(select(points,y+1),x+1))]
                                )
                                getscale(mean(dx),mean(dy))]],
            samples = default(tex_samples,8),
            vnf = samples==1? texture
                :
                  let(
                      s = 1 / samples,
                      slice_us = list([s:s:1-s/2]),
                      vnf_x = vnf_slice(texture, "X", slice_us),
                      vnf_xy = vnf_slice(vnf_x, "Y", slice_us),
                      vnf_q = vnf_quantize(vnf_xy,1e-4)
                  )
                  vnf_triangulate(vnf_q),
            yedge_paths = !row_wrap ? _tile_edge_path_list(vnf,1) : undef,
            xedge_paths = !col_wrap ? _tile_edge_path_list(vnf,0) : undef,
            trans_pt = function(x,y,pt)
               let(
                   tileindx = x+pt.x,
                   tileindy = y+(1-pt.y),

                   refx = tileindx/tex_reps.x*(ptsize.x-(col_wrap?0:1)),
                   refy = tileindy/tex_reps.y*(ptsize.y-(row_wrap?0:1)),
                   xind = floor(refx),
                   yind = floor(refy),
                   xfrac = refx-xind,
                   yfrac = refy-yind, 
                   corners = [points[yind%ptsize.y][xind%ptsize.x],     points[(yind+1)%ptsize.y][xind%ptsize.x],
                              points[yind%ptsize.y][(xind+1)%ptsize.x], points[(yind+1)%ptsize.y][(xind+1)%ptsize.x]],
                   base = bilerp(corners,yfrac, xfrac),
                   scale_list = xfrac==0 && yfrac==0 ? [local_scale[yind][xind], local_scale[yind][xind+1], local_scale[yind+1][xind], local_scale[yind+1][xind+1]]
                              : xfrac==0 ? [local_scale[yind+1][xind], local_scale[yind+1][xind+1]]
                              : yfrac==0 ? [local_scale[yind][xind+1], local_scale[yind+1][xind+1]]
                              :            [ local_scale[yind+1][xind+1]],
                   scale = mean([for(s=scale_list) if (is_def(s)) s])/local_scale[1][1],
                   normal = bilerp([normals[yind%ptsize.y][xind%ptsize.x],     normals[(yind+1)%ptsize.y][xind%ptsize.x],
                                    normals[yind%ptsize.y][(xind+1)%ptsize.x], normals[(yind+1)%ptsize.y][(xind+1)%ptsize.x]],
                                    yfrac, xfrac)
               )
               base + _tex_height(tex_depth,tex_inset,pt.z) * normal*(reverse?-1:1) * scale,
            fullvnf = vnf_join([
                           for(y=[0:1:tex_reps.y-1], x=[0:1:tex_reps.x-1])   // Main body of the textured shape
                             [
                              [for(pt=vnf[0]) trans_pt(x,y,pt)],
                              vnf[1]
                             ],
                           for(y=[if (cap1) 0, if (cap2) tex_reps.y-1])
                             let(
                                 cap_paths = [
                                              if (col_wrap && len(yedge_paths[0])>0)
                                                 [for(x=[0:1:tex_reps.x-1], pt=yedge_paths[0][0])
                                                     trans_pt(x,y,[pt.x,y?0:1,pt.z])],
                                              if (!row_wrap)      
                                                for(closed_path=yedge_paths[1], x=[0:1:tex_reps.x-1])
                                                   [for(pt = closed_path) trans_pt(x,y,[pt.x,y?0:1,pt.z])]
                                             ]
                             )
                             for(path=cap_paths) [path, [count(path,reverse=y==0)]],
                           if (!col_wrap)
                             for(x=[if (sidecap1) 0, if (sidecap2) tex_reps.x-1])
                                let( 
                                   cap_paths = [for(closed_path=xedge_paths[1], y=[0:1:tex_reps.y-1])
                                                   [for(pt = closed_path) trans_pt(x,y,[x?1:0,pt.y,pt.z])]]
                                )
                                for(path=cap_paths) [path, [count(path,reverse=x!=0)]]
                      ]),
            edgepaths = !return_edges ? undef
                      : [
                          if (!col_wrap)
                             for(x=[0, tex_reps.x-1])
                                   [for(y=[0:1:tex_reps.y-1],pt=xedge_paths[0][0])
                                                   trans_pt(x,y,[x?1:0,pt.y,pt.z])]
                          else each [[],[]],
                                 
                          if (!row_wrap && len(yedge_paths[0])>0)
                             for(ind=[0,1])
                               if ([cap1,cap2][ind]) []
                               else let(y=[0,tex_reps.y-1][ind])
                               [for(x=[0:1:tex_reps.x-1], pt=yedge_paths[0][0])
                                                     trans_pt(x,y,[pt.x,y?0:1,pt.z])]
                          else each [[],[]]
                        ],
            revvnf = reverse ? vnf_reverse_faces(fullvnf) : fullvnf
                          
       )
       !return_edges ? revvnf : [revvnf, edgepaths];


// Resamples a point array to the specified size.
// In use above, data is a list of points in R^3 on a grid 
// and size is the desired dimensions of the output array covering the
// same data.