module cyl(
	l=undef, h=undef,
	r=undef, r1=undef, r2=undef,
	d=undef, d1=undef, d2=undef,
	chamfer=undef, chamfer1=undef, chamfer2=undef,
	chamfang=undef, chamfang1=undef, chamfang2=undef,
	fillet=undef, fillet1=undef, fillet2=undef,
	circum=false, realign=false, from_end=false,
	orient=ORIENT_Z, align=V_CENTER, center=undef
) {
	r1 = get_radius(r1, r, d1, d, 1);
	r2 = get_radius(r2, r, d2, d, 1);
	l = first_defined([l, h, 1]);
	sides = segs(max(r1,r2));
	sc = circum? 1/cos(180/sides) : 1;
	orient_and_align([r1*2,r1*2,l], orient, align, center=center) {
		zrot(realign? 180/sides : 0) {
			if (!any_defined([chamfer, chamfer1, chamfer2, fillet, fillet1, fillet2])) {
				cylinder(h=l, r1=r1*sc, r2=r2*sc, center=true, $fn=sides);
			} else {
				vang = atan2(l, r1-r2)/2;
				chang1 = 90-first_defined([chamfang1, chamfang, vang]);
				chang2 = 90-first_defined([chamfang2, chamfang, 90-vang]);
				cham1 = (chamfer != undef || chamfer1 != undef)?first_defined([chamfer1, chamfer]) * (from_end? 1 : tan(chang1)):undef;
				cham2 = (chamfer != undef || chamfer2 != undef)?first_defined([chamfer2, chamfer]) * (from_end? 1 : tan(chang2)):undef;
				fil1 = first_defined([fillet1, fillet]);
				fil2 = first_defined([fillet2, fillet]);
				if (chamfer != undef) {
					assertion(chamfer <= r1,  "chamfer is larger than the r1 radius of the cylinder.");
					assertion(chamfer <= r2,  "chamfer is larger than the r2 radius of the cylinder.");
					assertion(chamfer <= l/2, "chamfer is larger than half the length of the cylinder.");
				}
				if (cham1 != undef) {
					assertion(cham1 <= r1,  "chamfer1 is larger than the r1 radius of the cylinder.");
					assertion(cham1 <= l/2, "chamfer1 is larger than half the length of the cylinder.");
				}
				if (cham2 != undef) {
					assertion(cham2 <= r2,  "chamfer2 is larger than the r2 radius of the cylinder.");
					assertion(cham2 <= l/2, "chamfer2 is larger than half the length of the cylinder.");
				}
				if (fillet != undef) {
					assertion(fillet <= r1,  "fillet is larger than the r1 radius of the cylinder.");
					assertion(fillet <= r2,  "fillet is larger than the r2 radius of the cylinder.");
					assertion(fillet <= l/2, "fillet is larger than half the length of the cylinder.");
				}
				if (fil1 != undef) {
					assertion(fil1 <= r1,  "fillet1 is larger than the r1 radius of the cylinder.");
					assertion(fil1 <= l/2, "fillet1 is larger than half the length of the cylinder.");
				}
				if (fil2 != undef) {
					assertion(fil2 <= r2,  "fillet2 is larger than the r1 radius of the cylinder.");
					assertion(fil2 <= l/2, "fillet2 is larger than half the length of the cylinder.");
				}

				dy1 = first_defined([cham1, fil1, 0]);
				dy2 = first_defined([cham2, fil2, 0]);
				maxd = max(r1,r2,l);

				rotate_extrude(convexity=2) {
					hull() {
						difference() {
							union() {
								difference() {
									back(l/2) {
										if (cham2!=undef && cham2>0) {
											rr2 = sc * (r2 + (r1-r2)*dy2/l);
											chlen2 = min(rr2, cham2/sin(chang2));
											translate([rr2,-cham2]) {
												rotate(-chang2) {
													translate([-chlen2,-chlen2]) {
														square(chlen2, center=false);
													}
												}
											}
										} else if (fil2!=undef && fil2>0) {
											translate([r2-fil2*tan(vang),-fil2]) {
												circle(r=fil2);
											}
										} else {
											translate([r2-0.005,-0.005]) {
												square(0.01, center=true);
											}
										}
									}

									// Make sure the corner fiddly bits never cross the X axis.
									fwd(maxd) square(maxd, center=false);
								}
								difference() {
									fwd(l/2) {
										if (cham1!=undef && cham1>0) {
											rr1 = sc * (r1 + (r2-r1)*dy1/l);
											chlen1 = min(rr1, cham1/sin(chang1));
											translate([rr1,cham1]) {
												rotate(chang1) {
													left(chlen1) {
														square(chlen1, center=false);
													}
												}
											}
										} else if (fil1!=undef && fil1>0) {
											right(r1) {
												translate([-fil1/tan(vang),fil1]) {
													fsegs1 = quantup(segs(fil1),4);
													circle(r=fil1,$fn=fsegs1);
												}
											}
										} else {
											right(r1-0.01) {
												square(0.01, center=false);
											}
										}
									}

									// Make sure the corner fiddly bits never cross the X axis.
									square(maxd, center=false);
								}

								// Force the hull to extend to the axis
								right(0.01/2) square([0.01, l], center=true);
							}

							// Clear anything left of the Y axis.
							left(maxd/2) square(maxd, center=true);

							// Clear anything right of face
							right((r1+r2)/2) {
								rotate(90-vang*2) {
									fwd(maxd/2) square(maxd, center=false);
								}
							}
						}
					}
				}
			}
		}
	}
}



// Module: downcyl()
//
// Description:
//   Creates a cylinder aligned below the origin.
//
// Usage:
//   downcyl(l|h, r|d);
//   downcyl(l|h, r1|d1, r2|d2);
//
// Arguments:
//   l / h = Length of cylinder. (Default: 1.0)
//   r = Radius of cylinder.
//   r1 = Bottom radius of cylinder.
//   r2 = Top radius of cylinder.
//   d = Diameter of cylinder. (use instead of r)
//   d1 = Bottom diameter of cylinder.
//   d2 = Top diameter of cylinder.
//
// Example: Cylinder
//   downcyl(r=20, h=40);
// Example: Cone
//   downcyl(r1=10, r2=20, h=40);