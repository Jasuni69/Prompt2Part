module Rundrum(x=+40,y,r=10,eck=4,twist=0,grad=90,grad2=90,lap=0.005,fn=fn,fs=fs,fa=fa,size,rad,name,help){
    
$info=name;
$idxON=false;

$fa=fa;
$fs=fs;
$fn=fn;

rI=is_undef(rad)?r:rad;
size=is_list(size)?size:[size,size];

  // WIP
  Echo("Angle with different radii not implemeted yet",condition=(r1!=r2||r2!=r3||r3!=r4)&&(grad2!=90||grad!=90));
  
    r1=is_list(rI)?rI[0]:rI;
    r2=is_list(rI)?rI[1]:rI;
    r3=is_list(rI)?rI[2]:rI;
    r4=is_list(rI)?rI[3]:rI;

    r=is_list(rI)?rI[0]:rI;
    y=is_undef(size.y)?is_list(x)?x[1]:is_undef(y)?x:y
                      :size.y;
    x=is_undef(size.x)?is_list(x)?x[0]:x
                      :size.x;
        
    //grad2=grad-20;// WIP
    shift=tan(grad-90)*y;
    grad=grad?grad:shift>0?atan(shift/y):-atan(-shift/y);
    shiftx=shift-r*2*tan(grad-90);
    shiftx2=tan(grad2-90)*y-r*2*tan(grad2-90);
    shiftYLang=Hypotenuse(shiftx,y-2*r);
    shiftYLang2=Hypotenuse(shiftx2,y-2*r);
    if(eck==4&&grad!=90&&name)echo(str(name," Rundrum grad=",grad,"° ShiftX=",shiftx,"mm (+-",shiftx/2,"mm) Lot(x)=",x*sin(grad),"mm"));
    //rx=r?r*(r/(sin(grad)*r)):0;
    function rx(r=r,grad=grad)=r*1/sin(grad);
    

if(eck==4&&twist==0)
    if(grad==90&&grad2==90){
        $info=is_undef(name)?$info:name;
        $tab=is_undef($tab)?1:b($tab,false)+1;
        //Ecken
        T(-x/2+r1,y/2-r1)rotate(90)RotEx(90,fn=fn/4,cut=true)T(r1)children();// R1
        union(){
        $info=false;
        $helpM=false;
        $idx=true; // disable help
        T(x/2-r2,y/2-r2)RotEx(90,fn=fn/4,cut=true)T(r2)children();// R2
        T(-x/2+r3,-y/2+r3)rotate(180)RotEx(90,fn=fn/4,cut=true)T(r3)children();// R3
        T(x/2-r4,-y/2+r4)rotate(-90)RotEx(90,fn=fn/4,cut=true)T(r4)children();// R4
        //Graden
        //X
        T((r1-r2)/2,y/2)R(90,0,90)linear_extrude(x-r1-r2+lap,center=true,convexity=5)children();
        T((r3-r4)/2,-y/2)R(90,0,-90)linear_extrude(x-r3-r4+lap,center=true,convexity=5)children();
        //Y
        T(-x/2,(r3-r1)/2)R(90,0,180)linear_extrude(y-r1-r3+lap,center=true,convexity=5)children();
        T(x/2,(r4-r2)/2)R(90,0,+0)linear_extrude(y-r2-r4+lap,center=true,convexity=5)children();        
        }
        
    }
else T(-shiftx/2*0){
      $info=is_undef(name)?$info:name;
      $tab=is_undef($tab)?1:b($tab,false)+1;
    //plus x    
    T(x/2-rx(r2,grad2)+shiftx2/2,y/2-r2)rotate(90-grad2)rotate_extrude(angle=grad2,convexity=5,$fn=0,$fa = grad2/(fn/4), $fs = 0.1)Ecke(r2)children();
    union(){
      $idx=true; // disable help
      $helpM=0;
      $info=0;
    T(x/2-rx(r4,grad2)-shiftx2/2,-y/2+r4)rotate(-90)rotate_extrude(angle=180-grad2,convexity=5,$fn=0,$fa = (180-grad2)/(fn/4), $fs = 0.1)Ecke(r4)children(); 
    //minus x   
    T(-x/2+rx(r1)+shiftx/2,y/2-r1)rotate(90)rotate_extrude(angle=180-grad,convexity=5,$fn=0,$fa = (180-grad)/(fn/4), $fs = 0.1)Ecke(r1)children();
    T(-x/2+rx(r3)-shiftx/2,-y/2+r3)rotate(-90)rotate_extrude(angle=-grad,convexity=5,$fn=0,$fa = grad/(fn/4), $fs = 0.1)Ecke(r3)children();  


    //linear x -+   
    T(+x/2-rx((r2+r4)/2,grad2)+shiftx2/2,y/2-r)rotate(90-grad2)T(+r)R(90,0,0)Tz(-lap/2)linear_extrude(shiftYLang2+lap,convexity=5,center=false,$fn=fn)children();
    T(-x/2+rx(r1/2+r3/2)-shiftx/2,-y/2+r)rotate(90-grad)T(-r)R(90,0,180)Tz(-lap/2)linear_extrude(shiftYLang+lap,convexity=5,center=false,$fn=fn)children();
 
    //linear y -+    
    T(-x/2+rx()+shiftx/2-lap/2,y/2+0)R(90,0,90)linear_extrude(x-rx(r1)-rx(r2,grad=grad2)+lap+shiftx2/2-shiftx/2,convexity=5,center=false,$fn=fn)children();
    T(+x/2-rx(grad=grad2)+lap/2-shiftx2/2,-y/2)R(90,0,-90)linear_extrude(x-rx()-rx(grad=grad2)+lap-shiftx2/2+shiftx/2,convexity=5,center=false,$fn=fn)children(); 
    }   
    if(2*r>x||2*r>y){
        echo();
            Echo(str("››»!!!«‹‹ ",name," Rundrum WARNUNG !!! Radius zu groß !!!"),color="red");
        echo();
        
    }

    if(name) if((2*r==x||2*r==y)&&x!=y)echo(str(name," Rundrum Halbkreis"));
    if(name)  if(2*r==x&&2*r==y)echo(str(name," Rundrum Vollkreis"));
       
    }
  else{
    for(i=[0:eck-1]){
        r=is_list(rI)?rI[i%len(rI)]:r;
        rNext=is_list(rI)?rI[(i+1)%len(rI)]:r;
        l=[Kathete(Umkreis(eck,x-rNext),x-rNext),Kathete(Umkreis(eck,x-r),x-r)];
        
        $tab=is_undef($tab)?1:b($tab,false)+1;
        $info=is_undef(name)?$info:name;
        $idx=i*2;
        stepDeg=360/eck;
        rotate(i*stepDeg)T(Umkreis(eck,x-r))rotate(-180/eck)rotate_extrude(angle=stepDeg,$fn=fn,convexity=5)intersection(){
            T(r)rotate(i*(twist/eck))children();
            translate([0,-150])square(300);
        }
        union(){
            $helpM=0;
            $info=0;
            $idx=i*2+1;
            //rotate(i*stepDeg+180/eck)T(x) R(-90)linear_extrude(l[0]+lap,center=false,twist=twist/eck,$fn=fn,convexity=5)rotate(+twist/eck+i*(twist/eck))children();
            rotate(i*stepDeg+180/eck)T(x,l[0]+lap) R(90)linear_extrude(vSum(l)+lap*2,center=false,twist=twist/eck,$fn=fn,convexity=5)rotate(+twist/eck+i*(twist/eck))children();
        }
    }
    
  }
MO(!$children);

    module Ecke(r=r){
        render()intersection(){
            T(r)children();
            translate([0,-150])square(300);
        }
    }
  
HelpTxt("Rundrum",["x",x,"y",y,"rad",rI,"eck",eck,"twist",twist,"grad",grad,"lap",lap,"fn",fn,"fs",fs,"fa",fa,"size",size,"name",name],help);    
}

/** \page Objects
Torus() creates a torus with optional child();

\param trx radius torus
\param d,r   diameter or radius rim (use $d,$r in children)
\param rot rotate 2D children
\param a,grad   angle torus (a is centered)
\param fn,fn2 fragments
\param fs,fs2 fragmentsize
\param dia  outer diameter torus optional to trx
\param id   inner diameter torus optional to trx
\param center center z
\param end  add Ends
\param trxEnd,gradEnd  end Torus radius and angle
\param lap  overlap of extrusions 
*/

//Torus(grad=130,end=+2,trxEnd=-3,fn=0,lap=.1,center=-1);