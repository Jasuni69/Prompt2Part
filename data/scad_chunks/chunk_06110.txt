module sweep_attach(parent, child, frac, idx, pathlen, spin=0, overlap=0, atype="hull", cp="centroid")
{
   $attach_to=child;
   req_children($children);
   dummy =  assert(!is_undef($sweep_transforms), "sweep_attach() must be used as a child of sweep() or path_sweep()")
            assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"")
            assert(num_defined([idx,frac,pathlen])==1, "Must define exactly one of idx, frac and pathlen")
            assert(is_undef(idx) || is_finite(idx), "idx must be a number")
            assert(is_undef(frac) || is_finite(frac), "frac must be a number");
   parmset = is_def(frac) ? "frac"
           : is_def(pathlen) ? "pathlen"
           : "idx";
   path = !is_undef($sweep_path) ? $sweep_path
        : [for(T=$sweep_transforms) apply(T,CTR)];
   seglen = path_segment_lengths(path,closed=$sweep_closed);
   pathcum = [0, each cumsum(seglen)];
   totlen = last(pathcum);
   pathtable = [for(i=idx(pathcum)) [pathcum[i],i]];
   i = _force_int(is_def(idx) ? idx
                :let(
                      pathlen = is_def(pathlen) ? pathlen : frac*totlen
                  )
                  lookup(posmod(pathlen,totlen),pathtable)+len($sweep_transforms)*floor(pathlen/totlen) //floor(abs(pathlen)/totlen)*sign(pathlen)
   );
   twist = is_undef($sweep_twist) ? ident(4)
         : let(
                L = len($sweep_transforms),
                absturn = floor(abs(i)/L),
                turns = floor(i/L) //sign(i)*absturn-1
           )
           zrot(-turns*$sweep_twist);
   geom = attach_geom(region=force_region($sweep_shape), two_d=true, extent=atype=="hull", cp=cp);
   anchor_data = _find_anchor(parent, geom);
   anchor_pos = point3d(anchor_data[1]);
   anchor_dir = point3d(anchor_data[2]);
   length = len($sweep_transforms);
   nextind = is_int(i) ? i>=length-1 && !$sweep_closed ? assert(i==length-1,str(parmset," is too large for the path")) undef
                       : i+1
          : $sweep_closed ?  posmod(ceil(i),length)
          : assert(i<length-1,str(parmset," is too large for the path")) ceil(i);
   prevind = is_int(i) ? i<=0 && !$sweep_closed ? assert(i==0,str(parmset," must be nonnegative")) undef
                       : i-1 
           : $sweep_closed ? floor(i)
           : assert(i>0,str(parmset, " must be nonnegative")) floor(i);
   uniform = is_undef($sweep_scales) ? false
           : let( 
                   slist = [if (is_def(prevind)) select($sweep_scales,prevind),
                            select($sweep_scales,i),
                            if (is_def(nextind)) select($sweep_scales,nextind)]
             )
             all_equal(slist);
   if (is_int(i) && uniform){      // Unscaled integer case: just use the profile transformation
       multmatrix(select($sweep_transforms,i)*twist)
         translate(anchor_pos)
         yrot(spin)
           frame_map(z=point3d(anchor_dir),y=UP) down(overlap) children();
   }
   else if (is_int(i) && all_defined([nextind,prevind])) {      // Scaled integer case, must average two adjacent facets
       frac1 = 0.1*min(seglen[i-1],seglen[i])/seglen[i-1];   // But can't average two facets at ends so exclude that case    
       frac2 = 0.1*min(seglen[i-1],seglen[i])/seglen[i];       
       dirsprev = _find_ps_dir(frac1,prevind,i,twist,anchor_pos,anchor_dir); 
       dirsnext = _find_ps_dir(frac2,i,nextind,twist,anchor_pos,anchor_dir);
       pos = apply($sweep_transforms[i]*twist, anchor_pos);
       mixdir = dirsprev[2]+dirsnext[2];   // Normal direction
       ydir=cross(cross(mixdir, dirsprev[1]+dirsnext[1]),mixdir);  // y direction perpendicular to mixdir
       translate(pos)
         rotate(v=mixdir,a=spin)
         frame_map(y=ydir, z=mixdir)
           down(overlap)
           children();
  }
  else {                       // Non-integer case or scaled integer at the ends: compute directions from single facet
    interp = is_undef(prevind)?0
           : is_undef(nextind)?1
           : i-floor(i);
    dirs = _find_ps_dir(interp,first_defined([prevind,i]),first_defined([nextind,i]),twist,anchor_pos,anchor_dir);
    translate(dirs[0])
        rotate(v=dirs[2],a=spin)
        frame_map(y=dirs[1], z=dirs[2])
        down(overlap) children();
  }
}