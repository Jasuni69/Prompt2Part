function _rounding_offsets(edgespec,z_dir=1) =
        let(
                edgetype = struct_val(edgespec, "type"),
                extra = struct_val(edgespec,"extra"),
                N = struct_val(edgespec, "steps"),
                r = struct_val(edgespec,"r"),
                cut = struct_val(edgespec,"cut"),
                k = struct_val(edgespec,"k"),
                angle = struct_val(edgespec, "angle"), 
                radius = in_list(edgetype,["circle","teardrop"])
                            ? (is_def(cut) ? cut/(sqrt(2)-1) : r)
                         :edgetype=="chamfer"
                            ? (is_def(cut) ? sqrt(2)*cut : r)
                         : undef,
                chamf_angle = struct_val(edgespec, "angle"),
                cheight = struct_val(edgespec, "chamfer_height"),
                cwidth = struct_val(edgespec, "chamfer_width"),
                chamf_width = first_defined([!all_defined([cut,chamf_angle]) ? undef : cut/cos(chamf_angle),
                                             cwidth,
                                             !all_defined([cheight,chamf_angle]) ? undef : cheight*tan(chamf_angle)]),
                chamf_height = first_defined([
                                              !all_defined([cut,chamf_angle]) ? undef : cut/sin(chamf_angle),
                                              cheight,
                                              !all_defined([cwidth, chamf_angle]) ? undef : cwidth/tan(chamf_angle)]),
                joint = first_defined([
                        struct_val(edgespec,"joint"),
                        all_defined([cut,k]) ? 16*cut/sqrt(2)/(1+4*k) : undef
                ]),
                points = struct_val(edgespec, "points"),
                argsOK = in_list(edgetype,["circle","teardrop"])? is_def(radius) :
                        edgetype == "chamfer"? chamf_angle>0 && chamf_angle<90 && num_defined([chamf_height,chamf_width])==2 :
                        edgetype == "smooth"? num_defined([k,joint])==2 :
                        edgetype == "profile"? points[0]==[0,0] :
                        false
        )
        assert(argsOK,str("Invalid specification with type ",edgetype))
        let(
                offsets =
                        edgetype == "profile"? scale([-1,z_dir], p=list_tail(points)) :
                        edgetype == "chamfer"?  chamf_width==0 && chamf_height==0? [] : [[-chamf_width,z_dir*abs(chamf_height)]] :
                        edgetype == "teardrop"? (
                                radius==0? [] : concat(
                                        [for(i=[1:N]) [radius*(cos(i*45/N)-1),z_dir*abs(radius)* sin(i*45/N)]],
                                        [[-2*radius*(1-sqrt(2)/2), z_dir*abs(radius)]]
                                )
                        ) :
                        edgetype == "circle"? radius==0? [] : [for(i=[1:N]) [radius*(cos(i*angle/N)-1), z_dir*abs(radius)*sin(i*angle/N)]] :
                        /* smooth */ joint==0 ? [] :
                        list_tail(
                                _bezcorner([[0,0],[0,z_dir*abs(joint)],[-joint,z_dir*abs(joint)]], k, $fn=N+2)
                        )
        )
        quant(extra > 0 && len(offsets)>0 ? concat(offsets, [last(offsets)+[0,z_dir*extra]]) : offsets, 1/1024);



// Function: smooth_path()
// Synopsis: Create a smoothed path passing through all the points of a given path, or passing through all the segment midpoint tangents.
// SynTags: Path
// Topics: Rounding, Paths
// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()
// Usage: "edges" method
//   smoothed = smooth_path(path, [tangents], [size=|relsize=], [method="edges"], [splinesteps=], [closed=], [uniform=]);
// Usage: "corners" method
//   smoothed = smooth_path(path, [size=|relsize=], method="corners", [splinesteps=], [closed=]);
// Description:
//   Smooths the input path, creating a continuous curve using a cubic spline, using one of two methods.
//   .
//   For `method="edges"` (default), every segment (edge) of the path is replaced by a cubic curve with `splinesteps`
//   points, and the cubic interpolation passes through every input point on the path, matching the tangents at every
//   point. If you do not specify `tangents`, they are computed using {{path_tangents()}} with `uniform=false` by
//   default. Only the dirction of a tangent vector matters, not the vector length.
//   Setting `uniform=true` with non-uniform sampling may be desirable in some cases but tends to
//   produces curves that overshoot the point on the path.  
//   .
//   For `method="corners"`, every corner of the path is replaced by two cubic curves, each with
//   `splinesteps` points. The two curves are joined at the corner bisector, and the cubic interpolations
//   are tangent to the midpoint of every segment. The `tangents` and `uniform` parameters don't apply to the
//   "corners" method. Using either one with "corners" causes an error.
//   .
//   The `size` or `relsize` parameters apply to both methods. They determine how far the curve can bend away
//   from the input path. In the case where the path has three non-collinear points, the size specifies the
//   exact distance between the specified path and the curve (maximum distance from edge if for the "edges"
//   method, or distance from corner with the "corners" method).
//   In 2D when the spline may make an S-curve, for the "edges" method the size parameter specifies the sum
//   of the deviations of the two peaks of the curve. In 3-space the bezier curve may have three extrema: two
//   maxima and one minimum.  In this case the size specifies the sum of the maxima minus the minimum.
//   .
//   If you give `relsize` instead, then for the "edges" method, the maximum deviation from the segment is
//   relative to  the segment length (e.g. 0.05 means 5% of the segment length). For the "corners" method,
//   `relsize` determines where the curve intersects the corner bisector, relative to the maximum deviation
//   possible (which corresponds to a circle rounding from the shortest leg of the corner). For example,
//   `relsize=1` is the maximum deviation from the corner (a circle arc from the shortest leg), and `relsize=0.5`
//   causes the curve to intersect the corner bisector halfway between that maximum and the tip of the corner.
//   .
//   At a given segment or corner (depending on the method) there is a maximum size: a size value that is too
//   large is rounded down. See also path_to_bezpath().
// Arguments:
//   path = path to smooth
//   tangents = tangents constraining curve direction vectors (vector length doesn't matter) at each point for `method="edges"`. Default: computed automatically
//   ---
//   relsize = relative maximum devation between the curve and edge (for method="edges") or corner (for method="corners"), a number or vector, expressed as proportion of edge length or proportion of max distance from corner (typically between 0 and 1). Default: 0.1 for `method="edges"` or 0.5 for `method="corners"`
//   size = absolute deviation between the curve and edge (for method="edges") or corner (for method="corners"), a number or vector.
//   method = type of curve; "edges" makes a curve that intersects all the path vertices but deviates from the path edges, and "corners" makes a curve that is tangent to all segment midpoints but deviates from the corners. Default: "edges"
//   splinesteps = Number of steps for each bezier curve section. Default: 10
//   uniform = set to true to compute tangents with uniform=true. Applies only to "edges" method. Default: false
//   closed = true if the curve is closed.  Default: false.
// Example(2D): Original path in green, smoothed "edges" path in yellow, "corners" path in red:
//   color("green")stroke(square(4), width=0.06);
//   stroke(smooth_path(square(4),size=0.4), width=0.1);
//   stroke(smooth_path(square(4),method="corners",size=0.4),
//          color="red", width=0.1);
// Example(2D): Closing the path changes the end tangents. Original path in green, "edges" path in yellow, "corners" in red.
//   polygon(smooth_path(square(4),method="edges",size=0.4,closed=true));
//   color("red")
//     polygon(smooth_path(square(4),method="corners",size=0.4,closed=true));
//   stroke(square(4), color="green", closed=true, width=0.06);
// Example(2D): Here's the square again with less smoothing. The "edges" curve is closer to the edge of the square, and the "corners" curve is closer to the square's corners.
//   polygon(smooth_path(square(4), size=.25,closed=true));
//   color("red") polygon(smooth_path(square(4),
//        method="corners",size=.25,closed=true));
//   stroke(square(4), closed=true, color="green", width=0.05);
// Example(2D): Turning on uniform tangent calculation also changes the end derivatives for the "edges" curve:
//   color("green")stroke(square(4), width=0.1);
//   stroke(smooth_path(square(4),size=0.4,uniform=true),
//          width=0.1);
// Example(2D): Here's a wide rectangle. With `method="edges"` (yellow), using `size` means all edges bulge the same amount, regardless of their length. With `method="corners"` (red), the curve is `size` distance from the corners (up to a maximum theoretical circular arc).
//   color("green")
//     stroke(square([10,5]), closed=true, width=0.06);
//   stroke(smooth_path(square([10,5]), method="edges",
//     size=1, closed=true), width=0.1);
//   stroke(smooth_path(square([10,5]), method="corners",
//     size=1, closed=true), width=0.1, color="red");
// Example(2D): For the "edges" curve, with relsize the bulge is proportional to the side length. 
//   color("green")stroke(square([10,4]), closed=true, width=0.1);
//   stroke(smooth_path(square([10,4]),relsize=0.1,closed=true),
//          width=0.1);
// Example(2D,Med,NoScales): For the "corners" curve, with relsize the distance from the corner is proportional to the maximum distance corresponding to a circular arc (shown in red) from the shorter leg of the corner. As `relsize` approaches zero, the curve approaches the corner.
//   stroke(smooth_path(square([20,15]), method="corners", relsize=1, closed=true),
//          color="red", closed=true, width=0.1);
//   stroke(smooth_path(square([20,15]), method="corners", relsize=0.66, closed=true),
//          color="gold", closed=true, width=0.1);
//   stroke(smooth_path(square([20,15]), method="corners", relsize=0.33, closed=true),
//          color="blue", closed=true, width=0.1);
//   stroke(smooth_path(square([20,15]), method="corners", relsize=0.001, closed=true),
//          color="green", closed=true, width=0.1);
// Example(2D): Settting uniform to true biases the tangents to align more with the line sides (applicable only to "edges" method).
//   color("green")
//     stroke(square([10,4]), closed=true, width=0.1);
//   stroke(smooth_path(square([10,4]),uniform=true,
//                      relsize=0.1,closed=true),
//          width=0.1);
// Example(2D): A more interesting shape, comparing the "edges" method (yellow) with "corners" method (red).
//   path = [[0,0], [4,0], [7,14], [-3,12]];
//   polygon(smooth_path(path,size=1,closed=true));
//   color("red") polygon(smooth_path(path,method="corners",relsize=0.7,closed=true));
//   stroke(path, color="green", width=0.2, closed=true);
// Example(2D,NoScales): Here's the square with a size that's too big to achieve, giving the the maximum possible curve with `method="edges"` (yellow). For `method="corners"` (red), the maximum possible distance from the corners is a circle.
//   color("green")stroke(square(4), width=0.06,closed=true);
//   stroke(smooth_path(square(4), method="edges", size=4, closed=true),
//          closed=true, width=0.1);
//   stroke(smooth_path(square(4), method="corners", size=4, closed=true),
//          color="red", closed=true, width=0.1);
// Example(2D): For `method="edges"`, you can alter the shape of the curve by specifying your own arbitrary tangent values. Only the vector direction matters, not the vector length.
//   polygon(smooth_path(square(4),
//           tangents=[[-2,-1], [-4,1], [1,2], [6,-1]],
//           size=0.4,closed=true));
// Example(2D): You can give a different size for each segment ("edges" method in yellow) or corner ("corners" method in red). The first vertex of the square (green) is the lower right corner, and the first edge is the bottom segment.
//   polygon(smooth_path(square(4),size = [.4, .05, 1, .3],
//                       method="edges", closed=true));
//   color("red")
//     polygon(smooth_path(square(4), size = [.4, .05, 1, .3],
//                         method="corners", closed=true));
//   stroke(square(4), color="green", width=0.03,closed=true);
// Example(FlatSpin,VPD=35,VPT=[4.5,4.5,1]): Works on 3d paths also.
//   path = [[0,0,0],[3,3,2],[6,0,1],[9,9,0]];
//   stroke(smooth_path(path,relsize=.1),width=.3);
//   color("red") for(p=path) translate(p) sphere(d=0.3);
//   stroke(path, width=0.1, color="red");
// Example(FlatSpin,VPD=45): Comparison of "edges" and "corners" 3D path resembling a [trefoil knot](https://en.wikipedia.org/wiki/Trefoil_knot).
//   shape = [[8.66, -5, -5], [8.66, 5, 5], [-2, 3.46, 0],
//       [-8.66, -5, -5], [0, -10, 5], [4, 0, 0],
//       [0, 10, -5], [-8.66, 5, 5], [-2, -3.46, 0]];
//   stroke(smooth_path(shape, method="corners", relsize=1, closed=true), color="red", closed=true, width=0.5);
//   stroke(smooth_path(shape, method="edges", size=1.5, closed=true, splinesteps=20), closed=true, width=0.5);
//   stroke(shape, color="green", width=0.15, closed=true);
// Example(2D): For the default "edges" method, this shows the type of overshoot that can occur with `uniform=true`.  You can produce overshoots like this if you supply a tangent that is difficult to connect to the adjacent points  
//   pts = [[-3.3, 1.7], [-3.7, -2.2], [3.8, -4.8], [-0.9, -2.4]];
//   stroke(smooth_path(pts, uniform=true, relsize=0.1),width=.1);
//   color("red")move_copies(pts)circle(r=.15,$fn=12);
// Example(2D): With the default of `uniform=false` no overshoot occurs.  Note that the shape of the curve is quite different.  
//   pts = [[-3.3, 1.7], [-3.7, -2.2], [3.8, -4.8], [-0.9, -2.4]];
//   stroke(smooth_path(pts, uniform=false, relsize=0.1),width=.1);
//   color("red")move_copies(pts)circle(r=.15,$fn=12);