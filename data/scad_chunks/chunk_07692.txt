module Spirale(grad=400*1,diff=2,radius=10,r1,r2,rand=n(2),$d,detail,fn=fn,exp=1,center=false,hull=true,end=2,old=false,scale=1,name,help){
   detail=fn;//compatibility
   advance=grad/detail; 
    rand=is_undef($d)?rand:$d;
    $d=rand;
    radius=is_undef(r1)?radius:center&&is_num(r2)?r1-r2/2:r1;
    iDiff=is_undef(r2)?diff:center?(radius-r2)/grad*360*2:(radius-r2)/grad*360;
    //diff=is_undef(r2)?diff:center?(radius-r2)/grad*360*2:(radius-r2)/grad*360;
    
    
       
    // * // recursive calculation
    function expDiff(diff=iDiff)=assert(exp>0)pow( (abs(diff/360*grad)), exp )*sign(diff);
    
    function diffAdj(f=1)=
    let(ratio=expDiff(iDiff*f)/(iDiff/360*grad))
    exp>1?ratio<=1+0.00000001?f:
                   diffAdj(f-f/100):
          ratio>=1-0.00000001?f:
                   diffAdj(f+ f/100)
    ;

    //echo(expDiff(iDiff*diffAdj())/(iDiff/360*grad),diffAdj());
    diff=is_undef(r2)?pow(iDiff,1/exp):
                      iDiff*(exp==1?1:diffAdj());
    // */
    
 /*
    diff=is_undef(r2)?pow(iDiff,1/exp):
                      pow(iDiff/360*grad,1/exp);
// */

 //center=is_undef(r2)?center:false;
 
 
/*
pointsOld=!$children?center?[
    for(i=[0:fn])RotLang(i*-grad/fn,diff/2/360*grad+radius-rand/2-pow(i*(diff/360*grad)/(fn),exp)),
    for(i=[fn:-1:0])RotLang(i*-grad/fn,diff/2/360*grad+radius+rand/2-pow(i*(diff/360*grad)/(fn),exp))]
    :[// center=false
for(i=[0:fn])RotLang(i*-grad/fn,radius-rand/2-pow(i*(diff/360*grad)/(fn),exp)),
for(i=[fn:-1:0])RotLang(i*-grad/fn,radius+rand/2-pow(i*(diff/360*grad)/(fn),exp))]
    :[0];// $children=true ⇒ deactivate point calculation
*/

path=[
  for(i=[0:fn])RotLang(
    i*-grad/fn, (center?diff/2/360*grad:0) + radius- pow( abs(diff/360*grad)*i/fn,exp)*sign(diff) )
];

points=concat(
  pathPoints(points=[[ rand/2,0]], path=path, 2D=true, scale=scale),
  pathPoints(points=[[-rand/2,0]], path=path, 2D=true, scale=scale, rev=true)
  );


if(!$children&&!old)rotate(center?-grad/2:0)union(){
    rotate(-90) polygon(points);
   if(b(end,false)>0) rotate(0)T((center?diff/2/360*grad:0)+radius)circle(d=rand,$fn=36);
   if(b(end,false)<0||end==2) rotate(grad)T((center?diff/2/360*grad:0)+radius-pow(grad/360*abs(diff),exp)*sign(diff))circle(d=rand*scale,$fn=36);
    
}

if(!$children&&old)// compatibility old version
    for(i=[center?-grad/2:0:advance:(center?grad/2:grad)-minVal]){
    j=i+advance;    
        Color(i/((center?grad/2:grad)-minVal))hull(){
        rotate(i)T(radius-pow(i/360*diff,exp))circle(d=rand,$fn=36);
        rotate(j)T(radius-pow(j/360*diff,exp))circle(d=rand,$fn=36); 
        }           
    }
    
if ($children)    for(i=[center?-grad/2:0:advance:(center?grad/2:grad)-minVal]){
    j=i+advance;
    $idx=i;
      if(hull) Color(i/((center?grad/2:grad)-minVal),$idxON=false) hull(){
        
        rotate(i)T(radius-pow(i/360*diff,exp))children();
        rotate(j)T(radius-pow(j/360*diff,exp))union(){$idx=j;children();} 
        } 
      else {
        if(i==0||i==-grad/2)rotate(i)T(radius-pow(i/360*diff,exp))children();
        rotate(j)T(radius-pow(j/360*diff,exp))children();
        
      }
            
            
    }
 
    //langold=( 2*radius-diff )* PI/360*grad;echo(langold);
    lang=pathLength(path);
    randEnd=end==true||b(end,false)>0?rand/2 + (end==2?rand/2*scale :0) : 0;
 InfoTxt("Spirale", ["Länge ",lang+randEnd ],name);
     
 HelpTxt("Spirale",[
   "grad",grad,
   "diff",diff,
   "radius",radius,
   "r1",r1,
   "r2",r2,
   "rand",rand,
   "$d",$d,
   //detail=",detail,"
   "fn",fn,
   "exp",exp,
   "center",center,
   "hull",hull,
   "end",end,
   "old",old,
   "scale",scale,
   "name",name],
   help);
}