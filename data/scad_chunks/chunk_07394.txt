module Strebe(h=20,d=5,d2,rad=4,rad2,sc=0,grad=0,skew=0,single=false,angle=360,spiel,fn=fn,fn2=fn?fn/4:undef,center=false,name, use2D=false,lap=.2,help){
    
    fn2=is_list(fn2)?fn2:[fn2,fn2];
    rad2=is_undef(rad2)?is_list(rad)?rad[1]:
                            rad:
                   rad2;
    rad=is_list(rad)?rad[0]:rad;
    d2=is_undef(d2)?d:d2;
    skew=skew?skew:tan(grad);
    grad=atan(skew);
    sc=sc?sc:d/(d*cos(grad));
    winkel=h==rad+rad2?90:
                       atan((single?(h-rad):
                                    (h-rad-rad2))/(d2/2-d/2));
    lap=is_undef(spiel)?is_list(lap)?lap:[1,1]*lap:spiel*[1,1];

    grad1=winkel>0?180-winkel:abs(winkel);//90;//VerbindugsWinkel unten
    grad2=180-grad1;//VerbindugsWinkel oben    
    //assert(h>=(rad+rad2),str("Strebe too short h=",h,"<",rad,"+",rad2," for rad")); 


  if (!use2D && !is_parent(needs2D))//search(["Rundrum"], parentList())[0] )
    M(skewzx=skew) Tz(center ? -h/2 : 0) scale([sc, 1, 1])
      rotate(-angle/2) rotate_extrude(angle=angle, convexity=5, $fn=fn)
        Strebe(skew=0, h=h, d=d, d2=d2, rad=rad, rad2=rad2, sc=1, grad=0, single=single, lap=lap, fn2=fn2, name=0, use2D=2, help=false);


  InfoTxt("Strebe",[
    "Neigungs ∡",str(atan(skew),"°"),
    "center ∡",str(single||rad!=rad2?"~":"=",winkel,"°"),
    "Scale",sc,
    " dSkew",str(d,"/",d*sc*cos(grad),"-",d2,"/",d2*sc*cos(grad),"mm"),
    "Parent",parentList()
  ],name); 


if (use2D || is_parent(needs2D))//search(["Rundrum"], parentList())[0] )
  M(skewyx=skew)T(0,center?-h/2:0){
    if(grad1>90) Echo(str("Strebe ∅",d,"mm is d=",(d/2-rad+sin(grad1)*rad)*2),color="warning");
    if(grad2>90) Echo(str("Strebe ∅",d2,"mm is d2=",(d2/2-rad2+sin(grad2)*rad2)*2),color="warning");
    Echo(str("Strebe too short h=",h,"<",rad,"+",rad2," for rad"),color="warning",condition=h<(rad+rad2));
    
   points= concat(
    use2D==2?[[0,h+lap[1]]]:single?[[-d2/2,h]]: kreis(fn=fn2[1],rand=0,r=rad2,grad=-grad2,rot=+grad2,center=false,sek=true,t=[-d2/2-abs(sin(winkel))*rad2,h-rad2]), // open L
    
    use2D==2?[[+0,h+lap[1]]]:[[single?-d2/2:-d2/2-rad2,h+lap[1]]],
    
    [[single?d2/2:d2/2+rad2,h+lap[1]]],
    
    single?[[d2/2,h]]: kreis(fn=fn2[1],rand=0,r=rad2,grad=-grad2,rot=0,center=false,sek=true,t=[d2/2+abs(sin(winkel))*rad2,h-rad2]),// open R
    
    kreis(fn=fn2[0],rand=0,r=rad,grad=-grad1,rot=grad1-180,center=false,sek=true,t=[d/2+abs(sin(winkel))*rad,rad]), // unten R
    
    [[d/2+rad,0-lap[0]]],
    
    use2D==2?[[0,-lap[0]]]:[[-d/2-rad,0-lap[0]]],
    
    use2D==2?[[+0,0]]:kreis(fn=fn2[0],rand=0,r=rad,grad=-grad1,rot=180,center=false,sek=true,t=[-d/2-abs(sin(winkel))*rad,rad]));// unten L
    
    
    scale([sc,1])polygon(points,convexity=5); 

}

HelpTxt("Strebe",["h",h,"d",d,"d2",d2,"rad",rad,"rad2",rad2,"sc",sc,"grad",grad,"skew",skew,"single",single,"angle",angle,"lap",lap,"fn",fn,"fn2",fn2,"name",name,"2D",str(use2D,"/*2 for halb*/")],help); 

}



/// Bezier() creates a Bezier shape polygon or 3D

//RotEx(cut=true)Bezier(mpRot=true);