function _contour_vertices(pxlist, pxsize, isovalmin, isovalmax, segtablemin, segtablemax) = [
    for(px = pxlist) let(
        v = px[0],
        idxmin = px[1],
        idxmax = px[2],
        f = px[3],
        bbsides = px[4],
        vpix = [ v, v+[0,pxsize.y], v+[pxsize.x,0], v+[pxsize.x,pxsize.y], v+0.5*[pxsize.x,pxsize.y] ]
    ) each [
        for(sp=segtablemin[idxmin]) // min contour
            if(len(sp)>0) [
                for(p=sp)
                    let(
                        edge = _MTEdgeVertexIndices[p],
                        vi0 = edge[0],
                        vi1 = edge[1],
                        denom = f[vi1] - f[vi0],
                        u = abs(denom)<0.00001 ? 0.5 : (isovalmin-f[vi0]) / denom
                      ) vpix[vi0] + u*(vpix[vi1]-vpix[vi0])
            ],
        for(sp=segtablemax[idxmax]) // max contour
            if(len(sp)>0) [
                for(p=sp)
                    let(
                        edge = _MTEdgeVertexIndices[p],
                        vi0 = edge[0],
                        vi1 = edge[1],
                        denom = f[vi1] - f[vi0],
                        u = abs(denom)<0.00001 ? 0.5 : (isovalmax-f[vi0]) / denom
                      ) vpix[vi0] + u*(vpix[vi1]-vpix[vi0])
            ],
        if(len(bbsides)>0) for(b = bbsides)
            let(
                edge = _MTEdgeVertexIndices[b],
                vi0 = edge[0],
                vi1 = edge[1],
                rev = f[vi0]<f[vi1],
                f0 = f[vi0],
                f1 = f[vi1],
                p0 = vpix[vi0],
                p1 = vpix[vi1],
                denom = f1 - f0,
                umin = abs(denom)<0.00001 ? 0.5 : max(-1e9, min(1e9, isovalmin-f0)) / denom,
                umax = abs(denom)<0.00001 ? 0.5 : max(-1e9, min(1e9, isovalmax-f0)) / denom,
                midptmin = p0 + umin*(p1-p0),
                midptmax = p0 + umax*(p1-p0)
            ) 
            if(f0<=isovalmin && isovalmin<=f1 && f1<=isovalmax) [midptmin, p1]
            else if(f0>=isovalmax && isovalmax>=f1 && f1>=isovalmin) [midptmax, p1]
            else if(f1>=isovalmax && isovalmax>=f0 && f0>=isovalmin) [p0, midptmax]
            else if(f1<=isovalmin && isovalmin<=f0 && f0<=isovalmax) [p0, midptmin]
            else if(f0<isovalmin && f1>isovalmax) [midptmin, midptmax]
            else if(f0>isovalmax && f1<isovalmin) [midptmax, midptmin]
            else if((f0<f1 && isovalmin<=f0 && isovalmax>=f1) || (f1<f0 && isovalmin<=f1 && isovalmax>=f0))
                [p0, p1]
    ]
];




/// ---------- 3D metaball stuff starts here ----------

/// Animated metaball demo made with BOSL2 here: https://imgur.com/a/m29q8Qd

/// Built-in metaball functions corresponding to each MB_ index.
/// For speed, they are split into four functions, each handling a different combination of influence != 1 or influence == 1, and cutoff < INF or cutoff == INF.
/// Each function returns a list: [function literal [sign, vnf]]

/// public metaball cutoff function if anyone wants it (demonstrated in example)