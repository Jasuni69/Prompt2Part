function join_prism(polygon, base, base_r, base_d, base_T=IDENT,
                    scale=1, prism_end_T=IDENT, short=false, 
                    length, l, height, h,
                    aux="none", aux_T=IDENT, aux_r, aux_d,
                    overlap, base_overlap,aux_overlap,
                    n=15, base_n, aux_n, end_n, 
                    fillet, base_fillet,aux_fillet,end_round,
                    k=0.7, base_k,aux_k,end_k,
                    uniform=true, base_uniform, aux_uniform, 
                    debug=false, return_axis=false,
                    smooth_normals=true, base_smooth_normals, aux_smooth_normals, 
                    start, end, _name1="base", _name2="aux") =
  let(
      objects=["cyl","cylinder","plane","sphere"],
      length = one_defined([h,height,l,length], "h,height,l,length", dflt=undef)
  )
  assert(is_path(polygon,2),"Prism polygon must be a 2d path")
  assert(is_rotation(base_T,3,centered=true),"Base transformation must be a rotation around the origin")
  assert(is_rotation(aux_T,3),"Aux transformation must be a rotation")
  assert(aux!="none" || is_rotation(aux_T,centered=true), "With no aux, aux_T must be a rotation centered on the origin")
  assert(is_matrix(prism_end_T,4), "Prism endpoint transformation is invalid")
  assert(aux!="none" || (is_num(length) && length>0),"With no aux must give positive length")
  assert(aux=="none" || is_undef(length), "length parameter allowed only when aux is \"none\"")
  assert(aux=="none" || is_path(aux,2) || in_list(aux,objects), "Unknown aux type")
  assert(is_path(base,2) || in_list(base,objects), "Unknown base type")
  assert(is_undef(length) || (is_num(length) && length>0), "Prism length must be positive")
  assert(is_num(scale) && scale>=0, "Prism scale must be non-negative")
  assert(num_defined([end_k,aux_k])<2, "Cannot define both end_k and aux_k")
  assert(num_defined([end_n,aux_n])<2, "Cannot define both end_n and aux_n")
  assert(prism_end_T==IDENT || num_defined([start,end])==0, "Cannot give prism_end_T with either start or end")
  let(
      base_r = get_radius(r=base_r,d=base_d),
      aux_r = get_radius(r=aux_r,d=aux_d),
      base_k= first_defined([base_k,k]),
      aux_k = first_defined([end_k,aux_k,k]),
      aux_n = first_defined([end_n,aux_n,n]),
      base_n = first_defined([base_n,n]),
      base_fillet = one_defined([fillet,base_fillet],"fillet,base_fillet"),
      aux_fillet = aux=="none" ? one_defined([aux_fillet,u_mul(-1,end_round)],"aux_fillet,end_round",0)
              : one_defined([fillet,aux_fillet],"fillet,aux_fillet"),
      base_overlap = one_defined([base_overlap,overlap],"base_overlap,overlap",base_fillet>0?1:0),
      aux_overlap = one_defined([aux_overlap,overlap],"aux_overlap,overlap",aux_fillet>0?1:0),
      base_uniform = first_defined([base_uniform, uniform]),
      aux_uniform = first_defined([aux_uniform, uniform]),
      base_smooth_normals = first_defined([base_smooth_normals, smooth_normals]),
      aux_smooth_normals = first_defined([aux_smooth_normals, smooth_normals])
      
  )
  assert(is_num(base_fillet),"Must give a numeric fillet or base_fillet value")
  assert(base=="plane" || base_fillet>=0, "Fillet for non-planar base object must be nonnegative")
  assert(is_num(aux_fillet), "Must give numeric fillet or aux_fillet")
  assert(in_list(aux,["none","plane"]) || aux_fillet>=0, "Fillet for aux object must be nonnegative")
  assert(!in_list(base,["sphere","cyl","cylinder"]) || (is_num(base_r) && !approx(base_r,0)), str("Must give nonzero base_r with base ",base))
  assert(!in_list(aux,["sphere","cyl","cylinder"]) || (is_num(aux_r) && !approx(aux_r,0)), str("Must give nonzero aux_r with base ",base))
  assert(!short || (in_list(base,["sphere","cyl","cylinder"]) && base_r<0), "You can only set short to true if the base is a sphere or cylinder with radius<0")
  let(
      base_r=default(base_r,1),
      aux_r=default(aux_r,1),
      polygon=clockwise_polygon(polygon),
      start_center = CENTER,
      aux_T_horiz = submatrix(aux_T,[0:2],[0:2]) == ident(3) && aux_T[2][3]==0, 
      dir = num_defined([start,end])==2 ? end-start
          : aux=="none" ? apply(aux_T,UP)
          : aux_T_horiz && in_list([base,aux], [["sphere","sphere"], ["cyl","cylinder"],["cylinder","cyl"], ["cyl","cyl"], ["cylinder", "cylinder"]]) ?
            unit(apply(aux_T, aux_r*UP))
          : apply(aux_T,CENTER)==CENTER ? apply(aux_T,UP)
          : apply(aux_T,CENTER),
      flip = short ? -1 : 1,
      axisline = [CENTER, flip*dir] +  repeat(default(start,CENTER),2), 
      start = base=="sphere" ?
                let( answer = _sphere_line_isect_best(abs(base_r),axisline, sign(base_r)*flip*dir))
                assert(answer,"Prism center doesn't intersect sphere (base)")
                answer
            : base=="cyl" || base=="cylinder" ?
                assert(dir.y!=0 || dir.z!=0, "Prism direction parallel to the cylinder")
                let(
                     mapped = apply(yrot(90),axisline),
                     answer = _cyl_line_intersection(abs(base_r),mapped,sign(base_r)*mapped[1])
                 )
                 assert(answer,"Prism center doesn't intersect cylinder (base)")
                 apply(yrot(-90),answer)
            : is_path(base) ?
                let( 
                     mapped = apply(yrot(-90),axisline),
                     answer = _prism_line_isect(pair(base,wrap=true),mapped,sign(base_r)*mapped[1])[0]
                 )
                 assert(answer,"Prism center doesn't intersect prism (base)")
                 apply(yrot(90),answer)
            : start_center,
      aux_T = aux=="none" ? move(start)*prism_end_T*move(-start)*move(length*dir)*move(start)
              : aux_T,
      prism_end_T = aux=="none" ? IDENT : prism_end_T,
      aux = aux=="none" && aux_fillet!=0 ? "plane" : aux, 
      end_center = apply(aux_T,CENTER), 
      ndir = base_r<0 && in_list(base,["cylinder","cyl","sphere"]) ? unit(start_center-start) : unit(end_center-start_center,UP),
      end_prelim = is_def(end) ? end
        :apply(move(start)*prism_end_T*move(-start),
            aux=="sphere" ?
                let( answer = _sphere_line_isect_best(abs(aux_r), [start,start+ndir], -sign(aux_r)*ndir))
                assert(answer,"Prism center doesn't intersect sphere (aux)")
                apply(aux_T,answer)
          : aux=="cyl" || aux=="cylinder" ? 
                let(
                     mapped = apply(yrot(90)*rot_inverse(aux_T),[start,start+ndir]),
                     answer = _cyl_line_intersection(abs(aux_r),mapped, -sign(aux_r)*(mapped[1]-mapped[0]))
                 )
                 assert(answer,"Prism center doesn't intersect cylinder (aux)")
                 apply(aux_T*yrot(-90),answer)
          : is_path(aux) ?
                let( 
                     mapped = apply(yrot(90),[start,start+ndir]),
                     answer = _prism_line_isect(pair(aux,wrap=true),mapped,sign(aux_r)*(mapped[0]-mapped[1]))[0] 
                 )
                 assert(answer,"Prism center doesn't intersect prism (aux)")
                 apply(aux_T*yrot(-90),answer)
          : end_center
      ),
      end = prism_end_T == IDENT ? end_prelim
          : aux=="sphere" ?
                let( answer = _sphere_line_isect_best(abs(aux_r), move(-end_center,[start,end_prelim]), -sign(aux_r)*(end_prelim-start)))
                assert(answer,"Prism center doesn't intersect sphere (aux)")
                answer+end_center
          : aux=="cyl" || aux=="cylinder" ? 
                let(
                     mapped = apply(yrot(90)*move(-end_center),[start,end_prelim]),
                     answer = _cyl_line_intersection(abs(aux_r),mapped, -sign(aux_r)*(mapped[1]-mapped[0]))
                 )
                 assert(answer,"Prism center doesn't intersect cylinder (aux)")
                 apply(move(end_center)*yrot(-90),answer)
          : is_path(aux) ?
                let( 
                     mapped = apply(yrot(90)*move(-end_center),[start,end_prelim]),
                     answer = _prism_line_isect(pair(aux,wrap=true),mapped,sign(aux_r)*(mapped[0]-mapped[1]))[0]
                 )
                 assert(answer,"Prism center doesn't intersect prism (aux)")
                 apply(move(end_center)*yrot(-90),answer)
          : plane_line_intersection( plane_from_normal(apply(aux_T,UP), end_prelim),[start,end_prelim]),
      pangle = rot(from=UP, to=end-start),
      truetop = apply(move(start)*pangle,path3d(scale(scale,polygon),norm(start-end))),      
      truebot = apply(move(start)*pangle,path3d(polygon)),
      base_trans = rot_inverse(base_T),
      base_top = apply(base_trans, truetop),
      base_bot = apply(base_trans, truebot),
      botmesh = apply(base_T,_prism_fillet(_name1, base, base_r, base_bot, base_top, base_fillet, base_k, base_n, base_overlap,base_uniform,base_smooth_normals,debug)),
      aux_trans = rot_inverse(aux_T),
      aux_top = apply(aux_trans, reverse_polygon(truetop)),
      aux_bot = apply(aux_trans, reverse_polygon(truebot)),
      topmesh_reversed = _prism_fillet(_name2,aux, aux_r, aux_top, aux_bot, aux_fillet, aux_k, aux_n, aux_overlap,aux_uniform,aux_smooth_normals,debug),
      topmesh = apply(aux_T,[for(i=[len(topmesh_reversed)-1:-1:0]) reverse_polygon(topmesh_reversed[i])]),
      round_dir = select(topmesh,-1)-botmesh[0],
      roundings_cross = [for(i=idx(truetop)) if (round_dir[i]*(truetop[i]-truebot[i])<0) i],
      vnf = vnf_vertex_array(concat(topmesh,botmesh),col_wrap=true, caps=true, reverse=true)
  )
  assert(debug || roundings_cross==[],"Roundings from the two ends cross on the prism: decrease size of roundings")
  return_axis ? [vnf,start,end] : vnf;