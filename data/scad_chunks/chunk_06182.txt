module screw(spec, head, drive, thread, drive_size, 
             length, l, thread_len, tolerance, details=true, 
             undersize, shaft_undersize, head_undersize,
             atype="screw",anchor, spin=0, orient=UP,
             _shoulder_diam=0, _shoulder_len=0,
             bevel,bevel1,bevel2,bevelsize,
             blunt_start,blunt_start1, blunt_start2,
             _internal=false, _counterbore, _teardrop=false)
{
   tempspec = _get_spec(spec, "screw_info", _internal ? "screw_hole" : "screw",
                        thread=thread, head=head, drive=drive, drive_size=drive_size);
   undersize = is_num(undersize) ? [undersize,undersize]
             : undersize;
   dummyA=assert(is_undef(undersize) || is_vector(undersize,2), "Undersize must be a scalar or 2-vector")
          assert(is_undef(undersize) || num_defined([shaft_undersize, head_undersize])==0,
                 "Cannot combine \"undersize\" with other more specific undersize parameters")
          assert(is_bool(_teardrop) ||_teardrop=="max" || all_nonnegative([_teardrop]), str("Invalid teardrop parameter",_teardrop));
   _teardrop = _teardrop==true ? .05 : _teardrop;   // set teardrop default
   shaft_undersize = first_defined([shaft_undersize, undersize[0]]);
   head_undersize = first_defined([head_undersize, undersize[1]]);
   dummyB=assert(is_undef(shaft_undersize) || is_finite(shaft_undersize), "shaft_undersize must be a number")
          assert(is_undef(head_undersize) || is_finite(head_undersize), "head_undersize must be a number")
          assert(is_undef(_counterbore) || is_bool(_counterbore) || (is_finite(_counterbore) && _counterbore>=0),
                 "Counterbore must be a nonnegative number of boolean");
   l = one_defined([l,length],"l,length",dflt=undef);
   _counterbore = _counterbore==true ? struct_val(tempspec,"head_height") 
                : _counterbore==false ? undef
                : _counterbore;
   head = struct_val(tempspec,"head");
   headless = head=="none";
   flathead = is_def(head) && starts_with(head,"flat");
   reset_headsize = _internal && flathead ? struct_val(tempspec,"head_size_sharp") : undef;
   spec=_struct_reset(tempspec,[
                                ["length", l],
                                ["shaft_oversize", u_mul(-1,shaft_undersize)],
                                ["head_oversize", u_mul(-1,head_undersize)],
                                ["counterbore", _counterbore],
                                ["thread_len", thread_len],
                                ["head_size", reset_headsize],
                               ]);
   dummy = _validate_screw_spec(spec);
   $screw_spec = spec;
   pitch =  struct_val(spec, "pitch") ;
   threadspec = pitch==0 ? undef : thread_specification(spec, internal=_internal, tolerance=tolerance);
   nominal_diam = _nominal_diam(spec);
   d_major = pitch==0 ? nominal_diam : mean(struct_val(threadspec, "d_major"));
   length = struct_val(spec,"length");
   counterbore = default(struct_val(spec,"counterbore"),0);
   user_thread_len = struct_val(spec,"thread_len");
   dummyC = assert(in_list(atype,["shaft","head","shank","threads","screw","shoulder"]),str("Unknown anchor type: \"",atype,"\""))
            assert(is_finite(length) && length>0, "Must specify positive screw length")
            assert(is_finite(_shoulder_len) && _shoulder_len>=0, "Must specify a nonegative shoulder length")
            assert(is_finite(_shoulder_diam) && _shoulder_diam>=0, "Must specify nonnegative shoulder diameter")
            assert(is_undef(user_thread_len) || (is_finite(user_thread_len) && user_thread_len>=0), "Must specify nonnegative thread length");
   sides = max(pitch==0 ? 3 : 12, segs(nominal_diam/2));
   rad_scale = _internal? (1/cos(180/sides)) : 1;
   islop = _internal ? 4*get_slop() : 0;
   head_height = headless || flathead ? 0 
               : counterbore==true || is_undef(counterbore) || counterbore==0 ? struct_val(spec, "head_height")
               : counterbore;
   head_diam = struct_val(spec, "head_size",0) + struct_val(spec, "head_oversize",0);
   flat_height = !flathead ? 0 
               : let( given_height = struct_val(spec, "head_height"))
                 all_positive(given_height) ? given_height
               : (struct_val(spec,"head_size_sharp")+struct_val(spec,"head_oversize",0)-d_major*rad_scale-islop)/2/tan(struct_val(spec,"head_angle")/2);

   flat_cbore_height = flathead && is_num(counterbore) ? counterbore : 0;

   blunt_start1 = first_defined([blunt_start1,blunt_start,true]);
   blunt_start2 = first_defined([blunt_start2,blunt_start,true]);

   shoulder_adj = _shoulder_len>0 ? flat_height:0;  // Adjustment because flathead height doesn't count toward shoulder length
   shoulder_full = _shoulder_len==0 ? 0 : _shoulder_len + flat_height;
   shank_len = is_def(user_thread_len) ? length - user_thread_len - (_shoulder_len==0?flat_height:0) : 0;
   thread_len = is_def(user_thread_len) ? user_thread_len
              : length - (_shoulder_len==0?flat_height:0);
   dummyD = assert(!(atype=="shank" && shank_len==0), "Specified atype of \"shank\" but screw has no shank (thread_len not given or it equals shaft length)")
            assert(!(atype=="shoulder" && _shoulder_len==0), "Specified atype of \"shoulder\" but screw has no shoulder")
            assert(!(atype=="threads" && thread_len==0), "Specified atype of \"threads\" but screw has no threaded part (thread_len=0)")
            assert(!(atype=="head" && headless), "You cannot anchor headless screws with atype=\"head\"");
   eps_gen = 0.01;
   eps_shoulder = headless && !_internal ? 0 : eps_gen;
   eps_shank = headless && !_internal && _shoulder_len==0 ? 0 : eps_gen;
   eps_thread = headless && !_internal && shank_len==0 && _shoulder_len==0 ? 0 : eps_gen;
   dummyL = assert(_shoulder_len>0 || is_undef(flat_height) || flat_height < length,
                   str("Length of screw (",length,") is shorter than the flat head height (",flat_height,")"));
   offset = atype=="head" ? (-head_height+flat_height-flat_cbore_height)/2
          : atype=="shoulder" ? _shoulder_len/2 + flat_height
          : atype=="shaft" ? _shoulder_len + (length+flat_height+shoulder_adj)/2
          : atype=="shank" ? _shoulder_len + (length-thread_len+flat_height+shoulder_adj)/2
          : atype=="threads" ? _shoulder_len + shoulder_adj + length-thread_len + thread_len/2
          : atype=="screw" ? (length-head_height+_shoulder_len+shoulder_adj-flat_cbore_height)/2
          : assert(false,"Unknown atype");
   dummyM = //assert(!headless || !in_list(anchor,["head_top","head_bot","head_center"]), str("Anchor \"",anchor,"\" not allowed for headless screw"))
            assert(shank_len>0 || !in_list(anchor,["shank_top","shank_bot","shank_center"]),
                   str("Screw has no unthreaded shank so anchor \"",anchor,"\" is not allowed"));
   anchor_list = [
          named_anchor("top", [0,0,offset+head_height+flat_cbore_height]),
          named_anchor("bot", [0,0,-length-shoulder_full+offset]),
          named_anchor("center", [0,0, -length/2 - shoulder_full/2 + head_height/2 + offset]),
          named_anchor("head_top", [0,0,head_height+offset]),
          named_anchor("head_bot", [0,0,-flat_height+offset]),
          named_anchor("head_center", [0,0,(head_height-flat_height)/2+offset]),
          if (_shoulder_len>0) named_anchor("shoulder_top", [0,0,offset-flat_height]),
          if (_shoulder_len>0) named_anchor("shoulder_bot", [0,0,offset-shoulder_full]),
          if (_shoulder_len>0) named_anchor("shoulder_center", [0,0,offset-flat_height-_shoulder_len/2]),
          named_anchor("shaft_top", [0,0,-_shoulder_len-flat_height+offset]),
          named_anchor("shaft_bot", [0,0,-length-shoulder_full+offset]),
          named_anchor("shaft_center", [0,0,(-_shoulder_len-flat_height-length-shoulder_full)/2+offset]),
          if (shank_len>0) named_anchor("shank_top", [0,0,-_shoulder_len-flat_height+offset]),
          if (shank_len>0) named_anchor("shank_bot", [0,0,-shank_len-_shoulder_len-flat_height+offset]),
          if (shank_len>0) named_anchor("shank_center", [0,0,-shank_len/2-_shoulder_len-flat_height+offset]),
          named_anchor("threads_top", [0,0,-shank_len-_shoulder_len-flat_height+offset]),
          named_anchor("threads_bot", [0,0,-length-shoulder_full+offset]),
          named_anchor("threads_center", [0,0,(-shank_len-length-_shoulder_len-shoulder_full-flat_height)/2+offset])
   ];
   vnf = head=="hex" && atype=="head" && counterbore==0 ? linear_sweep(hexagon(id=head_diam*rad_scale),height=head_height,center=true) : undef;
   head_diam_full = head=="hex" ? 2*head_diam/sqrt(3) : head_diam;
   attach_d = in_list(atype,["threads","shank","shaft"]) ? d_major 
            : atype=="screw" ? max(d_major,_shoulder_diam,default(head_diam_full,0))
            : atype=="shoulder" ? _shoulder_diam
            : is_def(vnf) ? undef
            : head_diam_full;
   attach_l = atype=="shaft" ? length-(_shoulder_len>0?0:flat_height)
            : atype=="shoulder" ? _shoulder_len
            : atype=="shank" ? shank_len
            : atype=="threads" ? thread_len
            : atype=="screw" ? length+head_height+shoulder_full + flat_cbore_height
            : is_def(vnf) ? undef
            : head_height+flat_height+flat_cbore_height;
   bevelsize = default(bevelsize, d_major/12);
   bevel1 = first_defined([bevel1,bevel,true]);
   bevel2 = first_defined([bevel2,bevel,headless && _shoulder_len==0 && shank_len==0]);
   attachable(
              vnf = vnf, 
              d = u_add(u_mul(attach_d, rad_scale), islop),
              l = attach_l,
              orient = orient,
              anchor = anchor,
              spin = spin,
              anchors=anchor_list)
   {
     up(offset)
       difference(){
         union(){
           screw_head(spec,details,counterbore=counterbore,flat_height=flat_height,
                      slop=islop,teardrop=_teardrop);
           if (_shoulder_len>0)
             up(eps_shoulder-flat_height){
               if (_teardrop!=false) //////
                 teardrop(d=_shoulder_diam*rad_scale+islop,cap_h=is_num(_teardrop) ? (_shoulder_diam*rad_scale+islop)/2*(1+_teardrop):undef,
                          h=_shoulder_len+eps_shoulder, anchor=FRONT, orient=BACK, $fn=sides);
               else
                 cyl(d=_shoulder_diam*rad_scale+islop, h=_shoulder_len+eps_shoulder, anchor=TOP, $fn=sides, chamfer1=details ? _shoulder_diam/30:0);
             }
           if (shank_len>0 || pitch==0){
             L = pitch==0 ? length - (_shoulder_len==0?flat_height:0) : shank_len;
             bevsize = (_internal ? -1 : 1)*bevelsize;
             bev1 = pitch!=0 ? 0
                  : bevel1==true ? bevsize
                  : bevel1==false ? 0
                  : bevel1=="reverse" ? -bevsize
                  : bevel1;
             bev2 = pitch!=0 ? 0
                  : bevel2==true ? bevsize
                  : bevel2==false ? 0
                  : bevel2=="reverse" ? -bevsize
                  : bevel2;
             down(_shoulder_len+flat_height-eps_shank)
               if (_teardrop!=false)  ///////
                 teardrop(d=d_major*rad_scale+islop, cap_h=is_num(_teardrop) ? (d_major*rad_scale+islop)/2*(1+_teardrop) : undef,
                          h=L+eps_shank, anchor=FRONT, orient=BACK, $fn=sides, chamfer1=bev1, chamfer2=bev2);
               else
                 cyl(d=d_major*rad_scale+islop, h=L+eps_shank, anchor=TOP, $fn=sides, chamfer1=bev1, chamfer2=bev2);
           }
           if (thread_len>0 && pitch>0){
             down(_shoulder_len+flat_height+shank_len-eps_thread)
                   threaded_rod([mean(struct_val(threadspec, "d_minor")),
                                 mean(struct_val(threadspec, "d_pitch")),
                                 d_major], 
                      pitch = struct_val(threadspec, "pitch"),
                      l=thread_len+eps_thread, left_handed=false, internal=_internal, 
                      bevel1=bevel1,
                      bevel2=bevel2,teardrop=_teardrop,
                      blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2, 
                      $fn=sides, anchor=TOP);
            }
             
         }
         if (!_internal) _driver(spec);
       }
     children();
   }  
}



// Module: screw_hole()
// Synopsis: Creates a screw hole.
// SynTags: Geom
// Topics: Threading, Screws
// See Also: screw()
// Usage:
//   screw_hole([spec], [head], [thread=], [length=|l=], [oversize=], [hole_oversize=], [teardrop=], [head_oversize], [tolerance=], [$slop=], [blunt_start=], [anchor=], [atype=], [orient=], [spin=]) [ATTACHMENTS];
// Description:
//   Create a screw hole mask.  See [screw and nut parameters](#section-screw-and-nut-parameters) for details on the parameters that define a screw.
//   The screw hole can be threaded to receive a screw or it can be an unthreaded clearance hole.  
//   The tolerance determines the dimensions of the screw
//   based on ISO and ASME standards.  Screws fabricated at those dimensions will mate properly with standard hardware.
//   The $slop argument makes the hole larger by 4*$slop to account for printing overextrusion.  It defaults to 0.
//   .
//   You can generate a screw specification from {{screw_info()}}, possibly create a modified version, and pass that in rather than giving the parameters.
//   .
//   The tolerance should be a nut tolerance for a threaded hole or a clearance hole tolerance for clearance holes.
//   For clearance holes, the UTS tolerances are "normal", "loose" and "close".  ASME also specifies the same naming for metric clearance holes.
//   However, ISO gives "fine", "medium" and "coarse" instead.  This function accepts all of these in either system.  It also takes "tight" to be equivalent to "close",
//   even though no standard suggests it, because it's a natural opposite of "loose".  The official tolerance designations for ISO are "H12" for "fine", "H13" for "medium"
//   and "H14" for "coarse".  These designations will also work, but only for metric holes.  You can also set tolerance to 0 or "none" to produce holes at the nominal size.
//   .
//   If you want to produce holes for tapping you can use a tolerance of "tap".  This produces a hole of the nominal screw diameter reduced by the thread pitch.  You may still
//   need to adjust $slop for best results.  Some people screw machine screws directly into plastic without tapping.  This works better with a somewhat larger hole, so
//   a tolerance of "self tap" produces such a hole.  Note that this tolerance also makes the default bevel2=true to bevel the top, which makes it much easier
//   to start the screw.  The "self tap" tolerance subtracts `0.72 * pitch` when pitch is below 1mm, `0.6 * pitch` when the pitch is over 1.5mm, and it interpolates between.
//   It was tested in PLA with a Prusa MK3S and $slop=0.05 and worked on UTS screws from #2 up to 1/2 inch.  
//   .
//   The counterbore parameter adds a cylindrical clearance hole above the screw shaft.  For flat heads it extends above the flathead and for other screw types it 
//   replaces the head with a cylinder large enough in diameter for the head to fit.  For a flat head you must specify the length of the counterbore.  For other heads you can
//   set counterbore to true and it will be sized to match the head height.  The counterbore will extend 0.01 above the TOP of the hole mask to ensure no
//   problems with differences.  Note that the counterbore defaults to true for non-flathead screws.  If you want the actual head shape to appear, set counterbore to zero.
//   .
//   For 3d printing circular holes can be problematic.  One solution is to use octagonal holes, setting $fn=8.  Another option is to use a teardrop hole, which
//   can be accomplished by setting `teardrop=true`.  The point of the teardrop will point in the Y direction (BACK) so you will need to ensure that you orient it
//   correctly in your final model.  
//   .
//   Anchoring for screw_hole() is the same as anchoring for {{screw()}}, with all the same anchor types and named anchors.  If you specify a counterbore it is treated as
//   the "head", or in the case of flat heads, it becomes part of the head.  If you make a teardrop hole the point is ignored for purposes of anchoring.
// Arguments:
//   spec = screw specification, e.g. "M5x1" or "#8-32".  See [screw naming](#subsection-screw-naming).  This can also be a screw specification structure of the form produced by {{screw_info()}}.  
//   head = head type.  See [screw heads](#subsection-screw-heads)  Default: none
//   ---
//   thread = thread type or specification for threaded masks, true to make a threaded mask with the standard threads, or false to make an unthreaded mask.  See [screw pitch](#subsection-standard-screw-pitch). Default: false
//   teardrop = If true, adds a teardrop profile to the hole for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to "max" for a pointed teardrop. Default: false
//   oversize = amount to increase diameter of the screw hole (hole and countersink).  A scalar or length 2 vector.  Default: use computed tolerance
//   hole_oversize = amount to increase diameter of the hole.  Overrides the use of tolerance and replaces any settings given in the screw specification. 
//   head_oversize = amount to increase diameter of head.  Overrides the user of tolerance and replaces any settings given in the screw specification.  
//   length / l= length of screw (in mm)
//   counterbore = set to length of counterbore, or true to make a counterbore equal to head height.  Default: false for flat heads and headless, true otherwise
//   tolerance = threading or clearance hole tolerance.  For internal threads, detrmines actual thread geometry based on nominal sizing.  See [tolerance](#subsection-tolerance). Default is "2B" for UTS and 6H for ISO.  For clearance holes, determines how much clearance to add.  Default is "normal".  
//   bevel = if true create bevel at both ends of hole.  Default: see below
//   bevel1 = if true create bevel at bottom end of hole.  Default: false
//   bevel2 = if true create bevel at top end of hole.     Default: true when tolerance="self tap", false otherwise
//   blunt_start = if true and hole is threaded, create blunt start threads.  Default: true
//   blunt_start1 = if true and hole is threaded, create blunt start threads at bottom end.
//   blunt_start2 = if true and hole is threaded, create blunt start threads top end.
//   $slop = add extra gap to account for printer overextrusion.  Default: 0
//   atype = anchor type, one of "screw", "head", "shaft", "threads", "shank"
//   anchor = Translate so anchor point on the shaft is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
// Side Effects:
//   `$screw_spec` is set to the spec specification structure. 
// Anchor Types:
//   screw = the entire screw (default)
//   head = screw head (invalid for headless screws)
//   shaft = screw shaft
//   shank = unthreaded section of shaft (invalid if screw is fully threaded)
//   threads = threaded section of screw     
// Named Anchors:
//   "top" = top of screw
//   "bot" = bottom of screw
//   "center" = center of screw
//   "head_top" = top of head (invalid for headless screws)
//   "head_bot" = bottom of head (invalid for headless screws)
//   "head_center" = center of head (invalid for headless screws)
//   "shaft_top" = top of shaft
//   "shaft_bot" = bottom of shaft
//   "shaft_center" = center of shaft
//   "shank_top" = top of shank (invalid if screw is fully threaded)
//   "shank_bot" = bottom of shank (invalid if screw is fully threaded)
//   "shank_center" = center of shank (invalid if screw is fully threaded)
//   "threads_top" = top of threaded portion of screw (invalid if thread_len=0)
//   "threads_bot" = bottom of threaded portion of screw (invalid if thread_len=0)
//   "threads_center" = center of threaded portion of screw (invalid if thread_len=0)
// Example: Counterbored clearance hole
//   diff()
//     cuboid(20)
//       attach(TOP)
//         screw_hole("1/4-20,.5",head="socket",counterbore=5,anchor=TOP);
// Example: Clearance hole for flathead 
//   diff()
//     cuboid(20)
//       attach(TOP)
//          screw_hole("1/4-20,.5",head="flat",counterbore=0,anchor=TOP);
// Example: Threaded hole, with inward bevel at the base
//   bottom_half()
//     diff()
//       cuboid(20)
//         attach(FRONT)
//           screw_hole("M16,15",anchor=TOP,thread=true,bevel1="reverse");