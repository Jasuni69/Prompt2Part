function mb_connector2d(p1, p2, r, cutoff=INF, influence=1, negative=false, hide_debug=false, d) =
    assert(is_num(cutoff) && cutoff>0, "\ncutoff must be a positive number.")
    assert(is_finite(influence) && influence>0, "\ninfluence must be a positive number.")
    let(
        //dum1 = assert(is_vector(p1,2), "\n2D connector start point p1 must be a 3D coordinate.")
        //    assert(is_vector(p2,3), "\n2D connector end point p2 must be a 3D coordinate.")
        dum1 = assert(p1 != p2, "\nStart and end points p1 and p2 cannot be the same."),
        r = get_radius(r=r,d=d),
        dum2 = assert(is_finite(r) && r>0, "\ninvalid radius or diameter."),
        neg = negative ? -1 : 1,
        dc = p2-p1, // center-to-center distance
        h = norm(dc)/2, // center-to-center length (cylinder height)
        //transform = submatrix(down(h)*rot(from=dc,to=UP)*move(-p1), [0:2], [0:3]),
        transform = submatrix(back(h)*rot(from=dc,to=FWD)*move(-p1), [0:2], [0:3]),
        poly=[neg, move(p1, rot(from=BACK,to=dc,p=hide_debug ? square(0.2,true) : back(h, rect([2*r,2*(r+h)],rounding=0.999*r,$fn=20))))]
   )
   [function (dv)
        let(newdv = transform * [each dv,1])
            _mb_stadium_full(newdv, h, r, cutoff, 1/influence, neg), poly];

 
/// metaball ring or annulus