module metric_bolt(
    headtype="socket",
    size=3,
    l=12,
    shank=0,
    pitch=undef,
    details=false,
    coarse=true,
    phillips=undef,
    torx=undef,
    flange=0,
    anchor="base",
    spin=0,
    orient=UP
) {
    D = headtype != "hex"?
        get_metric_socket_cap_diam(size) :
        get_metric_bolt_head_size(size);
    H = headtype == "socket"?
        get_metric_socket_cap_height(size) :
        get_metric_bolt_head_height(size);
    P = coarse?
        (pitch==undef? get_metric_iso_coarse_thread_pitch(size) : pitch) :
        (pitch==undef? get_metric_iso_fine_thread_pitch(size) : pitch);
    tlen = l - min(l, shank);
    sides = max(12, segs(size/2));
    tcirc = D/cos(30);
    bevtop = (tcirc-D)/2;
    bevbot = P/2;

    headlen = (
        (headtype == "pan" || headtype == "round" || headtype == "button")? H*0.75 :
        (headtype == "countersunk")? (D-size)/2 :
        (headtype == "oval")? ((D-size)/2 + D/2/3) :
        H
    );
    base = l/2 - headlen/2;
    sunklen = (
        (headtype == "oval")? (D-size)/2 :
        headlen-0.001
    );

    anchors = [
        named_anchor("countersunk", [0,0,base+sunklen]),
        named_anchor("base",   [0,0,base]),
        named_anchor("shank",  [0,0,base-shank])
    ];

    //color("silver")
    attachable(anchor,spin,orient, d=size, l=headlen+l, anchors=anchors) {
        up(base) {
            difference() {
                union() {
                    // Head
                    if (headtype == "hex") {
                        difference() {
                            cylinder(d=tcirc, h=H, $fn=6);

                            // Bevel hex nut top
                            if (details) {
                                up(H-bevtop) {
                                    difference() {
                                        cube([tcirc+1, tcirc+1, bevtop+0.5], anchor=BOTTOM);
                                        down(0.01) cylinder(d1=tcirc, d2=tcirc-bevtop*2, h=bevtop+0.02, center=false);
                                    }
                                }
                            }
                        }
                    } else if (headtype == "socket") {
                        sockw = get_metric_socket_cap_socket_size(size);
                        sockd = get_metric_socket_cap_socket_depth(size);
                        difference() {
                            cylinder(d=D, h=H);
                            up(H-sockd) cylinder(h=sockd+0.1, d=sockw/cos(30), $fn=6);
                            if (details) {
                                kcnt = 36;
                                zrot_copies(n=kcnt, r=D/2) up(H/3) cube([PI*D/kcnt/2, PI*D/kcnt/2, H], anchor=BOTTOM);
                            }
                        }
                    } else if (headtype == "pan") {
                        cyl(l=H*0.75, d=D, rounding2=H*0.75/2, anchor=DOWN);
                    } else if (headtype == "round") {
                        top_half(D) zscale(H*0.75/D*2) sphere(d=D);
                    } else if (headtype == "button") {
                        up(H*0.75/3) top_half(D) zscale(H*0.75*2/3/D*2) sphere(d=D);
                        cylinder(d=D, h=H*0.75/3+0.01, center=false);
                    } else if (headtype == "countersunk") {
                        cylinder(h=(D-size)/2, d1=size, d2=D);
                    } else if (headtype == "oval") {
                        up((D-size)/2) top_half(D) zscale(0.333) sphere(d=D);
                        cylinder(h=(D-size)/2, d1=size, d2=D);
                    }

                    // Flange
                    if (flange>0) {
                        up(headtype == "countersunk" || headtype == "oval"? (D-size)/2 : 0) {
                            cylinder(d=D+flange, h=H/8, center=false);
                            up(H/8) cylinder(d1=D+flange, d2=D, h=H/8, center=false);
                        }
                    }

                    // Unthreaded Shank
                    if (tlen < l) {
                        down(l-tlen) cylinder(d=size, h=l-tlen+0.05, center=false, $fn=sides);
                    }

                    // Threads
                    down(l) {
                        difference() {
                            up(tlen/2+0.05) {
                                if (tlen > 0) {
                                    if (P > 0) {
                                        threaded_rod(d=size, l=tlen+0.05, pitch=P, $fn=sides);
                                    } else {
                                        cylinder(d=size, h=tlen+0.05, $fn=sides, center=true);
                                    }
                                }
                            }

                            // Bevel bottom end of threads
                            if (details) {
                                difference() {
                                    down(0.5) cube([size+1, size+1, bevbot+0.5], anchor=BOTTOM);
                                    cylinder(d1=size-bevbot*2, d2=size, h=bevbot+0.01, center=false);
                                }
                            }
                        }
                    }
                }

                // Phillips drive hole
                if (headtype != "socket" && phillips != undef) {
                    down(headtype != "hex"? H/6 : 0) {
                        phillips_mask(size=phillips); //, shaft=D);
                    }
                }

                // Torx drive hole
                if (headtype != "socket" && torx != undef) {
                    up(1) torx_mask(size=torx, l=H+0.1, center=false);
                }
            }
        }
        children();
    }
}


// Module: metric_nut()
// Description:
//   Makes a model of a standard nut for a standard metric screw.
// Arguments:
//   size = standard metric screw size in mm. (Default: 3)
//   hole = include the hole in the nut.  (Default: true)
//   pitch = pitch of threads in the hole.  No threads if not given.
//   flange = radius of flange beyond the head.  Default = 0 (no flange)
//   details = true if model should be rendered with extra details.  (Default: false)
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
//   center = If true, centers the nut at the origin.  If false, sits on top of XY plane.  Overrides `anchor` if given.
// Example: No details, No Hole.  Useful for a mask.
//   metric_nut(size=10, hole=false);
// Example:  Hole, with No Threads
//   metric_nut(size=10, hole=true);
// Example:  Threads
//   metric_nut(size=10, hole=true, pitch=1.5);
// Example:  Details
//   metric_nut(size=10, hole=true, pitch=1.5, details=true);
// Example:  Centered
//   metric_nut(size=10, hole=true, pitch=1.5, details=true, center=true);
// Example:  Flange
//   metric_nut(size=10, hole=true, pitch=1.5, flange=3, details=true);