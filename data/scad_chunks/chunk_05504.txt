module bent_cutout_mask(r, thickness, path, radius, convexity=10)
{
  no_children($children);
  r = get_radius(r1=r, r2=radius);
  dummy1=assert(is_def(r) && r>0,"Radius of the cylinder to bend around must be positive");
  path2 = force_path(path);
  dummy2=assert(is_path(path2,2),"Input path must be a 2D path")
         assert(r-thickness>0, "Thickness too large for radius")
         assert(thickness>0, "Thickness must be positive");
  fixpath = clockwise_polygon(path2);
  curvepoints = arc(d=thickness, angle = [-180,0]);
  profiles = [for(pt=curvepoints) _cyl_hole(r+pt.x,apply(xscale((r+pt.x)/r), offset(fixpath,delta=thickness/2+pt.y,check_valid=false,closed=true)))];
  pathx = column(fixpath,0);
  minangle = (min(pathx)-thickness/2)*360/(2*PI*r);
  maxangle = (max(pathx)+thickness/2)*360/(2*PI*r);
  mindist = (r+thickness/2)/cos((maxangle-minangle)/2);
  dummy3 = assert(maxangle-minangle<180,"Cutout angle span is too large.  Must be smaller than 180.");
  zmean = mean(column(fixpath,1));
  innerzero = repeat([0,0,zmean], len(fixpath));
  outerpt = repeat( [1.5*mindist*cos((maxangle+minangle)/2),1.5*mindist*sin((maxangle+minangle)/2),zmean], len(fixpath));
  default_tag("remove")
    vnf_polyhedron(vnf_vertex_array([innerzero, each profiles, outerpt],col_wrap=true),convexity=convexity);
}



/*

join_prism To Do List:

special handling for planar joins?
   offset method
   cut, radius?
Access to the derivative smoothing parameter?   

*/



// Function&Module: join_prism()
// Synopsis: Join an arbitrary prism to a plane, sphere, cylinder or another arbitrary prism with a fillet.
// SynTags: Geom, VNF
// Topics: Rounding, Offsets
// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()
// Usage: The two main forms with most common options
//   join_prism(polygon, base, length=|height=|l=|h=, fillet=, [base_T=], [scale=], [prism_end_T=], [short=], ...) [ATTACHMENTS];
//   join_prism(polygon, base, aux=, fillet=, [base_T=], [aux_T=], [scale=], [prism_end_T=], [short=], ...) [ATTACHMENTS];
// Usage: As function
//   vnf = join_prism( ... );
// Description:
//   This function creates a smooth fillet between one or both ends of an arbitrary prism and various other shapes: a plane, a sphere, a cylinder,
//   or another arbitrary prism.  The fillet is a continuous curvature rounding with a specified width/height.  This module is general
//   and therefore has a complex interface.  The examples below form a tutorial on how to use `join_prism` that steps
//   through the various options and how they affect the results.  Be sure to check the examples for help understanding how the various options work.
//   .
//   When joining between planes this function produces similar results to {{rounded_prism()}}.  This function works best when the prism
//   cross section is a continuous shape with a high sampling rate and without sharp corners.  If you have sharp corners you should consider
//   giving them a small rounding first.  When the prism cross section has concavities the fillet size is limited by the curvature of those concavities.
//   In contrast, {{rounded_prism()}} works best on a prism that has fewer points and does well with sharp corners, but may encounter problems
//   with a high sampling rate.  
//   .
//   You specify the prism by giving its cross section as a 2D path.  The cross section is always the orthogonal cross
//   section of the prism.  Depending on end conditions, the ends may not be perpendicular to the
//   axis of the prism, but the cross section you give *is* always perpendicular to that cross section.
// Figure(3D,Big,NoScales,VPR=[74.6, 0, 329.7], VPT=[28.5524, 35.3006, 22.522], VPD=325.228): The layout and terminology used by `join_prism`.  The "base object" is centered on the origin.  The "auxiliary object" (if present) is some distance away so there is room for the "joiner prism" to connect the two objects.  The blue line is the axis of the jointer prism.  It is at the origin of the shape you supply for defining that prism.  The "root" point of the joiner prism is the point where the prism axis intersects the base.  The prism end point is where the prism axis intersects the auxiliary object.  If you don't give an auxiliary object then the prism end point is distance `length` along the axis from the root.  
//   aT = right(-10)*back(0)*up(75)*xrot(-35)*zrot(75);
//   br = 17;
//   ar = 15;
//   xcyl(r=br, l=50, circum=true, $fn=64);
//   multmatrix(aT)right(15)xcyl(r=ar,circum=true,l=50,$fn=64);
//   %join_prism(circle(r=10), base = "cyl", base_r=br, aux="cyl", aux_r=ar, aux_T=aT,fillet=3);
//   root = [-2.26667, 0, 17];
//   rback = [15,0,25];
//   endpt =  [-7.55915, 0, 56.6937];
//   endback = [10,0,55];
//   stroke([root,endpt],
//          width=1,endcap_width=3,endcaps="dot",endcap_color="red",color="blue",$fn=16);
//   stroke(move(3*unit(rback-root), [rback,root]), endcap2="arrow2",width=1/2,$fn=16,color="black");
//   down(0)right(4)color("black")move(rback)rot($vpr)text("prism root point",size=4);
//   stroke(move(3*unit(endback-endpt), [endback,endpt]), endcap2="arrow2", width=1/2, $fn=16, color="black");
//   down(2)right(4)color("black")move(endback)rot($vpr)text("prism end point",size=4);
//   right(4)move(-20*[1,1])color("black")rot($vpr)text("base",size=8);
//   up(83)right(-10)move(-20*[1,1])color("black")rot($vpr)text("aux",size=8);
//   aend=[-13,13,30];
//   ast=aend+10*[-1,1,0];
//   stroke([ast,aend],endcap2="arrow2", width=1/2, color="black");
//   left(2)move(ast)rot($vpr)color("black")text("joiner prism",size=5,anchor=RIGHT);
// Continues:
//   You must include a base ("plane", "sphere", "cylinder", "cyl"), or a polygon describing the cross section of a base prism.  If you specify a
//   sphere or cylinder you must give `base_r` or `base_d` to specify the radius or diameter of the base object.  If you choose a cylinder or a polygonal
//   prism then the base object appears aligned with the X axis.  In the case of the planar base, the
//   joining prism has one end of its axis at the origin.  As shown above, the point where the joining prism attaches to its base is the "root" of the prism.
//   If you use some other base shape, the root is adjusted so that it is on the boundary of your shape.  This happens by finding the intersection
//   of the joiner prisms's axis and using that as the root.  By default the prism axis is parallel to the Z axis.  
//   .
//   You may give `base_T`, a rotation operator that is applied to the base.  This is
//   useful to tilt a planar or cylindrical base.  The `base_T` operator must be an origin-centered rotation like yrot(25).  
//   .
//   You may optionally specify an auxiliary shape.  When you do this, the joining prism connects the base to the auxiliary shape,
//   which must be one of "none", "plane", "sphere", "cyl", or "cylinder".  You can also set it to a polygon to create an arbitrary
//   prism for the auxiliary shape.  As is the case for the base, auxiliary cylinders and prisms appear oriented along the X axis.  
//   For a cylinder or sphere you must use `aux_r` or `aux_d` to specify the radius or diameter.
//   The auxiliary shape appears centered on the origin and is likely to be an invalid end location unless you translate it to a position
//   away from the base object.  The `aux_T` operator operates on the auxiliary object, and unlike `base_T` can be a rotation that includes translation
//   operations (or is a non-centered rotation).
//   .
//   When you specify an auxiliary object, the joiner prism axis is initially the line connecting the origin (the base center point) to the auxiliary
//   object center point.  The joiner prism end point is determined analogously to how the root is determined, by intersecting the joiner
//   prism axis with the auxiliary object.  Note that this means that if `aux_T` is a rotation it changes the joiner prism root, because
//   the rotated prism axis intersects the base in a different location.  If you do not give an auxiliary object then you must give
//   the length/height parameter to specify the prism length.  This gives the length of the prism measured from the root to the end point.
//   Note that the joint with a curved base may significantly extend the length of the joiner prism: its total length is often larger than
//   the length you request.  
//   .
//   For the cylinder and spherical objects you may wish to joint a prism to the concave surface.  You can do this by setting a negative
//   radius for the base or auxiliary object.  When `base_r` is negative, and the joiner prism axis is vertical, the prism root is **below** the
//   XY plane.  In this case it is actually possible to use the same object for base and aux and you can get a joiner prism that crosses a cylindrical
//   or spherical hole.  You can also attach to the inside of a prism object by setting the corresponding radius to a negative value.  Only the sign
//   matters in this case.  
//   .
//   When placing prisms inside a hole, an ambiguity can arise about how to identify the root and end of the joiner prism.  The prism axis has
//   two intersections with a cylinder and both are potentially valid roots.  When the auxiliary object is entirely inside the hole, or the auxiliary
//   object is a sphere or cylinder with negative radius that intersections the base, both prism directions produce a valid
//   joiner prism that meets the hole's concave surface, so two valid interpretations exist.  By default, the longer prism is returned.
//   You can select the shorter prism by setting `short=true`.  If you specify `short=true` when the base has a negative radius, but only one valid
//   prism exists, you get an error that doesn't clearly identify that a bogus `short=true` was the real cause.  
//   .
//   You can also alter your prism by using the `prism_end_T` operator which applies to the end point of the prism.  It does not effect
//   the root  of the prism.  The `prism_end_T` operator is applied in a coordinate system where the root of the
//   prism is the origin, so if you set it to a rotation, the prism base remains rooted at the same location and the prism rotates
//   in the specified fashion.  Applying `prism_end_T` likely results in the prism axis being different and the new end point not being on the auxiliary object, or the length of the prism may change.  Therefore, the end point is recalculated
//   to achieve the specified length (if aux is "none") or to contact the auxiliary object, if you have specified one.  This means, for example,
//   that setting `prism_end_T` to a scale operation doesn't change the result because it doesn't alter the prism axis.
//   .
//   A different way to specify the prism position is using the `start` and `end` parameters, which specify the axis of the prism's centerline.
//   You cannot combine `prism_end_T` with either `start` or `end`.  if you give only `start` then the prism's anchor point on the base
//   will be shifted but its direction will remain the same.  If you give only `end` then the prism's anchor point on the base remains
//   fixed (as computed based on the center-to-center line) and only the point on the auxiliary object moves.  
//   .
//   The size of the fillets is determined by the fillet, `fillet_base`, and `fillet_aux` parameters.  The fillet parameter controls both
//   ends of the prism, or you can set the ends independently.  The fillets must be nonnegative except when the prism joints a plane.
//   In this case a negative fillet gives a roundover.  In the case of no auxiliary object you can use `round_end` to round over the planar
//   far end of the joiner prism.  By default, the fillet is constructed using a method that produces a fillet with a uniform height along
//   the joiner prism.  This can be limiting when connectijng to objects with high curvature, so you can turn it off using the `uniform` option.
//   See the figures below for an explanation of the uniform and non-uniform filleting methods.  
//   .
//   The overlap is a potentially tricky parameter.  It specifies how much extra material to
//   create underneath the filleted prism so it overlaps the object that it joins to, ensuring valid unions.
//   For joins to convex objects you can choose a small value, but when joining to a concave object the overlap may need to be
//   large to ensure that the base of the joiner prism is well-behaved.  In such cases you may need to use an intersection
//   remove excess base.
//   .
//   When connecting to a base or auxiliary object that is a prism, the `smooth_normals` parameter controls how normals on that prism are
//   computed.  If `smooth_normals=true` (the default) then the normals are interpolated across the faces to create a more continuously varying normal.
//   This generally produces good results if the prism is a continous shape that is uniformly and finely sampled.  But if the shape has
//   large faces it can produce inferior or even incorrect results.  For example, {{prism_connector()}} makes connections to edges of objects
//   and must set `smooth_normals=false` to get correct results in this situation, or the constructed prism ends up hidden inside the object in
//   joins to.  If you create a prism that appears to suffer from this problem an informational (nonfatal) message will be displayed.
//   Note that the messages appears once for every problematic point in your joining profile.  
// Figure(2D,Med,NoAxes): Uniform fillet method.  This image shows how we construct a uniform fillet.  The pictures shows the cross section that is perpendicular to the prism.  The blue curve represents the base object surface.  The vertical line is the side of the prism.  To construct a fillet we travel along the surface of the base, following the curve, until we have moved the fillet length, `a`.  This defines the point `u`.  We then construct a tangent line to the base and find its intersection, `v`, with the prism.  Note that if the base is steeply curved, this tangent may fail to intersect, and the algorithm fails with an error because `v` does not exist.  Finally we locate `w` to be distance `a` above the point where the prism intersects the base object.  The fillet is defined by the `[u,v,w]` triple and is shown in red.  Note that with this method, the fillet is always height `a` above the base, so it makes a uniform curve parallel to the base object.  However, when the base curvature is more extreme, point `v` may end up above point `w`, resulting in an invalid configuration.  It also happens that point `v`, while below `w`, is close to `w`, so the resulting fillet has an abrupt angle near `w` instead of a smooth transition.  
//   R=60;
//   base = R*[cos(70),sin(70)];
//   end = R*[cos(45),sin(45)];
//   tang = [-sin(45),cos(45)];
//   isect = line_intersection([base,back(1,base)], [end,end+tang]);
//   toppt = base+[0,2*PI*R*25/360];
//   bez = _smooth_bez_fill([toppt, isect,end], 0.8);
//   color("red")
//     stroke(bezier_curve(bez,30,endpoint=true), width=.5);
//   color("blue"){
//      stroke(arc(n=50,angle=[35,80], r=R), width=1);
//      stroke([base, back(40,base)]);
//      move(R*[cos(35),sin(35)])text("Base", size=5,anchor=BACK);
//      back(1)move(base+[0,40]) text("Prism", size=5, anchor=FWD);
//   }
//   color([.3,1,.3]){
//     right(2)move(toppt)text("w",size=5);
//     right(2)move(end)text("u",size=5);
//     stroke([isect+[1,1/4], isect+[16,4]], width=.5, endcap1="arrow2");
//     move([16.5,3])move(isect)text("v",size=5);
//     stroke([end,isect],dots=true);
//     stroke([isect,toppt], dots=true);
//   }
//   color("black")  {
//      stroke(arc(n=50, angle=[45,70], r=R-3), color="black", width=.6, endcaps="arrow2");
//       move( (R-10)*[cos(57.5),sin(57.5)]) text("a",size=5);
//      left(3)move( base+[0,PI*R*25/360]) text("a", size=5,anchor=RIGHT);
//      left(2)stroke( [base, toppt],endcaps="arrow2",width=.6);
//   }
// Figure(2D,Med,NoAxes): Non-Uniform fillet method.  This method differs because point `w` is found by moving the fillet distance `a` starting at the intersection point `v` instead of at the base surface.  This means that the `[u,v,w]` triple is always in the correct order to produce a valid fillet.  However, the height of the fillet above the surface varies.  When the base concave, point `v` is below the surface of the base, which in more extreme cases can produce a fillet that goes below the base surface.  The uniform method is less likely to produce this kind of result.  When the base surface is a plane, the uniform and non-uniform methods are identical.
//   R=60;
//   base = R*[cos(70),sin(70)];
//   end = R*[cos(45),sin(45)];
//   tang = [-sin(45),cos(45)];
//   isect = line_intersection([base,back(1,base)], [end,end+tang]);
//   toppt = isect+[0,2*PI*R*25/360];
//   bez = _smooth_bez_fill([toppt, isect,end], 0.8);
//   color("red")stroke(bezier_curve(bez,30,endpoint=true), width=.5);
//   color("blue"){
//      stroke(arc(n=50,angle=[35,80], r=R), width=1);
//      stroke([base, back(40,base)]);
//      move(R*[cos(35),sin(35)])text("Base", size=5,anchor=BACK);
//      back(1)move(base+[0,40]) text("Prism", size=5, anchor=FWD);
//   }
//   color([.3,1,.3]){
//     right(2)move(toppt)text("w",size=5);
//     right(2)move(end)text("u",size=5);
//     stroke([isect+[1,1/4], isect+[16,4]], width=.5, endcap1="arrow2");
//     move([16.5,3])move(isect)text("v",size=5);
//     stroke([end,isect],dots=true);
//     stroke([isect,toppt], dots=true);
//   }
//   color("black")  {
//      stroke(arc(n=50, angle=[45,70], r=R-3), width=.6, endcaps="arrow2");
//      move( (R-10)*[cos(57.5),sin(57.5)]) text("a",size=5);
//      left(3)move( (isect+toppt)/2) text("a", size=5,anchor=RIGHT);
//      left(2)stroke( [isect, toppt],endcaps="arrow2",width=.6);
//   }
// Arguments:
//   polygon = polygon giving prism cross section
//   base = string specifying base object to join to ("plane","cyl","cylinder", "sphere") or a point list to use an arbitrary prism as the base.
//   ---
//   length / height / l / h = length/height of prism if aux=="none"
//   scale = scale factor for prism far end.  Default: 1
//   prism_end_T = root-centered arbitrary transform to apply to the prism's far point.  Default: IDENT
//   short = flip prism direction for concave sphere or cylinder base, when there are two valid prisms.  Default: false
//   base_T = origin-centered rotation operator to apply to the base
//   base_r / base_d = base radius or diameter if you picked sphere or cylinder
//   aux = string specifying auxilary object to connect to ("none", "plane", "cyl", "cylinder", or "sphere") or a point list to use an arbitrary prism.  Default: "none"
//   aux_T = rotation operator that may include translation when aux is not "none" to apply to aux
//   aux_r / aux_d = radius or diameter of auxiliary object if you picked sphere or cylinder
//   start = starting endpoint for the axis of the prism center
//   end = ending endpoint for the axis of the prism center
//   n = number of segments in the fillet at both ends.  Default: 15
//   base_n = number of segments to use in fillet at the base
//   aux_n = number of segments to use in fillet at the aux object
//   end_n = number of segments to use in roundover at the end of prism with no aux object
//   fillet = fillet for both ends of the prism (if applicable)  Must be nonnegative except for joiner prisms with planar ends
//   base_fillet = fillet for base end of prism 
//   aux_fillet = fillet for joint with aux object
//   end_round = roundover of end of prism with no aux object 
//   overlap = amount of overlap of prism fillet into objects at both ends.  Default: 1 for normal fillets, 0 for negative fillets and roundovers
//   base_overlap = amount of overlap of prism fillet into the base object
//   aux_overlap = amount of overlap of the prism fillet into aux object
//   k = fillet curvature parameter for both ends of prism
//   base_k = fillet curvature parameter for base end of prism
//   end_k / aux_k = fillet curvature parameter for end of prism where the aux object is
//   uniform = set to false to get non-uniform filleting at both ends (see Figures 2-3).  Default: true
//   base_uniform = set to false to get non-uniform filleting at the base
//   aux_uniform = set to false to get non-uniform filleting at the auxiliary object
//   smooth_normals = if true then smooth normals to the base and auxiliary objects when those objects are prisms.  If false do not smooth the normals. No effect for objects that are not prisms.  Default: true
//   base_smooth_normals = set to true or false to control smoothing of normals on the base prism object only
//   aux_smooth_normals = set to true or false to control smoothing of normals on the auxiliary prism object only
//   debug = set to true to allow return of various cases where self-intersection was detected
//   anchor = Translate so anchor point is at the origin.  (module only) Default: "origin"
//   spin = Rotate this many degrees around Z axis after anchor.  (module only) Default: 0
//   orient = Vector to rotate top toward after spin  (module only)
//   atype = Select "hull" or "intersect" anchor types.  (module only) Default: "hull"
//   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  (module only) Default: "centroid"
// Named Anchors:
//   "root" = Root point of the joiner prism, pointing out in the direction of the prism axis
//   "end" = End point of the joiner prism, pointing out in the direction of the prism axis
// Example(3D,NoScales): Here is the simplest case, a circular prism with a specified length standing vertically on a plane.  
//   join_prism(circle(r=15,$fn=60),base="plane",
//              length=18, fillet=3, n=12);
//   cube([50,50,5],anchor=TOP);
// Example(3D,NoScales): Here we substitute an abitrary prism. 
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="plane",length=18, fillet=3, n=12);
//   cube([50,50,5],anchor=TOP);
// Example(3D,NoScales): Here we apply a rotation of the prism, using prism_end_T, which rotates around the prism root.  Note that aux_T rotates around the origin, which is the same when the prism is joined to a plane.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="plane",length=18, fillet=3,
//              n=12, prism_end_T=yrot(25));
//   cube([50,50,5],anchor=TOP);
// Example(3D,NoScales): We can use `end_round` to get a roundover
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="plane",length=18, fillet=3,
//              n=12, prism_end_T=yrot(25), end_round=4);
//   cube([50,50,5],anchor=TOP);
// Example(3D,NoScales): We can tilt the base plane by applying a base rotation.  Note that because we did not tilt the prism, it still points upward.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="plane",length=18, fillet=3,
//              n=12, base_T=yrot(25));
//   yrot(25)cube([50,50,5],anchor=TOP);
// Example(3D,NoScales): Next consider attaching the prism to a sphere.  You must use a circumscribed sphere to avoid a lip or gap between the sphere and prism.  Note that the prism is attached to the sphere's boundary above the origin and projects by the specified length away from the attachment point.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="sphere",base_r=30, length=18,
//              fillet=3, n=12);
//   spheroid(r=30,circum=true,$fn=64);
// Example(3D,NoScales): Rotating using the prism_end_T option rotates around the attachment point.  Note that if you rotate too far, some points of the prism miss the sphere, which is an error.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="sphere",base_r=30, length=18,
//              fillet=3, n=12, prism_end_T=yrot(-15));
//   spheroid(r=30,circum=true,$fn=64);
// Example(3D,NoScales): Rotating using the aux_T option rotates around the origin.  You could get the same result in this case by rotating the whole model.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="sphere",base_r=30, length=18,
//              fillet=3, n=12, aux_T=yrot(-45));
//   spheroid(r=30,circum=true,$fn=64);
// Example(3D,NoScales): The origin in the prism cross section always aligns with the origin of the object you attach to.  If you want to attach off center, then shift your prism cross section.  If you shift too far so that parts of the prism miss the base object then you get an error.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(right(10,flower),base="sphere",base_r=30,
//              length=18, fillet=3, n=12);
//   spheroid(r=30,circum=true,$fn=64);
// Example(3D,NoScales): The third available base shape is the cylinder.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="cylinder",base_r=30,
//              length=18, fillet=4, n=12); 
//   xcyl(r=30,l=75,circum=true,$fn=64);
// Example(3D,NoScales): You can rotate the cylinder the same way we rotated the plane.
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="cylinder",base_r=30, length=18,
//              fillet=4, n=12, base_T=zrot(33)); 
//   zrot(33)xcyl(r=30,l=75,circum=true,$fn=64);
// Example(3D,NoScales): And you can rotate the prism around its attachment point with prism_end_T
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="cylinder",base_r=30, length=18,
//              fillet=4, n=12, prism_end_T=yrot(22));
//   xcyl(r=30,l=75,circum=true,$fn=64);
// Example(3D,NoScales): Or you can rotate the prism around the origin with aux_T
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="cylinder",base_r=30, length=18,
//              fillet=4, n=12, aux_T=xrot(22));
//   xcyl(r=30,l=75,circum=true,$fn=64);
// Example(3D,NoScales): Here's a prism where the scale changes
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="cylinder",base_r=30, length=18,
//              fillet=4, n=12,scale=.5);
//   xcyl(r=30,l=75,circum=true,$fn=64);
// Example(3D,NoScales,VPD=190,VPR=[61.3,0,69.1],VPT=[41.8956,-9.49649,4.896]): Giving a negative radius attaches to the inside of a sphere or cylinder.  Note you want the inscribed cylinder for the inner wall.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="cylinder",base_r=-30, length=18,
//              fillet=4, n=12);
//   bottom_half(z=-10)
//     tube(ir=30,wall=3,l=74,$fn=64,orient=RIGHT,anchor=CENTER);
// Example(3D,NoScales,VPD=140,VPR=[72.5,0,73.3],VPT=[40.961,-19.8319,-3.03302]): A hidden problem lurks with concave attachments.  The bottom of the prism does not follow the curvature of the base.  Here you can see a gap.  In some cases you can create a self-intersection in the prism.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   left_half(){
//     join_prism(flower,base="cylinder",base_r=-30, length=18,
//                fillet=4, n=12);
//     bottom_half(z=-10)
//       tube(ir=30,wall=3,l=74,$fn=64,orient=RIGHT,anchor=CENTER);
//   }
// Example(3D,NoScales,VPD=140,VPR=[72.5,0,73.3],VPT=[40.961,-19.8319,-3.03302]): The solution to both problems is to increase the overlap parameter, but you may then have excess base that must be differenced or intersected away.  In this case, an overlap of 2 is sufficient to eliminate the hole.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   left_half(){
//     join_prism(flower,base="cylinder",base_r=-30, length=18,
//                fillet=4, n=12, overlap=2);     
//     bottom_half(z=-10)
//       tube(ir=30,wall=3,l=74,$fn=64,orient=RIGHT,anchor=CENTER);
//   }
// Example(3D,NoScales,VPD=126,VPR=[76.7,0,111.1],VPT=[6.99093,2.52831,-14.8461]): Here is an example with a spherical base.  This overlap is near the minimum required to eliminate the gap, but it creates a large excess structure around the base of the prism.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   left_half(){
//     join_prism(flower,base="sphere",base_r=-30, length=18,
//                fillet=4, n=12, overlap=7);
//     bottom_half(z=-10) difference(){
//       sphere(r=33,$fn=16);
//       sphere(r=30,$fn=64);
//     }
//   }
// Example(3D,NoScales,VPD=126,VPR=[55,0,25],VPT=[1.23541,-1.80334,-16.9789]): Here is the previous example with the excess structure differenced away. 
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   intersection(){
//     union(){
//       join_prism(flower,base="sphere",base_r=-30, length=18, 
//                  fillet=4, n=12, overlap=7);
//       difference(){
//         down(18)cuboid([68,68,30],anchor=TOP);
//         sphere(r=30,$fn=64);
//       }
//     }
//     sphere(r=33,$fn=16);
//   }
// Example(3D,NoScales,VPD=126,VPR=[55,0,25],VPT=[1.23541,-1.80334,-16.9789]): As before, rotating with aux_T rotates around the origin. 
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   intersection(){
//     union(){
//       join_prism(flower,base="sphere",base_r=-30, length=18,
//                  fillet=4, n=12, overlap=7, aux_T=yrot(13));
//       difference(){
//         down(18)cuboid([68,68,30],anchor=TOP);
//         sphere(r=30,$fn=64);
//       }
//     }
//     sphere(r=33,$fn=16);
//   }
// Example(3D,NoScales,VPD=102.06,VPR=[55,0,25],VPT=[3.96744,-2.80884,-19.9293]): Rotating with prism_end_T rotates around the attachment point.  We shrank the prism to allow a significant rotation.
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   intersection(){
//     union(){
//       join_prism(scale(.5,flower),base="sphere",base_r=-30,
//                  length=18, fillet=2, n=12, overlap=7,
//                  prism_end_T=yrot(25));
//       difference(){
//         down(23)cuboid([68,68,30],anchor=TOP);
//         sphere(r=30,$fn=64);
//       }
//     }
//     sphere(r=33,$fn=16);
//   }
// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): You can create a prism that crosses the inside of a cylinder or sphere by giving the same negative radius twice and leaving both objects with the same center, as shown here.  
//   left_half(x=7){
//     join_prism(circle(r=15),base="cylinder",base_r=-30, n=12,
//                aux="cylinder", aux_r=-30, fillet=8, overlap=3);
//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);     
//   }
// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): Here's a similar example with a plane for the auxiliary object.  Note that we observe the 1 unit overlap on the top surface.  
//   left_half(x=7){
//     join_prism(circle(r=15),base="cylinder",base_r=-30,
//                aux="plane", fillet=8, n=12, overlap=3);
//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);     
//   }
// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): We have tweaked the previous example just slightly by lowering the height of the plane.  The result is a bit of a surprise:  the prism flips upside down!  This happens because there is an ambiguity in creating a prism between a plane and the inside of the cylinder.  By default, this ambiguity is resolved by choosing the longer prism.  
//   left_half(x=7){
//     join_prism(circle(r=15),base="cylinder",base_r=-30, n=12,
//                aux="plane", aux_T=down(5), fillet=8, overlap=3);
//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);     
//   }
// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): Adding `short=true` resolves the ambiguity of which prism to construct in the other way, by choosing the shorter option.  
//   left_half(x=7){
//     join_prism(circle(r=15),base="cylinder",base_r=-30,
//                aux="plane", aux_T=down(5), fillet=8,
//                n=12, overlap=3, short=true);
//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);
//   }
// Example(3D,NoScales,VPR=[85.1,0,107.4],VPT=[8.36329,13.0211,9.98397],VPD=237.091): The problem does not arise in this case because the auxiliary object only allows one possible way to make the connection. 
//   left_half(x=7){
//     join_prism(circle(r=15),base="cylinder",base_r=-30,
//                aux="cylinder", aux_r=30, aux_T=up(20),
//                fillet=8, n=12, overlap=3);
//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);
//     up(20)xcyl(r=30,l=74,$fn=64);
//   }
// Example(3D,NoScales,VPT=[-1.23129,-3.61202,-0.249883],VPR=[87.9,0,295.7],VPD=213.382): When the aux cylinder is inside the base cylinder we can select the two options, shown here as red for the default and blue for the `short=true` case. 
//   color("red")
//     join_prism(circle(r=5),base="cylinder",base_r=-30, 
//                aux="cyl",aux_r=10, aux_T=up(12), fillet=4,
//                 n=12, overlap=3, short=false);
//   color("blue")
//     join_prism(circle(r=5),base="cylinder",base_r=-30, 
//                aux="cyl",aux_r=10, aux_T=up(12), fillet=4,
//                n=12, overlap=3, short=true);
//   tube(ir=30,wall=5,$fn=64,l=18,orient=RIGHT,anchor=CENTER);
//   up(12)xcyl(r=10, circum=true, l=18);
// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[4.34503,1.48579,-2.32228],VPD=237.091): The same thing is true when you use a negative radius for the aux cylinder. This is the default long case.  
//   join_prism(circle(r=5,$fn=64),base="cylinder",base_r=-30, 
//              aux="cyl",aux_r=-10, aux_T=up(12), fillet=4,
//              n=12, overlap=3, short=false);
//   tube(ir=30,wall=5,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
//   up(12) top_half()
//      tube(ir=10,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[4.34503,1.48579,-2.32228],VPD=237.091): And here is the short case:
//   join_prism(circle(r=5,$fn=64),base="cylinder",base_r=-30, 
//              aux="cyl",aux_r=-10, aux_T=up(12), fillet=4,
//              n=12, overlap=3, short=true);
//   tube(ir=30,l=24,wall=5,$fn=64,orient=RIGHT,anchor=CENTER);
//   up(12) bottom_half()
//     tube(ir=10,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[0.138465,6.78002,24.2731],VPD=325.228): Another example where the cylinders overlap, with the long case here:
//   auxT=up(40);
//   join_prism(circle(r=5,$fn=64),base="cylinder",base_r=-30, 
//              aux="cyl",aux_r=-40, aux_T=auxT, fillet=4,
//              n=12, overlap=3, short=false);
//   tube(ir=30,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
//   multmatrix(auxT)
//     tube(ir=40,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[0.138465,6.78002,24.2731],VPD=325.228): And the short case:
//   auxT=up(40);
//   join_prism(circle(r=5,$fn=64),base="cylinder",base_r=-30, 
//              aux="cyl",aux_r=-40, aux_T=auxT, fillet=4,
//              n=12, overlap=3, short=true);
//   tube(ir=30,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
//   multmatrix(auxT)
//     tube(ir=40,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);
// Example(3D,NoScales): Many of the preceeding examples feature a prism with a concave shape cross section.  Concave regions can limit the amount of rounding that is possible.  This occurs because the algorithm is not able to handle a fillet that intersects itself.  Fillets on a convex prism always grow larger as they move away from the prism, so they cannot self intersect.  This means that you can make the fillet as big as can fit on the base shape.  The fillet fails to fit if the tangent plane to the base at the fillet distance from the prism fails to intersect the prism.  Here is an extreme example, almost the largest possible fillet to the convex elliptical convex prism.  
//   ellipse = ellipse([17,10],$fn=164);  
//   join_prism(ellipse,base="sphere",base_r=30, length=18,
//              fillet=18, n=25, overlap=1);
//   spheroid(r=30,circum=true, $fn=96);
// Example(3D,NoScales): This example shows a failed rounding attempt where the result is self-intersecting.  Using the `debug=true` option makes it possible to view the result to understand what went wrong.  Note that the concave corners have a crease where the fillet crosses itself.  The error message advises you to decrease the size of the fillet.  You can also fix the problem by making your concave curves shallower.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+2.5*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="cylinder",base_r=30, length=18,
//              fillet=6, n=12, debug=true); 
// Example(3D,NoScales): Your prism needs to be finely sampled enough to follow the contour of the base you are attaching it to.  If it is not, you get a result like this.  The fillet joints the prism smoothly, but makes a poor transition to the sphere. 
//   sq = rect(15);
//   join_prism(sq, base="sphere", base_r=25,
//              length=18, fillet=4, n=12);
//   spheroid(r=25, circum=true, $fn=96);
// Example(3D,NoScales): To fix the problem, you must subdivide the polygon that defines the prism.  But note that the join_prism method works poorly at sharp corners.
//   sq = subdivide_path(rect(15),n=64);
//   join_prism(sq, base="sphere", base_r=25,
//              length=18, fillet=4, n=12);
//   spheroid(r=25, circum=true,$fn=96);
// Example(3D,NoScales): In the previous example, a small rounding of the prism corners produces a nicer result.
//   sq = subdivide_path(
//          round_corners(rect(15),cut=.5,$fn=32),
//          n=128);
//   join_prism(sq, base="sphere", base_r=25,
//              length=18, fillet=4, n=12);
//   spheroid(r=25, circum=true,$fn=96);
// Example(3D,NoScales): The final option for specifying the base is to use an arbitrary prism, specified by a polygon.  Note that the base prism is oriented to the RIGHT, so the attached prism remains Z oriented.  
//   ellipse = ellipse([17,10],$fn=164);  
//   join_prism(zrot(90,ellipse), base=2*ellipse, length=19,
//              fillet=4, n=12);
//   linear_sweep(2*ellipse,height=60, center=true, orient=RIGHT);
// Example(3D,NoScales): As usual, you can rotate around the attachment point using prism_end_T. 
//   ellipse = ellipse([17,10],$fn=164);  
//   join_prism(zrot(90,ellipse), base=2*ellipse, length=19,
//              fillet=4, n=12, prism_end_T=yrot(22));
//   linear_sweep(2*ellipse,height=60, center=true, orient=RIGHT);
// Example(3D,NoScales): And you can rotate around the origin with aux_T.
//   ellipse = ellipse([17,10],$fn=164);  
//   join_prism(zrot(90,ellipse), base=2*ellipse, length=19,
//              fillet=4, n=12, aux_T=yrot(22));
//   linear_sweep(2*ellipse,height=60, center=true, orient=RIGHT);
// Example(3D,NoScales): The base prism can be a more complicated shape.
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base=1.4*flower, fillet=3,
//              n=15, length=20);
//   linear_sweep(1.4*flower,height=60,center=true,
//                convexity=10,orient=RIGHT);
// Example(3D,NoScales): Here's an example with both prism_end_T and aux_T 
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base=1.4*flower, length=20,
//              prism_end_T=yrot(20),aux_T=xrot(10),
//              fillet=3, n=25);
//   linear_sweep(1.4*flower,height=60,center=true,
//                convexity=10,orient=RIGHT);
// Example(3D,NoScales): The same example as above with `smooth_normals=false` produces a banding pattern in the fillet.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base=1.4*flower, length=20,
//              prism_end_T=yrot(20),aux_T=xrot(10),
//              fillet=3, n=25,smooth_normals=false);
//   linear_sweep(1.4*flower,height=60,center=true,
//                convexity=10,orient=RIGHT);
// Example(3D,NoScales,VPR=[78,0,42],VPT=[12.45,-12.45,10.4],VPD=130): Instead of terminating your prism in a flat face perpendicular to its axis you can attach it to a second object.  The simplest case is to connect to planar attachments.  When connecting to a second object you must position and orient the second object using aux_T, which is now allowed to be a rotation and translation operator.  The `length` parameter is no longer allowed.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="plane", fillet=4, n=12,
//              aux="plane", aux_T=up(12));
//   %up(12)cuboid([40,40,4],anchor=BOT); 
//   cuboid([40,40,4],anchor=TOP);
// Example(3D,NoScales,VPR=[78,0,42],VPT=[12.45,-12.45,10.4],VPD=130): Here's an example where the second object is rotated.  The prism goes from the origin to the origin point of the object.  In this case because the rotation is applied first, the prism is vertical.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = up(12)*xrot(-22);
//   join_prism(flower,base="plane",fillet=2.75, n=12,
//              aux="plane", aux_T=aux_T); 
//   multmatrix(aux_T)cuboid([42,42,4],anchor=BOT);
//   cuboid([40,40,4],anchor=TOP);
// Example(3D,NoScales,VPR=[78,0,42],VPT=[12.45,-12.45,10.4],VPD=130): In this example, the aux_T transform moves the centerpoint (origin) of the aux object, and the resulting prism connects centerpoints, so it is no longer vertical. 
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = xrot(-22)*up(12);
//   join_prism(flower,base="plane",fillet=2.75, n=12,
//              aux="plane", aux_T=aux_T);
//   multmatrix(aux_T)cuboid([42,42,4],anchor=BOT);
//   cuboid([43,43,4],anchor=TOP);
// Example(3D,NoScales,VPR=[78,0,42],VPT=[9.95,-9.98,13.0],VPD=142]): You can combine with base_T
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = xrot(-22)*up(22);
//   base_T = xrot(5)*yrot(-12);
//   join_prism(flower,base="plane",base_T=base_T, 
//              aux="plane",aux_T=aux_T, fillet=4, n=12);
//   multmatrix(aux_T)cuboid([42,42,4],anchor=BOT);
//   multmatrix(base_T)cuboid([45,45,4],anchor=TOP);
// Example(3D,NoScales,VPR=[76.6,0,29.4],VPT=[11.4009,-8.43978,16.1934],VPD=157.778): Using prism_end_T shifts the prism's end without tilting the plane, so the prism ends are not perpendicular to the prism axis.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   join_prism(flower,base="plane", prism_end_T=right(14),
//              aux="plane",aux_T=up(24), fillet=4, n=12);
//   right(7){
//     %up(24)cuboid([65,42,4],anchor=BOT);
//     cuboid([65,42,4],anchor=TOP);
//   }
// Example(3D,NoAxes,NoScales,VPR=[101.9, 0, 205.6], VPT=[5.62846, -5.13283, 12.0751], VPD=102.06): Negative fillets give roundovers and are pemitted only for joints to planes.  Note that overlap defaults to zero for negative fillets.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = xrot(-22)*up(22);
//   base_T = xrot(5)*yrot(-12);
//   join_prism(flower,base="plane",base_T=base_T,
//              aux="plane", aux_T=aux_T, fillet=-4,n=12);
// Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): It works the same way with the other shapes, but make sure you move the shapes far enough apart that there is room for a prism.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = up(85);
//   base_T = xrot(5)*yrot(-12);
//   join_prism(flower,base="cylinder",base_r=25, fillet=4, n=12,
//              aux="sphere",aux_r=35,base_T=base_T, aux_T=aux_T);
//   multmatrix(aux_T)spheroid(35,circum=true);
//   multmatrix(base_T)xcyl(l=75,r=25,circum=true);
// Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): Here we translate the sphere to the right and the prism goes with it
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = right(40)*up(85);
//   join_prism(flower,base="cylinder",base_r=25, n=12,
//              aux="sphere",aux_r=35, aux_T=aux_T, fillet=4);
//   multmatrix(aux_T)spheroid(35,circum=true);
//   xcyl(l=75,r=25,circum=true);
// Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): This is the previous example with the prism_end_T transformation used to shift the far end of the prism away from the sphere center.  Note that prism_end_T can be any transformation, but it just acts on the location of the prism endpoint to shift the direction the prism points.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = right(40)*up(85);
//   join_prism(flower,base="cylinder",base_r=25,
//              prism_end_T=left(4), fillet=3, n=12, 
//              aux="sphere",aux_r=35, aux_T=aux_T); 
//   multmatrix(aux_T)spheroid(35,circum=true);
//   xcyl(l=75,r=25,circum=true);
// Example(3D,NoScales,VPR=[96.9,0,157.5],VPT=[-7.77616,-2.272,37.9424],VPD=366.527): Here the base is a cylinder but the auxilary object is a generic prism, and the joiner prism has a scale factor.  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T = up(85)*zrot(-75);
//   ellipse = ellipse([17,10],$fn=164);  
//   join_prism(flower,base="cylinder",base_r=25,
//              fillet=4, n=12,
//              aux=ellipse, aux_T=aux_T,scale=.5);
//   multmatrix(aux_T)
//     linear_sweep(ellipse,orient=RIGHT,height=75,center=true);
//   xcyl(l=75,r=25,circum=true,$fn=100);
// Example(3D,NoAxes,VPT=[10.0389,1.71153,26.4635],VPR=[89.3,0,39],VPD=237.091): Base and aux are both a general prism in this case.
//   ellipse = ellipse([10,17]/2,$fn=96);  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T=up(50);   
//   join_prism(ellipse,base=flower,aux_T=aux_T,aux=flower,
//              fillet=3, n=12, prism_end_T=right(9));
//   multmatrix(aux_T)
//     linear_sweep(flower,height=60,center=true,orient=RIGHT);
//   linear_sweep(flower,height=60,center=true,orient=RIGHT);
// Example(3D,NoAxes,VPT=[8.57543,0.531762,26.8046],VPR=[89.3,0,39],VPD=172.84): Shifting the joiner prism forward brings it close to a steeply curved edge of the auxiliary prism at the top.  Note that a funny looking bump with a sharp corner has appeared in the fillet.  This bump/corner is a result of the uniform filleting method running out of space.  If we move the joiner prism farther forward, the algorithm fails completely.  
//   ellipse = ellipse([10,17]/2,$fn=96);  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T=up(50);   
//   join_prism(ellipse,base=flower,aux_T=aux_T,aux=flower,
//              fillet=3, n=12, prism_end_T=fwd(1.6));
//   multmatrix(aux_T)
//     linear_sweep(flower,height=60,center=true,orient=RIGHT);
//   linear_sweep(flower,height=60,center=true,orient=RIGHT);
// Example(3D,NoAxes,VPT=[8.57543,0.531762,26.8046],VPR=[89.3,0,39],VPD=172.84): This is the same example as above but with uniform turned off.  Note how the line the fillet makes on the joiner prism is not uniform, but the overall curved shape is more pleasing than the previous result, and we can bring the joiner prism a little farther forward and still construct a model. 
//   ellipse = ellipse([10,17]/2,$fn=96);  
//   flower = [for(theta=lerpn(0,360,180,endpoint=false))
//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];
//   aux_T=up(50);   
//   join_prism(ellipse,base=flower,aux_T=aux_T,aux=flower,
//              fillet=3, n=12, prism_end_T=fwd(1.7),
//              uniform=false);
//   multmatrix(aux_T)
//     linear_sweep(flower,height=60,center=true,orient=RIGHT);
//   linear_sweep(flower,height=60,center=true,orient=RIGHT);
// Example(3D,NoScales): By setting the base and auxiliary to the same thing you can create a hole cutting mask with rounded ends.  
//   difference(){
//     spheroid(r=30,circum=true);    
//     join_prism(circle(r=15),base="sphere",base_r=-30, n=15,
//                aux="sphere",aux_r=-30,fillet=8, overlap=17);
//   }
// Example(3D,VPT=[0.59633,-3.01826,-3.89606],VPR=[129.2,0,26.4],VPD=192.044,NoScales): Here we have rotated the auxiliary sphere, resulting in a hole that is off-center through the sphere.  Because we rotate the auxiliary object, both ends of the prism have moved.  Note that setting k to a large value better matches the bezier curve to the curvature of the sphere, resulting in a better result.  
//   difference(){
//     spheroid(r=30,circum=true);    
//     join_prism(circle(r=15),base="sphere",base_r=-30, n=15,
//                aux="sphere",aux_T=xrot(30), aux_r=-30,fillet=8, overlap=17, k=0.9);
//   }
// Example(3D,VPT=[-12.5956,-5.1125,-0.322237],VPR=[82.3,0,116.7],VPD=213.382,NoScales): Here we adjust just the auxiliary end, which is at the bottom.  We rotate it by 45 deg, but this rotation would normally be relative to the other prism end, so we add a centerpoint based on the radius so that the rotation is relative to the sphere center instead.
//   difference(){
//     spheroid(r=30,circum=true);    
//     join_prism(circle(r=15),base="sphere",base_r=-30, n=15,
//                aux="sphere",prism_end_T=xrot(45,cp=[0,0,-30]), aux_r=-30,fillet=8, overlap=17, k=0.9);               
//   }
// Example(3D,NoScales,VPT=[12.3373,11.6037,-1.87883],VPR=[40.3,0,323.4],VPD=292.705): A diagonal hole through a cylinder with rounded ends, created by shifting the auxiliary prism end along the prism length.  
//   back_half(200)
//     difference(){
//       right(15)xcyl(r=30,l=100,circum=true); 
//       join_prism(circle(r=15),base="cyl",base_r=-30, n=15,
//                  aux="cyl",prism_end_T=right(35),aux_r=-30,fillet=7, overlap=17);
//     }
// Example(3D,NoScales,VPT=[-7.63774,-0.808304,13.8874],VPR=[46.6,0,71.2],VPD=237.091): A hole created by shifting along prism width.  
//   left_half()
//     difference(){
//       xcyl(r=30,l=100,circum=true); 
//       join_prism(circle(r=15),base="cyl",base_r=-30, n=15,
//                  aux="cyl",prism_end_T=fwd(9),aux_r=-30,fillet=7, overlap=17);
//     }
// Example(3D,NoScales,VPT=[1.99307,-2.05618,-0.363144],VPR=[64.8,0,15],VPD=237.091): Shifting the auxiliary cylinder changes both ends of the prism
//   back_half(200)
//      difference(){
//         xcyl(r=30,l=100,circum=true); 
//         join_prism(circle(r=15),base="cyl",base_r=-30, n=15,
//                    aux="cyl",aux_T=right(20),aux_r=-30,fillet=7, overlap=17);
//      }
// Example(3D): Positioning a joiner prism as an attachment
//   cuboid([20,30,40])
//     attach(RIGHT,"root")
//       join_prism(circle(r=8,$fn=32),
//                  l=10, base="plane", fillet=4);
// Example(3D,NoScales,VPR=[47.3,0,14.5],VPT=[-2.8467,-2.05938,-10.6999],VPD=220): Two join_prism objects are placed on the parent cylinder using anchors, and then their descriptions are used to contruct a curved handle with a bezier.
//   $fs=.5; $fa=4;
//   vspace=25;
//   bezlen=40;
//   cylr=20;
//   straightlen=10;
//   circ = circle(r=6);
//   cyl(r=cylr,h=50, rounding=3)
//     let(cyl=parent())
//       down(vspace/2)
//       attach(RIGHT+FWD, "root", spin=90)
//         join_prism(circ, base="cyl", base_r=20, height=straightlen, fillet=4)
//         let(base1=parent())
//     restore(cyl)
//       up(vspace/2)
//       attach(LEFT+FWD, "root", spin=90)
//         join_prism(circ, base="cyl", base_r=20, height=straightlen, fillet=4)
//           let(base2=parent())
//     let(
//         avg_dir = desc_dir(base1,anchor=TOP)+desc_dir(base2,anchor=TOP),
//         bez=[
//           desc_point(base1,anchor=TOP),
//           desc_point(base1,anchor=TOP)+bezlen*desc_dir(base1,anchor=TOP),
//           (cylr+straightlen+bezlen)*avg_dir,
//           desc_point(base2,anchor=TOP)+bezlen*desc_dir(base2,anchor=TOP),
//           desc_point(base2,anchor=TOP)]
//       )
//       path_sweep(circ,bezier_curve(bez,40));