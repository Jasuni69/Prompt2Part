module Loch(h=5,h2=1,d=3.5,l=0,d2,deg=[45,45],rad,extrude=spiel,center=[1,1,0],fn=0,fs=fs,fa=fa,cuts=0, use2D=false,name,help){



d=is_num(d)?[d,d]:assert(d,str("Loch d =",d))d;
d2=is_num(d2)?[d2,d2]:d2;
ly=is_list(l)?max(0,l.y):0;
lx=is_list(l)?max(0,l.x):max(l,0);
cuts=ly?0:cuts;
l=max(is_list(l)?l.x:l,0);
r=[max(0,d[0]/2),max(0,d[1]/2)];
ih2=is_list(h2)?[h2[0],h2[1]]:[h2,h2];

conDeg=is_list(deg)?[deg[0],deg[1]]:[deg,deg];
deg=[is_undef(d2[0])?conDeg[0]: d[0]<d2[0]?abs(conDeg[0]):-abs(conDeg[0]),
     is_undef(d2[1])?conDeg[1]: d[1]<d2[1]?abs(conDeg[1]):-abs(conDeg[1]) 
     ];
     
h2=assert(rad?vSum(ih2)<h:vSum(ih2) <= h ,"Loch h2 too big for h")[
is_undef(d2[0])?max(deg[0]<0?min(ih2[0],r[0]/tan(-deg[0]))
                            :ih2[0],0)
               :deg[0]==90? ih2[0] :abs((d2[0]-d[0])/2/tan(deg[0])),
is_undef(d2[1])?max(deg[1]<0?min(ih2[1],r[1]/tan(-deg[1]))
                            :ih2[1],0)
               :deg[1]==90? ih2[1] :abs((d2[1]-d[1])/2/tan(deg[1]))];

rad=is_list(rad)?rad:[h2.x?rad:0,h2.y?rad:0];


maxRad=[
abs(deg[0])==90?rad[0]:abs(  h2[0]*tan(deg[0])/(1-cos(deg[0]))  ),
abs(deg[1])==90?rad[1]:abs(  h2[1]*tan(deg[1])/(1-cos(deg[1]))  )
];

hc=max(h-vSum(h2),0);// lenghth center
degC=atan((d[0]-d[1])/2/hc); // angle center part for rad>0
rotDeg=[degC,-degC];// rotate fillets

irad=[
is_undef(rad[0])?min(maxRad[0],abs(hc/2/tan(deg[0]/2)) ):min(max(0,rad[0]),maxRad[0]),
is_undef(rad[1])?min(maxRad[1],abs(hc/2/tan(deg[1]/2)) ):min(max(0,rad[1]),maxRad[1])
];


center=is_list(center)?center:[1,1,1]*b(center,false);


r2=[ //extrude radius
 abs(deg[0])==90?max(d2[0]?d2[0]/2:0,r[0]+irad[0])*sign(deg[0]):
                 r[0]+h2[0]*tan(deg[0]),
 abs(deg[1])==90?max(d2[1]?d2[1]/2:0,r[1]+irad[1])*sign(deg[1]):
                 r[1]+h2[1]*tan(deg[1])
];
iext=is_list(extrude)?extrude:is_num(extrude)?[extrude,extrude]:extrude?[500,500]:[0,0];
extrude=[r2[0]>0?iext[0]:0,r2[1]>0?iext[1]:0];
ifn360=fn?fn:fs2fn(fs=fs,r=max(r2[0],r2[1],max(r)) );
ifn=fn?ceil(fn/2)-1:fs2fn(fs=fs,r=max(r2[0],r2[1],max(r)),grad=ly?90:180)-1;

radFn=[fs2fn(fs=fs,fa=fa,r=irad[0],grad=deg[0]-degC,minf=3),fs2fn(fs=fs,fa=fa,r=irad[1],grad=deg[1]+degC,minf=3)];


// WIP move fillets for tangential
delta=[irad[0]*tan(rotDeg[0]/2) * [sin(deg[0]),cos(deg[0]) ],irad[1]*tan(rotDeg[1]/2) * [sin(deg[1]),cos(deg[1]) ]];
radDeltaH=[tan(deg[0]/2)*irad[0],tan(deg[1]/2)*irad[1]]+[delta[0].y,delta[1].y];
radDeltaX=-[delta[0].x,delta[1].x];

Echo(str("d is list and rad>0 WIP not fully implemented! degC=",degC,"°"),color="warning",condition=d[0]!=d[1]&&max(irad)>0);

Echo(str(name," Loch h2=",h2," to big for h=",h," min h=",vSum(h2)),condition=h-vSum(h2)<0);

Echo(str(name," Loch h2=",ih2," to big for deg=",deg," with r=",r," ⇒ limited to h2=",h2),color="warning",condition=min(deg)<0&&(r[0]<ih2[0]*tan(-deg[0])||r[1]<ih2[1]*tan(-deg[1])));

Echo(str(name," Loch rad ",rad," to big for h2(",h2,") ⇒ limited to max rad=",irad),color="warning",condition=(rad[0]&&maxRad[0]<rad[0])||(rad[1]&&maxRad[1]<rad[1]));
Echo(str(name," Loch h too small for rad"),condition=abs(radDeltaH[0])>hc+1e-16-abs(radDeltaH[1])||vSum(radDeltaH)>hc+1e-16);

// INFO
hCinfo=hc-vSum(radDeltaH);// needs checking
degCinfo=max(irad)&&degC?str(degC," ! WIP"):degC;

InfoTxt("Loch",concat(["d",[r2[0],r,r2[1]]*2,"length-X",[r2[0]*2+lx,r*2+lx*[1,1],r2[1]*2+lx],"centerH",hCinfo],d[0]-d[1]?["degC",str(degCinfo,"°")]:[]),name);

HelpTxt("Loch",["h",h,"h2",h2,"d",d,"l",l,"d2",d2,"deg",deg,"rad",rad,"extrude",extrude,"center",center,"fn",fn,"fs",fs,"fa",fa,"cuts",cuts,"use2D", use2D,"name",name],help);