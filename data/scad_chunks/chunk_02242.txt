module camera_front(cam, hinge = 0) { //! Make the STL for a camera case front
    front = cam_front_size(cam);
    back = cam_back_size(cam);
    pcb = camera_pcb(cam);
    pcb_size = pcb_size(pcb);
    lens_offset = camera_lens_offset(cam);
    screw = pcb_screw(pcb);

    shelf = front.z - back.z;

    connector_slot = connector_size + 2 * [clearance, 0, layer_height];
    rad = wall;
    led_hole_r = 1;
    led_clearance = [5,   2, 1 * 2];
    res_clearance = [3.5, 2, 1 * 2];

    conn_pos = camera_connector_pos(cam);
    conn = camera_connector_size(cam);
    sensor_length = conn_pos.y + conn.y / 2 - lens_offset.y + clearance;

    module hinge_pos()
        if(!is_undef(hinge))
            rotate(hinge * 90)
                translate([0, (hinge ? front.x * hinge : front.y) / 2 + hinge_offset, hinge_r])
                    children();

    stl(str("camera_front_", cam[0]))
        difference() {
            union() {
                hull()
                    for(x = [-1, 1], y = [-1, 1])
                        translate([x * (front.x / 2 - rad), y * (front.y / 2 - rad)])
                            hull() {    // 3D truncated teardrop gives radiused edges without exceeding 45 degree overhang
                                translate_z(front.z - 1)
                                    cylinder(r = rad, h = 1);

                                translate_z(rad)
                                    sphere(rad);

                                cylinder(r = rad * (sqrt(2) - 1), h = eps);
                            }

                hinge_pos()
                    hull() {
                        rotate([-90, 0, -90])
                            teardrop(r = hinge_r, h = hinge_h, center = false);

                        translate([0, -10, -hinge_r])
                            cube([hinge_h, eps, 2 * hinge_r]);
                    }
            }

            hinge_pos()
                rotate([90, 0, 90])
                    teardrop_plus(r = screw_clearance_radius(hinge_screw), h = 100, center = true);

            translate_z(front.z / 2 + shelf - layer_height)                                 // recess for the back
                cube([back.x + 2 * clearance, back.y + 2 * clearance, front.z], center = true);

            translate_z(front.z / 2 + shelf - pcb_size.z)                                   // recess for PCB
                cube([pcb_size.x + 2 * clearance, pcb_size.y + 2 * clearance, front.z], center = true);

            translate_z(shelf)
                hflip() {
                    pcb_component_position(pcb, "smd_led")                                  // clearance for LED
                        cube(led_clearance, center = true);

                    pcb_component_position(pcb, "smd_res")                                  // clearance for resistor
                        cube(res_clearance, center = true);
                }

            translate([conn_pos.x, lens_offset.y + sensor_length / 2, shelf - pcb_size.z])  // clearance for sensor connector
                cube([conn.x + 2 * clearance, sensor_length, 2 * cam_front_clearance(cam)], center = true);

            translate([0, -front.y / 2, shelf + front.z / 2])                               // slot for connector
                cube([connector_slot.x, connector_slot.y, front.z], center = true);

            translate_z(cam_back_clearance + layer_height)
                cam_holes(cam)
                    rotate(90)
                        poly_cylinder(r = screw_clearance_radius(screw), h = 100, center = true);

            translate_z(shelf - pcb_size.z)
                hflip()
                    camera_lens(cam, clearance);

            hflip()
                pcb_component_position(pcb, "smd_led")
                    rotate(45)
                        poly_cylinder(r = led_hole_r, h = 100, center = true);              // hole for led
        }
}