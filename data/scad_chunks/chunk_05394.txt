module edge_profile_asym(
    edges=EDGES_ALL, except=[],
    excess=0.01, convexity=10,
    flip=false, corner_type="none",
    size=[0,0]
) {
    function _corner_orientation(pos,pvec) =
        let(
            j = [for (i=[0:2]) if (pvec[i]) i][0],
            T = (pos.x>0? xflip() : ident(4)) *
                (pos.y>0? yflip() : ident(4)) *
                (pos.z>0? zflip() : ident(4)) *
                rot(-120*(2-j), v=[1,1,1])
        ) T;

    function _default_edge_orientation(edge) =
        edge.z < 0? [[-edge.x,-edge.y,0], UP] :
        edge.z > 0? [[-edge.x,-edge.y,0], DOWN] :
        edge.y < 0? [[-edge.x,0,0], BACK] :
        [[-edge.x,0,0], FWD] ;

    function _edge_transition_needs_flip(from,to) =
        let(
            flip_edges = [
                [BOT+FWD, [FWD+LEFT, FWD+RIGHT]],
                [BOT+BACK, [BACK+LEFT, BACK+RIGHT]],
                [BOT+LEFT, []],
                [BOT+RIGHT, []],
                [TOP+FWD, [FWD+LEFT, FWD+RIGHT]],
                [TOP+BACK, [BACK+LEFT, BACK+RIGHT]],
                [TOP+LEFT, []],
                [TOP+RIGHT, []],
                [FWD+LEFT, [TOP+FWD, BOT+FWD]],
                [FWD+RIGHT, [TOP+FWD, BOT+FWD]],
                [BACK+LEFT, [TOP+BACK, BOT+BACK]],
                [BACK+RIGHT, [TOP+BACK, BOT+BACK]],
            ],
            i = search([from], flip_edges, num_returns_per_match=1)[0],
            check = assert(i!=[], "Bad edge vector.")
        ) in_list(to,flip_edges[i][1]);

    function _edge_corner_numbers(vec) =
        let(
            v2 = [for (i=idx(vec)) vec[i]? (vec[i]+1)/2*pow(2,i) : 0],
            off = v2.x + v2.y + v2.z,
            xs = [0, if (!vec.x) 1],
            ys = [0, if (!vec.y) 2],
            zs = [0, if (!vec.z) 4]
        ) [for (x=xs, y=ys, z=zs) x+y+z + off];

    function _gather_contiguous_edges(edge_corners) =
        let(
            no_tri_corners = all([for(cn = [0:7]) len([for (ec=edge_corners) if(in_list(cn,ec[1])) 1])<3]),
            check = assert(no_tri_corners, "Cannot have three edges that meet at the same corner.")
        )
        _gather_contiguous_edges_r(
            [for (i=idx(edge_corners)) if(i) edge_corners[i]],
            edge_corners[0][1],
            [edge_corners[0][0]], []);

    function _gather_contiguous_edges_r(edge_corners, ecns, curr, out) =
        len(edge_corners)==0? [each out, curr] :
        let(
            i1 = [
                for (i = idx(edge_corners))
                if (in_list(ecns[0], edge_corners[i][1]))
                i
            ],
            i2 = [
                for (i = idx(edge_corners))
                if (in_list(ecns[1], edge_corners[i][1]))
                i
            ]
        ) !i1 && !i2? _gather_contiguous_edges_r(
            [for (i=idx(edge_corners)) if(i) edge_corners[i]],
            edge_corners[0][1],
            [edge_corners[0][0]],
            [each out, curr]
        ) : let(
            nu_curr = [
                if (i1) edge_corners[i1[0]][0],
                each curr,
                if (i2) edge_corners[i2[0]][0],
            ],
            nu_ecns = [
                if (!i1) ecns[0] else [
                    for (ecn = edge_corners[i1[0]][1])
                    if (ecn != ecns[0]) ecn
                ][0],
                if (!i2) ecns[1] else [
                    for (ecn = edge_corners[i2[0]][1])
                    if (ecn != ecns[1]) ecn
                ][0],
            ],
            rem = [
                for (i = idx(edge_corners))
                if (i != i1[0] && i != i2[0])
                edge_corners[i]
            ]
        )
        _gather_contiguous_edges_r(rem, nu_ecns, nu_curr, out);

    function _edge_transition_inversions(edge_string) =
        let(
            // boolean cumulative sum
            bcs = function(list, i=0, inv=false, out=[])
                    i>=len(list)? out :
                    let( nu_inv = list[i]? !inv : inv )
                    bcs(list, i+1, nu_inv, [each out, nu_inv]),
            inverts = bcs([
                false,
                for(i = idx(edge_string)) if (i)
                    _edge_transition_needs_flip(
                        edge_string[i-1],
                        edge_string[i]
                    )
            ]),
            boti = [for(i = idx(edge_string)) if (edge_string[i].z<0) i],
            topi = [for(i = idx(edge_string)) if (edge_string[i].z>0) i],
            lfti = [for(i = idx(edge_string)) if (edge_string[i].x<0) i],
            rgti = [for(i = idx(edge_string)) if (edge_string[i].x>0) i],
            idx = [for (m = [boti, topi, lfti, rgti]) if(m) m[0]][0],
            rinverts = inverts[idx] == false? inverts : [for (x = inverts) !x]
        ) rinverts;

    function _is_closed_edge_loop(edge_string) =
        let(
            e1 = edge_string[0],
            e2 = last(edge_string)
        )
        len([for (i=[0:2]) if (abs(e1[i])==1 && e1[i]==e2[i]) 1]) == 1 &&
        len([for (i=[0:2]) if (e1[i]==0 && abs(e2[i])==1) 1]) == 1 &&
        len([for (i=[0:2]) if (e2[i]==0 && abs(e1[i])==1) 1]) == 1;

    function _edge_pair_perp_vec(e1,e2) =
        [for (i=[0:2]) if (abs(e1[i])==1 && e1[i]==e2[i]) -e1[i] else 0];

    req_children($children);
    check1 = assert($parent_geom != undef, "No object to attach to!")
        assert(in_list(corner_type, ["none", "round", "chamfer", "sharp"]))
        assert(is_bool(flip));
    edges = _edges(edges, except=except);
    vecs = [
        for (i = [0:3], axis=[0:2])
        if (edges[axis][i]>0)
        EDGE_OFFSETS[axis][i]
    ];
    all_vecs_are_edges = all([for (vec = vecs) sum(v_abs(vec))==2]);
    check2 = assert(all_vecs_are_edges, "All vectors must be edges.");
    edge_corners = [for (vec = vecs) [vec, _edge_corner_numbers(vec)]];
    edge_strings = _gather_contiguous_edges(edge_corners);
    default_tag("remove")
    for (edge_string = edge_strings) {
        inverts = _edge_transition_inversions(edge_string);
        flipverts = [for (x = inverts) flip? !x : x];
        vecpairs = [
            for (i = idx(edge_string))
            let (p = _default_edge_orientation(edge_string[i]))
            flipverts[i]? [p.y,p.x] : p
        ];
        is_loop = _is_closed_edge_loop(edge_string);
        for (i = idx(edge_string)) {
            if (corner_type!="none" && (i || is_loop)) {
                e1 = select(edge_string,i-1);
                e2 = select(edge_string,i);
                vp1 = select(vecpairs,i-1);
                vp2 = select(vecpairs,i);
                pvec = _edge_pair_perp_vec(e1,e2);
                pos = [for (i=[0:2]) e1[i]? e1[i] : e2[i]];
                mirT = _corner_orientation(pos, pvec);
                $attach_to = undef;
                $attach_anchor = _find_anchor(pos, $parent_geom);
                $profile_type = "corner";
                position(pos) {
                    multmatrix(mirT) {
                        if (vp1.x == vp2.x && size.y > 0) {
                            zflip() {
                                if (corner_type=="chamfer") {
                                    fn = $fn;
                                    move([size.y,size.y]) {
                                        rotate_extrude(angle=90, $fn=4)
                                            left_half(planar=true, $fn=fn)
                                                zrot(-90) fwd(size.y) children();
                                    }
                                    linear_extrude(height=size.x) {
                                        mask2d_roundover(size.y, inset=0.01, $fn=4);
                                    }
                                } else if (corner_type=="round") {
                                    move([size.y,size.y]) {
                                        rotate_extrude(angle=90)
                                            left_half(planar=true)
                                                zrot(-90) fwd(size.y) children();
                                    }
                                    linear_extrude(height=size.x) {
                                        mask2d_roundover(size.y, inset=0.01);
                                    }
                                }
                            }
                        } else if (vp1.y == vp2.y) {
                            if (corner_type=="chamfer") {
                                fn = $fn;
                                rotate_extrude(angle=90, $fn=4)
                                    right_half(planar=true, $fn=fn)
                                        children();
                                rotate_extrude(angle=90, $fn=4)
                                    left_half(planar=true, $fn=fn)
                                        children();
                            } else if (corner_type=="round") {
                                rotate_extrude(angle=90)
                                    right_half(planar=true)
                                        children();
                                rotate_extrude(angle=90)
                                    left_half(planar=true)
                                        children();
                            } else { //corner_type == "sharp"
                                intersection() {
                                    rot([90,0, 0]) linear_extrude(height=100,center=true,convexity=convexity) children();
                                    rot([90,0,90]) linear_extrude(height=100,center=true,convexity=convexity) children();
                                }
                            }
                        }
                    }
                }
            }
        }
        for (i = idx(edge_string)) {
            $attach_to = undef;
            $attach_anchor = _find_anchor(edge_string[i], $parent_geom);
            $profile_type = "edge";
            edge_profile(edge_string[i], excess=excess, convexity=convexity) {
                if (flipverts[i]) {
                    mirror([-1,1]) children();
                } else {
                    children();
                }
            }
        }
    }
}



// Module: corner_profile()
// Synopsis: Rotationally extrudes a 2d edge profile into corner mask on the given corners of the parent.
// SynTags: Geom
// Topics: Attachments, Masking
// See Also: attachable(), position(), attach(), face_profile(), edge_profile(), corner_mask(), face_mask(), edge_mask()
// Usage:
//   PARENT() corner_profile([corners], [except], [r=|d=], [convexity=]) CHILDREN;
// Description:
//   Takes a 2D mask shape, rotationally extrudes and converts it into a corner mask, and attaches it
//   to the selected corners with the appropriate orientation. If no tag is set then `corner_profile()`
//   sets the tag for children to "remove" so that it will work with the default {{diff()}} tag.
//   See [Specifying Corners](attachments.scad#subsection-specifying-corners) for information on how to specify corner sets.
//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).
// Arguments:
//   corners = Corners to mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: All corners.
//   except = Corners to explicitly NOT mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: No corners.
//   ---
//   r = Radius of corner mask.
//   d = Diameter of corner mask.
//   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10
// Side Effects:
//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
//   `$idx` is set to the index number of each corner.
//   `$attach_anchor` is set for each corner given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
//   `$profile_type` is set to `"corner"`.
// Example:
//   diff()
//   cuboid([50,60,70],rounding=10,edges="Z",anchor=CENTER) {
//       corner_profile(TOP,r=10)
//           mask2d_teardrop(r=10, angle=40);
//   }