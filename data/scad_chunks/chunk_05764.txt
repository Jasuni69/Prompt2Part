function vnf_boundary(vnf,merge=true,idx=false) =
   assert(!idx || !merge, "\nCannot request indices unless marge=false and VNF contains no duplicate vertices.")
   let(
       vnf = merge ? vnf_merge_points(vnf) : vnf,
       edgelist= [ for(face=vnf[1], edge=pair(face,wrap=true))
                      [edge.x<edge.y ? edge : [edge.y,edge.x],edge]
                 ],
       sortedge = _sort_pairs0(edgelist),  
       edges=  [
                if (sortedge[0][0]!=sortedge[1][0]) sortedge[0][1],
                for(i=[1:1:len(sortedge)-2])
                     if (sortedge[i][0]!=sortedge[i-1][0] && sortedge[i][0]!=sortedge[i+1][0]) sortedge[i][1],
                if (last(sortedge)[0] != sortedge[len(sortedge)-2][0]) last(sortedge)[1]
               ],
       paths = _assemble_paths(vnf[0], edges)    // could be made cleaner and maybe more robust with an _assemble_path version that 
   )                                             // uses edge vertex indices instead of actual point values
   idx ? paths : [for(path=paths) select(vnf[0],path)];


// Function: vnf_small_offset()
// Synopsis: Computes an offset surface to a VNF for small offset distances
// SynTags: VNF
// Topics: VNF Manipulation
// See Also: vnf_sheet(), vnf_merge_points()
// Usage:
//   newvnf = vnf(vnf, delta, [merge=]);
// Description:
//   Computes a simple offset of a VNF by estimating the normal at every point based on the weighted average of surrounding polygons
//   in the mesh.  The offset distance, `delta`, must be small enough so that no self-intersection occurs, which is no issue when the
//   curvature is positive (like the outside of a sphere) but for negative curvature it means the offset distance must be smaller
//   than the smallest radius of curvature of the VNF. Any self-intersection that occurs
//   invalidates the resulting geometry, giving you an error when you introduce a second object into the model.
//   **It is your responsibility to avoid invalid geometry!**  It cannot be detected automatically.  
//   The positive offset direction is toward the outside of the VNF, the faces that are colored yellow in the "thrown together" view.  
//   .
//   **The input VNF must not contain duplicate points.**  By default, vnf_small_offset() calls {{vnf_merge_points()}}
//   to remove duplicate points.  Note, however, that this operation can be slow.  If you are **certain** there are no duplicate points you can
//   set `merge=false` to disable the automatic point merge and save time.  The result of running on a VNF with duplicate points is likely to
//   be incorrect or invalid.
// Arguments:
//   vnf = vnf to offset
//   delta = distance of offset, positive to offset out, negative to offset in
//   ---
//   merge = set to false to suppress the automatic invocation of {{vnf_merge_points()}}.  Default: true
// Example(3D):  The original sphere is on the left and an offset sphere on the right.  
//   vnf = sphere(d=100);
//   xdistribute(spacing=125){
//     vnf_polyhedron(vnf);
//     vnf_polyhedron(vnf_small_offset(vnf,18));
//   }
// Example(3D): The polyhedron on the left is enlarged to match the size of the offset polyhedron on the right.  The offset does **not** preserve coplanarity of faces.  This is because the vertices all move independently, so nothing constrains faces to remain coplanar.  
//   include <BOSL2/polyhedra.scad>
//   vnf = regular_polyhedron_info("vnf","pentagonal icositetrahedron",d=25);
//   xdistribute(spacing=300){
//     scale(11)vnf_polyhedron(vnf);
//     vnf_polyhedron(vnf_small_offset(vnf,125));
//   }