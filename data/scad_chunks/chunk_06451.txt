module generic_bottle_neck(
    wall,
    neck_d = 25,
    id = 21.4,
    thread_od = 27.2,
    height = 17,
    support_d = 33.0,
    pitch = 3.2,
    round_supp = false,
    anchor = "support-ring",
    spin = 0,
    orient = UP
) {
    inner_d = id;
    neck_d = neck_d;
    supp_d = max(neck_d, support_d);
    thread_pitch = pitch;
    flank_angle = 15;

    diamMagMult = neck_d / 26.19;
    heightMagMult = height / 17.00;

    assert(all_nonnegative([support_d]),"support_d must be a nonnegative number");
    sup_r = 0.30 * (heightMagMult > 1 ? heightMagMult : 1);
    support_r = floor(((supp_d == neck_d) ? sup_r : min(sup_r, (supp_d - neck_d) / 2)) * 5000) / 10000;
    support_rad = (wall == undef || !round_supp) ? support_r :
        min(support_r, floor((supp_d - (inner_d + 2 * wall)) * 5000) / 10000);
        //Too small of a radius will cause errors with the arc, this limits granularity to .0001mm
    support_width = max(heightMagMult,1) * sign(support_d);
    roundover = 0.58 * diamMagMult;
    lip_roundover_r = (roundover > (neck_d - inner_d) / 2) ? 0 : roundover;
    h = height + support_width;
    threadbase_d = neck_d - 0.8 * diamMagMult;

    $fn = segs(33 / 2);
    thread_h = (thread_od - threadbase_d) / 2;
    anchors = [
        named_anchor("support-ring", [0, 0, 0 - h / 2])
    ];
    attachable(anchor, spin, orient, d = neck_d, l = h, anchors = anchors) {
        down(h / 2) {
            rotate_extrude(convexity = 10) {
                polygon(turtle(
                    state = [inner_d / 2, 0], (supp_d != neck_d) ? [
                        "untilx", supp_d / 2 - ((round_supp) ? support_rad : 0),
                        "arcleft", ((round_supp) ? support_rad : 0), 90,
                        "untily", support_width - support_rad,
                        "arcleft", support_rad, 90,
                        "untilx", neck_d / 2,
                        "right", 90,
                        "untily", h - lip_roundover_r,
                        "arcleft", lip_roundover_r, 90,
                        "untilx", inner_d / 2
                    ] : [
                        "untilx", supp_d / 2 - ((round_supp) ? support_rad : 0),
                        "arcleft", ((round_supp) ? support_rad : 0), 90,
                        "untily", h - lip_roundover_r,
                        "arcleft", lip_roundover_r, 90,
                        "untilx", inner_d / 2
                    ]
                ));
            }
            up(h - pitch / 2 - lip_roundover_r) {
                difference() {
                    thread_helix(
                        d = threadbase_d - 0.1 * diamMagMult,
                        pitch = thread_pitch,
                        thread_depth = thread_h + 0.1 * diamMagMult,
                        flank_angle = flank_angle,
                        turns = (height - pitch - lip_roundover_r) * .6167 / pitch,
                        lead_in = -thread_h * 2,
                        anchor = TOP
                    );
                    zrot_copies(rots = [90, 270]) {
                        zrot_copies(rots = [-28, 28], r = threadbase_d / 2) {
                            prismoid(
                                [20 * heightMagMult, 1.82 * diamMagMult],
                                [20 * heightMagMult, 1.82 * diamMagMult * .6 + 2 * sin(29) * thread_h],
                                h = thread_h + 0.1 * diamMagMult,
                                anchor = BOT,
                                orient = RIGHT
                            );
                        }
                    }
                }
            }
        }
        children();
    }
}