function bezier_triangle(tri, splinesteps=16, vertices=[], faces=[]) =
	let(
		base = len(vertices),
		pts = [
			for (
				u=[0:splinesteps],
				v=[0:splinesteps-u]
			) bezier_triangle_point(tri, u/splinesteps, v/splinesteps)
		],
		new_vertices = concat(vertices, pts),
		patchlen = len(tri),
		tricnt = _tri_count(splinesteps+1),
		new_faces = [
			for (
				u=[0:splinesteps-1],
				v=[0:splinesteps-u-1]
			) let (
				v1 = v + (tricnt - _tri_count(splinesteps+1-u)) + base,
				v2 = v1 + 1,
				v3 = v + (tricnt - _tri_count(splinesteps-u)) + base,
				v4 = v3 + 1,
				allfaces = concat(
					[[v1,v2,v3]],
					((u<splinesteps-1 && v<splinesteps-u-1)? [[v2,v4,v3]] : [])
				)
			)  for (face=allfaces) face
		]
	) [new_vertices, concat(faces, new_faces)];



// Function: bezier_patch_flat()
// Usage:
//   bezier_patch_flat(size, [N], [orient], [trans]);
// Description:
//   Returns a flat rectangular bezier patch of degree `N`, centered on the XY plane.
// Arguments:
//   size = 2D XY size of the patch.
//   N = Degree of the patch to generate.  Since this is flat, a degree of 1 should usually be sufficient.
//   orient = The orientation to rotate the edge patch into.  Use the `ORIENT` constants in `BOSL/constants.scad`.
//   trans = Amount to translate patch, after rotating to `orient`.
// Example(3D):
//   patch = bezier_patch_flat(size=[100,100], N=3);
//   trace_bezier_patches([patch], size=1, showcps=true);