function path_to_bezcornerpath(path, closed, size, relsize) =
    is_1region(path) ? path_to_bezcornerpath(path[0], default(closed,true), tangents, size, relsize) :
    let(closed=default(closed,false))
        assert(is_bool(closed))
        assert(num_defined([size,relsize])<=1, "\nCan't define both size and relsize.")
        assert(is_path(path,[2,3]),"\nInput path is not a valid 2d or 3d path.")
        let(
            curvesize = first_defined([size,relsize,0.5]),
            relative = is_undef(size),
            pathlen = len(path)
        )
        assert(is_num(curvesize) || len(curvesize)==pathlen, str("\nSize or relsize must have length ",pathlen,"."))
        let(sizevect = is_num(curvesize) ? repeat(curvesize, pathlen) : curvesize)
            assert(min(sizevect)>0, "\nSize or relsize must be greater than zero.")
        let(
            roundpath = closed ? [
            for(i=[0:pathlen-1]) let(p3=select(path,[i-1:i+1]))
                _bez_path_corner([0.5*(p3[0]+p3[1]), p3[1], 0.5*(p3[1]+p3[2])], sizevect[i], relative),
            [0.5*(path[0]+path[pathlen-1])]
        ]
        : [ for(i=[1:pathlen-2]) let(p3=select(path,[i-1:i+1]))
            _bez_path_corner(
                [i>1?0.5*(p3[0]+p3[1]):p3[0], p3[1], i<pathlen-2?0.5*(p3[1]+p3[2]):p3[2]],
                sizevect[i], relative),
            [path[pathlen-1]]
        ]
    )
    flatten(roundpath);


/// Internal function: _bez_path_corner()
/// Usage:
///   _bez_path_corner(three_point_path, curvesize, relative);
/// Description:
///   Used by path_to_bezcornerpath()
///   Given a path with three points [p1, p2, p3] (2D or 3D), return a bezier path (minus the last control point) that creates a curve from p1 to p3.
///   The curvesize (roundness or inverse sharpness) parameter determines how close to a perfect circle (curvesize=1) or the p2 corner (curvesize=0) the path is, coming from the shortest leg. The longer leg path is stretched appropriately.
///   The error in using a cubic bezier curve to approximate a circular arc is about 0.00026 for a unit circle, with zero error at the endpoint and the corner bisector.
/// Arguments:
///   p = List of 3 points [p1, p2, p3]. The points may be 2D or 3D.
///   curvesize = curve is circular (curvesize=1) or sharp to the corner (curvesize=0) or anywhere in between
///   relative = if true, curvesize is a proportion between 0 and 1. If false, curvesize is an absolute distance that gets converted to a proportion internally.