function _find_anchor(anchor, geom)=
    is_string(anchor)? (
          anchor=="origin"? [anchor, CENTER, UP, 0]    // Ok that this returns 3d anchor in the 2d case?
        : let(
              anchors = last(geom),
              found = search([anchor], anchors, num_returns_per_match=1)[0]
          )
          assert(found!=[], str("Unknown anchor: ",anchor))
          anchors[found]
    ) :
    let(
        cp = _get_cp(geom),
        offset_raw = select(geom,-2),
        offset = [for (i=[0:2]) anchor[i]==0? 0 : offset_raw[i]],  // prevents bad centering.
        type = geom[0]
    )
    assert(is_vector(anchor),str("Invalid anchor: anchor=",anchor))
    let(
        anchor = point3d(anchor),
        oang = (
            approx(point2d(anchor), [0,0])? 0 :
            atan2(anchor.y, anchor.x)+90
        )
    )
    type == "prismoid"? ( //size, size2, shift, axis
        let(all_comps_good = [for (c=anchor) if (c!=sign(c)) 1]==[])
        assert(all_comps_good, "All components of an anchor for a cuboid/prismoid must be -1, 0, or 1")
        let(
            size=geom[1],
            size2=geom[2],
            shift=point2d(geom[3]),
            axis=point3d(geom[4]),
            override = geom[5](anchor)
        )
        let(
            size = [for (c = size) max(0,c)],
            size2 = [for (c = size2) max(0,c)],
            anch = rot(from=axis, to=UP, p=anchor),
            offset = rot(from=axis, to=UP, p=offset),
            h = size.z,
            u = (anch.z + 1) / 2,  // u is one of 0, 0.5, or 1
            axy = point2d(anch),
            bot = point3d(v_mul(point2d(size )/2, axy), -h/2),
            top = point3d(v_mul(point2d(size2)/2, axy) + shift, h/2),
            edge = top-bot,
            pos = point3d(cp) + lerp(bot,top,u) + offset,
               // Find vectors of the faces involved in the anchor
            facevecs = 
                [
                    if (anch.x!=0) unit(rot(from=UP, to=[edge.x,0,max(0.01,h)], p=[axy.x,0,0]), UP),
                    if (anch.y!=0) unit(rot(from=UP, to=[0,edge.y,max(0.01,h)], p=[0,axy.y,0]), UP),
                    if (anch.z!=0) unit([0,0,anch.z],UP)
                ],
            dir = anch==CENTER? UP
                : len(facevecs)==1? unit(facevecs[0],UP)
                : len(facevecs)==2? vector_bisect(facevecs[0],facevecs[1])
                : _three_edge_corner_dir(facevecs,[FWD,LEFT])*anch.z,            
            edgedir = len(facevecs)!=2 ? undef
                    : rot(from=UP,to=axis,p=unit(cross(facevecs[0], facevecs[1]))), 
            edgeang = len(facevecs)==2 ? 180-vector_angle(facevecs[0], facevecs[1]) : undef,
            edgelen = anch.z==0 ? norm(edge)
                    : anch.z>0 ? abs([size2.y,size2.x]*axy)
                    : abs([size.y,size.x]*axy),
            endvecs = len(facevecs)!=2 ? undef
                    : anch.z==0 ? [DOWN, UP]
                    : let(
                          raxy = zrot(-90,axy),
                          bot1 = point3d(v_mul(point2d(size )/2, raxy), -h/2),
                          top1 = point3d(v_mul(point2d(size2)/2, raxy) + shift, h/2),
                          edge1 = top1-bot1,
                          vec1 = (raxy.x!=0) ? unit(rot(from=UP, to=[edge1.x,0,max(0.01,h)], p=[raxy.x,0,0]), UP)
                               :               unit(rot(from=UP, to=[0,edge1.y,max(0.01,h)], p=[0,raxy.y,0]), UP),
                          raxy2 = zrot(90,axy),
                          bot2 = point3d(v_mul(point2d(size )/2, raxy2), -h/2),
                          top2 = point3d(v_mul(point2d(size2)/2, raxy2) + shift, h/2),
                          edge2 = top2-bot2,
                          vec2 = (raxy2.y!=0) ? unit(rot(from=UP, to=[edge.x,0,max(0.01,h)], p=[raxy2.x,0,0]), UP)
                               :               unit(rot(from=UP, to=[0,edge.y,max(0.01,h)], p=[0,raxy2.y,0]), UP)
                      )
                      [vec1,vec2],
            final_dir = default(override[1],anch==CENTER?UP:rot(from=UP, to=axis, p=dir)),
            final_pos = default(override[0],rot(from=UP, to=axis, p=pos)),

            // If the anchor is an edge anchor and not horizontal we point spin UP
            // If the anchor is horizontal edge we point spin clockwise:
            //     cross product of UP with the edge direction will point OUT if we are on top and edge direction
            //     is correct.  We check if it points out by comparing to the final_dir which points out at that edge,
            //     with a correction for top/bottom (anchor.z).  
            // Otherwise use the standard BACK/UP definition
            // The precomputed oang value seems to be wrong, at least when axis!=UP

            spin = is_def(edgedir) && !approx(edgedir.z,0) ? _compute_spin(final_dir, edgedir * (edgedir*UP>0?1:-1))
                 : is_def(edgedir) ? _compute_spin(final_dir,
                                                   edgedir * (approx(unit(cross(UP,edgedir)),unit([final_dir.x,final_dir.y,0])*anchor.z) ? 1 : -1))
                 : _compute_spin(final_dir, final_dir==DOWN || final_dir==UP ? BACK : UP)
        ) [anchor, final_pos, final_dir, default(override[2],spin),
           if (is_def(edgeang)) [["edge_angle",edgeang],["edge_length",edgelen], ["vec", endvecs]]]
    ) : type == "conoid"? ( //r1, r2, l, shift, axis
        let(
            rr1=geom[1],
            rr2=geom[2],
            length=geom[3],
            shift=point2d(geom[4]),
            axis=point3d(geom[5]),
            r1 = is_num(rr1)? [rr1,rr1] : point2d(rr1),
            r2 = is_num(rr2)? [rr2,rr2] : point2d(rr2),
            anch = rot(from=axis, to=UP, p=anchor),
            axisname = axis==UP ? "Z"
                     : axis==RIGHT ? "X"
                     : axis==BACK ? "Y"
                     : "",
            dummy = assert(anch.z == sign(anch.z), str("The ",axisname," component of an anchor for the cylinder/cone must be -1, 0, or 1")),
            offset = rot(from=axis, to=UP, p=offset),
            u = (anch.z+1)/2,
            // Returns [point,tangent_dir]
            solve_ellipse = function (r,dir) approx(dir,[0,0]) ? [[0,0],[0,0]]
                                            : let(
                                                  x = r.x*dir.x*r.y / sqrt(dir.x^2*r.y^2+dir.y^2*r.x^2),
                                                  y = r.x*dir.y*r.y / sqrt(dir.x^2*r.y^2+dir.y^2*r.x^2)
                                             )
                                             [[x,y], unit([y*r.x^2,-x*r.y^2],CTR)],
            on_center = approx(point2d(anch), [0,0]),
            botdata = solve_ellipse(r1,point2d(anch)),
            topdata = solve_ellipse(r2,point2d(anch)),
            bot = point3d(botdata[0], -length/2),
            top = move(shift,point3d(topdata[0], length/2)),
            tangent = lerp(botdata[1],topdata[1],u), 
            normal = [-tangent.y,tangent.x],
            axy = unit(point2d(anch),[0,0]),
            obot = point3d(v_mul(r1,axy), -length/2),
            otop = point3d(v_mul(r2,axy)+shift, length/2),
            pos = point3d(cp) + lerp(bot,top,u) + offset,
            sidevec = rot(from=UP, to=top==bot?UP:top-bot, p=point3d(normal)),
            vvec = anch==CENTER? UP : unit([0,0,anch.z],UP),
            vec = on_center? unit(anch,UP)
                : approx(anch.z,0)? sidevec
                : unit((sidevec+vvec)/2,UP),
            pos2 = rot(from=UP, to=axis, p=pos),
            vec2 = anch==CENTER? UP : rot(from=UP, to=axis, p=vec),
               // Set spin for top/bottom to be clockwise
            spin = anch.z!=0 && (!approx(anch.x,0) || !approx(anch.y,0)) ? _compute_spin(vec2,rot(from=UP,to=axis,p=point3d(tangent)*anch.z))
                 : anch.z==0 && norm(anch)>EPSILON ? _compute_spin(vec2, (approx(vec2,DOWN) || approx(vec2,UP))?BACK:UP)
                 : oang
        ) [anchor, pos2, vec2, spin]
    ) : type == "point"? (
        let(
            anchor = unit(point3d(anchor),CENTER),
            pos = point3d(cp) + point3d(offset),
            vec = unit(anchor,UP)
        ) [anchor, pos, vec, oang]
    ) : type == "point2d"? (
        let(
            anchor = unit(_force_anchor_2d(anchor), [0,0]),
            pos = point2d(cp) + point2d(offset),
            vec = unit(anchor,BACK)
        ) [anchor, pos, vec, oang]
    ) : type == "spheroid"? ( //r
        let(
            rr = geom[1],
            r = is_num(rr)? [rr,rr,rr] : point3d(rr),
            anchor = unit(point3d(anchor),CENTER),
            pos = point3d(cp) + v_mul(r,anchor) + point3d(offset),
            vec = unit(v_mul(r,anchor),UP)
        ) [anchor, pos, vec, oang]
    ) : type == "vnf_isect"? ( //vnf
        let(
            vnf=geom[1],
            override = geom[2](anchor)
        )                                                   // CENTER anchors anchor on cp, "origin" anchors on [0,0]
        approx(anchor,CTR)? [anchor, default(override[0],cp),default(override[1],UP),default(override[2], 0)] :     
        vnf==EMPTY_VNF? [anchor, [0,0,0], unit(anchor), 0] :
        let(
            eps = 1/2048,
            points = vnf[0],
            faces = vnf[1],
            rpts = apply(rot(from=anchor, to=RIGHT) * move(-cp), points),
            hits = [
                for (face = faces)
                    let(
                        verts = select(rpts, face),
                        ys = column(verts,1),
                        zs = column(verts,2)
                    )
                    if (max(ys) >= -eps && max(zs) >= -eps &&
                        min(ys) <=  eps &&  min(zs) <=  eps)
                        let(
                            poly = select(points, face),
                            isect = polygon_line_intersection(poly, [cp,cp+anchor], eps=eps),
                            ptlist = is_undef(isect) ? [] :
                                     is_vector(isect) ? [isect]
                                                      : flatten(isect),   // parallel to a face
                            n = len(ptlist)>0 ? polygon_normal(poly) : undef
                        )
                        for(pt=ptlist) [anchor * (pt-cp), n, pt]
            ]
        )
        assert(len(hits)>0, "Anchor vector does not intersect with the shape.  Attachment failed.")
        let(
            furthest = max_index(column(hits,0)),
            dist = hits[furthest][0],
            pos = hits[furthest][2],
            hitnorms = [for (hit = hits) if (approx(hit[0],dist,eps=eps)) hit[1]],
            unorms = [
                      for (i = idx(hitnorms))
                          let(
                              thisnorm = hitnorms[i],
                              isdup = [
                                       for (j = [i+1:1:len(hitnorms)-1])
                                           if (approx(thisnorm, hitnorms[j])) 1
                                      ] != []
                          )
                          if (!isdup) thisnorm
                     ],
            n = unit(sum(unorms)),
            oang = approx(point2d(n), [0,0])? 0 : atan2(n.y, n.x) + 90
        )
        [anchor, default(override[0],pos),default(override[1], n),default(override[2], oang)]
    ) : type == "vnf_extent"? ( //vnf
        let(
            vnf=geom[1],
            override = geom[2](anchor)
        )                                                   // CENTER anchors anchor on cp, "origin" anchors on [0,0]
        approx(anchor,CTR)? [anchor, default(override[0],cp),default(override[1],UP),default(override[2], 0)] :     
        vnf==EMPTY_VNF? [anchor, [0,0,0], unit(anchor,UP), 0] :
        let(
            rpts = apply(rot(from=anchor, to=RIGHT) * move(point3d(-cp)), vnf[0]),
            maxx = max(column(rpts,0)),
            idxs = [for (i = idx(rpts)) if (approx(rpts[i].x, maxx)) i],
            // We want to catch the case where the points lie on an edge.  The complication is that the edge
            // may appear twice WITH DIFFERENT VERTEX INDICES if repeated points appear in the vnf.  
            edges_faces = len(idxs)==2 ?  // Simple case, no repeated points, [idxs] gives the edge
                               approx(vnf[0][idxs[0]],vnf[0][idxs[1]]) ? []   // Are edge points identical?
                             : let( facelist = _vnf_find_edge_faces(vnf,idxs))
                               len(facelist)==2 ? [[idxs], facelist] : []
                        : len(idxs)!=4 ? []       // If we don't have four points it's not an edge pair
                        : let(
                              pts = select(vnf[0],idxs),
                              matchind = [for(i=[1:3]) if (approx(pts[i],pts[0])) i]   // indices where actual vertex point is the same as point zero
                          )
                          len(matchind)!=1 ? []
                        : let(   // After this runs we have two edges as index pairs, and their associated faces as index values
                              match1 = select(idxs,[0,matchind[0]]),
                              match2 = list_remove(idxs,[0,matchind[0]]),
                              facelists = [for(i=[0:1], j=[0:1])
                                              let(
                                                   ed = [match1[i],match2[j]],
                                                   fl = _vnf_find_edge_faces(vnf,ed)
                                              )
                                              if (fl!=[]) [ed,fl]
                                          ],
                              final = [column(facelists,0), flatten(column(facelists,1))]
                          )
                          assert(len(final[1])==2, "invalid!")
                          final,
            dir = len(idxs)>2 && edges_faces==[] ? [anchor,oang]
                : edges_faces!=[] ?
                    let( 
                        faces = edges_faces[1],
                        edge = select(vnf[0],edges_faces[0][0]),
                        facenormals = [for(face=faces) polygon_normal(select(vnf[0],vnf[1][face]))],
                        direction= unit(mean(facenormals)),
                        projnormals = project_plane(point4d(cross(facenormals[0],facenormals[1])), facenormals),
                        ang = 180- posmod(v_theta(projnormals[1])-v_theta(projnormals[0]),360),
                        horiz_face = [for(i=[0:1]) if (approx(v_abs(facenormals[i]),UP)) i],
                        spin = horiz_face==[] ?
                                   let(  
                                       edgedir = edge[1]-edge[0],
                                       nz = [for(i=[0:2]) if (!approx(edgedir[i],0)) i],
                                       flip = edgedir[last(nz)] < 0 ? -1 : 1
                                   )
                                   _compute_spin(direction, flip*edgedir)
                            :
                                let(
                                       hedge = len(edges_faces[0])==1 ? edges_faces[0][0]
                                                                      : edges_faces[0][horiz_face[0]],
                                       face = select(vnf[1],faces[horiz_face[0]]),
                                       edgeind = search([hedge[0]], face)[0],
                                       flip = select(face,edgeind+1)== hedge[1] ? 1 : -1, 
                                       edgedir = edge[1]-edge[0]
                                   )
                                   _compute_spin(direction, flip*edgedir)
                    ) 
                    [direction,spin,[["edge_angle",ang],["edge_length",norm(edge[0]-edge[1])]]]
                :   let(   // This section handles corner anchors, currently spins just point up
                       vertices = vnf[0],
                       faces = vnf[1],
                       cornerfaces = _vnf_find_corner_faces(vnf,idxs[0]),    // faces = [3,9,12] indicating which faces
                       normals = [for(faceind=cornerfaces) polygon_normal(select(vnf[0], faces[faceind]))],
                       angles = [for(faceind=cornerfaces)
                                    let(
                                        thisface = faces[faceind],
                                        vind = search(idxs[0],thisface)[0]
                                    )
                                    vector_angle(select(vertices, select(thisface,vind-1,vind+1)))
                                 ],
                       direc = unit(angles*normals)
                    )
                    [direc, atan2(direc.y,direc.x)+90],
            avep = sum(select(rpts,idxs))/len(idxs),
            mpt = approx(point2d(anchor),[0,0])? [maxx,0,0] : avep,
            pos = point3d(cp) + rot(from=RIGHT, to=anchor, p=mpt)
        ) [anchor, default(override[0],pos),default(override[1],dir[0]),default(override[2],dir[1]),if (len(dir)==3) dir[2]]
    ) : type == "trapezoid"? ( //size, size2, shift, override
        let(all_comps_good = [for (c=anchor) if (c!=sign(c)) 1]==[])
        assert(all_comps_good, "All components of an anchor for a rectangle/trapezoid must be -1, 0, or 1")
        let(
            anchor=_force_anchor_2d(anchor),
            size=geom[1], size2=geom[2], shift=geom[3],
            u = (anchor.y+1)/2,  // 0<=u<=1
            frpt = [size.x/2*anchor.x, -size.y/2],
            bkpt = [size2/2*anchor.x+shift, size.y/2],
            override = geom[4](anchor),
            pos = override[0] != undef? override[0] :
                point2d(cp) + lerp(frpt, bkpt, u) + point2d(offset),
            svec = approx(bkpt,frpt)? [anchor.x,0,0] :
                point3d(line_normal(bkpt,frpt)*anchor.x),
            vec = is_def(override[1]) ? override[1]
                : anchor.y == 0? ( anchor.x == 0? BACK : svec )
                : anchor.x == 0? [0,anchor.y,0]
                : unit((svec + [0,anchor.y,0]) / 2, [0,anchor.y,0])
        ) [anchor, pos, vec, 0]
    ) : type == "ellipse"? ( //r
        let(
            anchor = unit(_force_anchor_2d(anchor),[0,0]),
            r = force_list(geom[1],2),
            pos = approx(anchor.x,0)
                ? [0,sign(anchor.y)*r.y]
                : let(
                       m = anchor.y/anchor.x,
                       px = approx(min(r),0)? 0 :
                           sign(anchor.x) * sqrt(1/(1/sqr(r.x) + m*m/sqr(r.y)))
                  )
                  [px,m*px],
            vec = approx(min(r),0)? (approx(norm(anchor),0)? BACK : anchor) :
                unit([r.y/r.x*pos.x, r.x/r.y*pos.y],BACK)
        ) [anchor, point2d(cp+offset)+pos, vec, 0]
    ) : type == "rgn_isect"? ( //region
        let(
            anchor = _force_anchor_2d(anchor),
            rgn = force_region(move(-point2d(cp), p=geom[1]))
        )
        approx(anchor,[0,0])? [anchor, cp, BACK, 0] :     // CENTER anchors anchor on cp, "origin" anchors on [0,0]
        let(
            isects = [
                for (path=rgn, t=triplet(path,true)) let(
                    seg1 = [t[0],t[1]],
                    seg2 = [t[1],t[2]],
                    isect = line_intersection([[0,0],anchor], seg1, RAY, SEGMENT),
                    n = is_undef(isect)? [0,1] :
                        !approx(isect, t[1])? line_normal(seg1) :
                        unit((line_normal(seg1)+line_normal(seg2))/2,[0,1]),
                    n2 = vector_angle(anchor,n)>90? -n : n
                )
                if(!is_undef(isect) && !approx(isect,t[0])) [norm(isect), isect, n2]
            ]
        )
        assert(len(isects)>0, "Anchor vector does not intersect with the shape.  Attachment failed.")
        let(
            maxidx = max_index(column(isects,0)),
            isect = isects[maxidx],
            pos = point2d(cp) + isect[1],
            vec = unit(isect[2],[0,1])
        ) [anchor, pos, vec, 0]
    ) : type == "rgn_extent"? ( //region
        let( anchor = _force_anchor_2d(anchor) )
        approx(anchor,[0,0])? [anchor, cp, BACK, 0] :   // CENTER anchors anchor on cp, "origin" anchors on [0,0]
        let(
            rgn = force_region(geom[1]),
            rpts = rot(from=anchor, to=RIGHT, p=flatten(rgn)),
            maxx = max(column(rpts,0)),
            ys = [for (pt=rpts) if (approx(pt.x, maxx)) pt.y],
            midy = (min(ys)+max(ys))/2,
            pos = rot(from=RIGHT, to=anchor, p=[maxx,midy])
        ) [anchor, pos, unit(anchor,BACK), 0]
    ) : type=="extrusion_extent" || type=="extrusion_isect" ? (  // extruded region
        assert(in_list(anchor.z,[-1,0,1]), "The Z component of an anchor for an extruded 2D shape must be -1, 0, or 1.")
        let(
            anchor_xy = point2d(anchor),
            rgn = geom[1],
            L = geom[2],
            twist = geom[3],
            scale = geom[4],
            shift = geom[5],
            u = (anchor.z + 1) / 2,
            shmat = move(lerp([0,0], shift, u)),
            scmat = scale(lerp([1,1], scale, u)),
            twmat = zrot(lerp(0, -twist, u)),
            mat = shmat * scmat * twmat
        )
        approx(anchor_xy,[0,0]) ? [anchor, apply(mat, point3d(cp,anchor.z*L/2)), unit(anchor, UP), oang] :
        let(
            newrgn = apply(mat, rgn),
            newgeom = attach_geom(two_d=true, region=newrgn, extent=type=="extrusion_extent", cp=cp),
            topmat = anchor.z!=0 ? []
                   : move(shift)*scale(scale)*zrot(-twist),
            topgeom = anchor.z!=0? []
                    : attach_geom(two_d=true, region=apply(topmat,rgn), extent=type=="extrusion_extent", cp=cp),
            top2d =  anchor.z!=0? []
                  : _find_anchor(anchor_xy, topgeom),
            result2d = _find_anchor(anchor_xy, newgeom),
            pos = point3d(result2d[1], anchor.z*L/2),
            vec = anchor.z==0? rot(from=UP,to=point3d(top2d[1],L/2)-point3d(result2d[1]),p=point3d(result2d[2]))
                : unit(point3d(result2d[2], anchor.z),UP),
            oang = atan2(vec.y,vec.x) + 90
        )
        [anchor, pos, vec, oang]
    ) :
    assert(false, "Unknown attachment geometry type.");


/// Internal Function: _is_shown()
/// Usage:
///   bool = _is_shown();
/// Topics: Attachments
/// See Also: reorient(), attachable()
/// Description:
///   Returns true if objects should currently be shown based on the tag settings.