function _contour_pixels(pixsize, bbox, fieldarray, fieldfunc, pixcenters, isovalmin, isovalmax, closed=true) = let(
    // get field intensities
    hp = 0.5*pixsize,
    field = is_def(fieldarray)
    ? fieldarray
    : let(v = bbox[0], b1 = bbox[1]+[hp.x,hp.y]) [
        for(x=[v.x:pixsize.x:b1.x]) [
            for(y=[v.y:pixsize.y:b1.y])
                fieldfunc(x,y)
        ]
    ],
    has_center_array = is_list(pixcenters),
    nx = len(field)-2,
    ny = len(field[0])-2,
    v0 = bbox[0]
) let(
    isocorrectmin = (isovalmin>=0?1:-1)*max(abs(isovalmin)*1.000001, isovalmin+0.0000001),
    isocorrectmax = (isovalmax>=0?1:-1)*max(abs(isovalmax)*1.000001, isovalmax+0.0000001)
) [
    for(i=[0:nx]) let(x=v0.x+pixsize.x*i)
        for(j=[0:ny]) let(y=v0.y+pixsize.y*j)
            let(i1=i+1, j1=j+1,
                pf = let(
                    // clamp corner values to Â±1e9, make sure no corner=isovalmin or isovalmax
                    f0=let(c=min(1e9,max(-1e9,field[i][j]))) abs(c-isovalmin)<EPSILON ? isocorrectmin : abs(c-isovalmax)<EPSILON ? isocorrectmax : c,
                    f1=let(c=min(1e9,max(-1e9,field[i][j1]))) abs(c-isovalmin)<EPSILON ? isocorrectmin : abs(c-isovalmax)<EPSILON ? isocorrectmax : c,
                    f2=let(c=min(1e9,max(-1e9,field[i1][j]))) abs(c-isovalmin)<EPSILON ? isocorrectmin : abs(c-isovalmax)<EPSILON ? isocorrectmax : c,
                    f3=let(c=min(1e9,max(-1e9,field[i1][j1]))) abs(c-isovalmin)<EPSILON ? isocorrectmin : abs(c-isovalmax)<EPSILON ? isocorrectmax : c
                ) [  // pixel corner field values
                    f0, f1, f2, f3,
                    // get center value of pixel
                    if (has_center_array)
                        pixcenters[i][j]
                    else if(pixcenters)
                        is_def(fieldfunc)
                            ? min(1e9,max(-1e9,fieldfunc(x+hp.x, y+hp.y)))
                            : 0.25*(f0 + f1 + f2 + f3)
                ],
                minpf = min(pf),
                maxpf = max(pf),
                pixcoord = [x,y],
                psides = closed ? _bbox_sides(pixcoord, pixsize, bbox) : [],
                pixfound_isomin = (minpf <= isovalmin && isovalmin <= maxpf),
                pixfound_isomax = (minpf <= isovalmax && isovalmax <= maxpf),
                pixfound_outer = len(psides)==0 ? false
                : let(
                    ps = flatten([for(i=psides) _MTEdgeVertexIndices[i]]),
                    sumcond = len([for(p=ps) if(isovalmin<=pf[p] && pf[p]<=isovalmax) 1])
                ) sumcond == len(ps), // true if full edge is between isovalmin and isovalmax
                pixindex_isomin = pixfound_isomin ? _mctrindex(pf, isovalmin) : 0,
                pixindex_isomax = pixfound_isomax ? _mctrindex(pf, isovalmax) : 0
            ) if(pixfound_isomin || pixfound_isomax || pixfound_outer) [
                pixcoord,           // pixel lower coordinate
                pixindex_isomin,    // pixel ID for isomin
                pixindex_isomax,    // pixel ID for isomax
                pf,                 // clamped pixel corner values
                psides              // list of bounding box sides, if any
            ]
];