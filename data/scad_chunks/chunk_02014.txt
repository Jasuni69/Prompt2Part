module drag_chain_link(type, start = false, end = false, check_kids = true) { //! One link of the chain, special case for start and end
    stl(str(drag_chain_name(type), "_drag_chain_link", start ? "_start" : end ? "_end" : ""));

    s = drag_chain_size(type);
    wall = drag_chain_wall(type);
    bwall = drag_chain_bwall(type);
    twall = drag_chain_twall(type);
    os = drag_chain_outer_size(type);
    clearance = drag_chain_clearance(type);
    supports = drag_chain_supports(type);
    r = os.z / 2;
    // initial estimates of pin_r and pin_h
    pin_r0 = r / 2 - 0.2;
    pin_h0 = min(wall + clearance, 2 * pin_r0 - 1);
     // for conical pin: ensure minimum radius of top of pin and pin does not overlap cutout
    pin_r = supports ? r / 2 : min(r / 2 - 0.2, (os.z - 2 * twall - 3 * pin_h0 / 4 - 0.2) / 2);
    pin_h = min(wall + clearance, 2 * pin_r - 1);

    socket_x = r;
    pin_x = socket_x + s.x;

    outer_normal_x =  pin_x - r - clearance;     // s.x - clearance
    outer_end_x = end ? os.x : outer_normal_x;

    inner_x = start ? 0 : outer_normal_x - wall; // s.x - clearance - wall

    roof_x_normal = 2 * r - twall;
    cam_x = drag_chain_cam_x(type);
    assert(r + norm([drag_chain_cam_x(type), r - drag_chain_twall(type)]) + clearance <= inner_x || start, "Link must be longer");

    vflip(!supports)
    difference() {
        union() {
            for(side = [-1, 1])
                rotate([90, 0, 0]) {
                    // Outer cheeks
                    translate_z(side * (os.y / 2 - wall / 2))
                        difference() {
                            linear_extrude(wall, center = true)
                                hull() {
                                    if(start)
                                        square([eps, os.z]);
                                    else
                                        translate([socket_x, r])
                                            rotate(supports ? 180 : 0)
                                                teardrop(r = r, h = 0);

                                    translate([outer_end_x - eps, 0])
                                        square([eps, os.z]);
                                }
                                if(!start)
                                    if(supports)
                                        translate([socket_x, r, 0])
                                            horihole(pin_r, r, wall + 2*eps);
                                    else
                                        translate([socket_x, r, -side * (wall / 2 + clearance)])
                                            rotate(180)
                                                hull() {
                                                    horihole(r = pin_r + pin_h / 2, z = r, h = eps);
                                                    translate_z(side * pin_h)
                                                        horihole(r = pin_r - pin_h / 2, z = r, h = eps);
                                                }
                            }
                    // Inner cheeks
                    translate_z(side * (s.y / 2 + wall / 2)) {
                        linear_extrude(wall, center = true)
                            difference() {
                                union() {
                                    hull() {
                                        if(!end) {
                                            translate([pin_x, r])
                                                rotate(supports ? 180 : 0)
                                                    teardrop(r = r, h = 0);

                                            translate([pin_x, twall])
                                                square([cam_x, eps]);
                                        }
                                        else
                                            translate([os.x - eps, 0])
                                                square([eps, os.z]);

                                        translate([inner_x, 0])
                                            square([eps, os.z]);
                                    }
                                }
                                // Cutout for top wall
                                if(!end)
                                    intersection() {
                                        translate([pin_x - r, 0])
                                            square([3 * r, twall]);  // When straight

                                        translate([pin_x, r])
                                             rotate(-45)
                                                translate([-r + roof_x_normal, -r - twall]) // When bent fully
                                                    square(os.z);
                                    }
                            }
                        // Pin
                        if(!end)
                            if(supports)
                                translate([pin_x, r, side * (wall / 2 + clearance)])
                                    horicylinder(r = pin_r, z = r, h = 2 * wall + eps);
                            else
                                translate([pin_x, r, side * wall / 2])
                                    vflip(side == -1)
                                        cylinder(r1 = pin_r + pin_h / 2, r2 = pin_r - pin_h / 2, h = pin_h + eps);
                    }

                    // Cheek joint
                    translate([inner_x, 0, side * (s.y / 2 + wall) - 0.5])
                        cube([outer_end_x - inner_x, os.z, 1]);
                }

            // Roof, actually the floor when printed with supports
            roof_x = start ? 0 : roof_x_normal;
            roof_end = end ? s.x + 2 * r : s.x + r - twall - clearance;
            translate([roof_x, -s.y / 2 - wall, 0]) {
                cube([roof_end - roof_x, s.y + 2 * wall, twall]);
                translate([0, -wall, 0])
                    cube([s.x - roof_x - clearance, s.y + 4 * wall, twall]);
            }

            // Floor, actually the roof when printed with supports
            floor_x = start ? 0 : 2 * r;
            floor_end = end ? s.x + 2 * r : s.x + r;
            translate([floor_x, -s.y / 2 - wall, os.z - bwall]) {
                cube([floor_end - floor_x, s.y + 2 * wall, bwall]);
                translate([0, -wall, 0])
                    cube([s.x - floor_x - clearance, s.y + 4 * wall, bwall]);
            }

            if(start || end) {
                drag_chain_screw_positions(type, end)
                    rotate($a)
                        screw_lug(drag_chain_screw(type), os.z);

                if(check_kids) {
                    custom = drag_chain_screw_lists(type)[bool2int(end)] == [0, 0, 0, 0];
                    assert($children == bool2int(custom), str("wrong number of children for ",  end ? "end" : "start", " STL customisation: ", $children));
                }
                children();
            }
        } // end union

        if(start || end)
            translate_z(-eps)
                drag_chain_screw_positions(type, end)
                    rotate($a)
                        poly_cylinder(r = screw_clearance_radius(drag_chain_screw(type)), h = os.z + 2 * eps, center = false);
    } // end difference

    if(supports && show_supports() && !end) {
        for(side = [-1, 1]) {
            w = 2.1 * extrusion_width;
            translate([s.x + r + cam_x - w / 2, side * (s.y / 2 + wall / 2), twall / 2])
                cube([w, wall, twall], center = true);

            h = round_to_layer(r - pin_r / sqrt(2));
            y = s.y / 2  + max(wall + w / 2 + clearance, 2 * wall + clearance - w / 2);
            translate([s.x + r, side * y, h / 2])
                cube([pin_r * sqrt(2), w, h], center = true);

            gap = cam_x - pin_r / sqrt(2) + extrusion_width;
            translate([s.x + r + cam_x - gap / 2, side * (s.y / 2 + wall + clearance / 2), layer_height / 2])
                cube([gap, 2 * wall + clearance, layer_height], center = true);
        }
    }
}

// Need to use a wrapper because can't define nested modules in an assembly