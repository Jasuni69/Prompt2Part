function pb_ellipseArc(p1=[], p2=[], rx, ry, angle=0, long=false, ccw=false, skip_first=false) = rx==0||ry==0? [p1,p2] : let(
    d = norm(p2-p1),
    e = assert(rx*2>=d, str("pb_ellipseArc - Radius:",rx," is too small for distance:",d)),
    pc = pb_ellipseCenter(p2,p1,rx,ry,angle, long, ccw),
    
    m = [[cos(angle), -sin(angle)],[sin(angle), cos(angle)]],
    nm = [[cos(-angle), -sin(-angle)],[sin(-angle), cos(-angle)]],
    v1 = (p1-pc) * nm, v2 = (p2-pc) * nm,
    a1 = (v1[1]<0? 180 : 0)+ atan2(v1[0]/v1[1],rx/ry),
    a2 = (v2[1]<0? 180 : 0)+ atan2(v2[0]/v2[1],rx/ry),
    da = abs(a2 - a1 % 360), das = da<=180? da : 360-da,
    cda = long? 360-das : das,
  
    s = pb_segmentsPerCircle((rx+ry)/2),

    steps = floor(abs(cda*s/360)),
    sa = ccw? -(cda/steps) : cda/steps,
    pts = steps<=2? [p2] : [for(i=[1:steps-1]) let(a = a1 + (sa * i)%360) pc+[sin(a) * rx , cos(a) * ry] * m, p2]
) [skip_first? pts : concat([p1],pts),concat(pc,0)];

//  function pb_curveBetweenPoints(p1, p2, radius)
//
//  Creates a curve made of line segments connecting the two points with the defined radius.
//  p1      (list)   List of two numbers representing a 2D point
//  p2      (list)   List of two numbers representing a 2D point
//  radius  (number) Required radius of the desired curve. Change the sign of the radius to mirror the curve. The radius value must be at least half the distance between p1 and p2.
//  return  (list)   List of the resulting curve data...
//      return[0]    (list)   List of the 2D point list describing the curve. The list includes p1 and p2.
//      return[1]    (number) Angle of the last line segment in the curve
//      return[2]    (list)   List of two numbers representing a 2D point. This point is the center of the circle segment drawn.