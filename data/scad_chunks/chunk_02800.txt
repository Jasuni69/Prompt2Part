module text_subdivision(text,size=10,font="Subdivision Font",halign="left",valign="baseline",spacing=1,line_spacing=3,weight=1,slant=0,method="1path",smooth=2,fontdefinition,custom=false,t,_index=0,_xoffset=0,_yoffset=0)
{
  // Print the characters according to the width.
  // Only one character is printed. This function is
  // called recursively for the next character.

  if(size>0)
  {
    // The OpenSCAD function text() has "text" as the first parameter.
    // But sometimes it is documented as "t".
    // Therefor this function allows also "t".
    // The parameter "t" is however at the end of other parameters, to
    // avoid that the normal order of parameters is disturbed.
    stringcommon = is_undef(t)    ? "" : t;
    string       = is_undef(text) ? stringcommon : text;

    // I think that a default spacing of 3 is okay.
    char_spacing = 3 * spacing;

    // Check if the user has a own font definition.
    // If so, add it to the end of the internal list of fonts.
    _fontlist = is_undef(fontdefinition) ? font_list : concat(font_list,fontdefinition);

    // Find the font of the name.
    for(i=[0:len(_fontlist)-1])
    {
      if(_fontlist[i][0][0] == font)
      {
        // Concatenate the default font after the found font.
        // Then it automatically falls back to the default font.
        font_definition = concat(_fontlist[i][1],_fontlist[0][1]);
        
        if(_index < len(string))
        {
          // If the character was not found, then the index 0 is used.
          char = string[_index];
          dataindex = GetFontIndex(font_definition,char);
          width = font_definition[dataindex][1];
          points = font_definition[dataindex][2];
          newline = (char == "\n");
          tab = (char == "\t");

          // Implementing the backspace is not possible,
          // since the "\b" is not possible in OpenSCAD.
          // There are UTF-8 characters that can be written over a character,
          // so maybe this code can be used in the future.
          //        // Going back is not possible with this recursive function.
          //        // Therefor if the next character is a backspace, then
          //        // the x position is not incremented.
          //        next_index = _index < (len(string)-1) ? _index+1 : 0;
          //        next_char_backspace = (next_index > 0 && string[next_index] == "\b");
          next_char_backspace = false;

          // Adjust alignment
          xoffset_aligned = (halign == "center") ? _xoffset - width/2 : _xoffset;

          // are there any points and is it printable ?
          if(len(points) > 0 && !newline && !tab)
          {
            // This render over the iterations reduces the number
            // of triangles in the 2D resulting shape.
            render()
            {
              for(i=[0:len(points)-1])
              {
                path = Subdivision(points[i],divisions=smooth,method=method);

                // The font design is for a height of 10.
                // The 'size' parameter scales everything.
                scale([size/10,size/10])
                {
                  translate([xoffset_aligned,_yoffset])
                  {
                    if(len(path) == 1)
                    {
                      // Not a hull() over two points, but a single point
                      y = path[0].y;
                      x = path[0].x + slant * y;
                      list1 = [[x,y]];
                      if(custom)
                        CustomRender(list1,weight);
                      else
                        DefaultRender(list1,weight);
                    }
                    else
                    {
                      // Take two points.
                      // make a line with a hull() over two points.
                      for(j=[0:len(path)-2])
                      {
                        y1 = path[j].y;
                        x1 = path[j].x + slant * y1;
                        y2 = path[j+1].y;
                        x2 = path[j+1].x + slant * y2;
                        list2 = [[x1,y1],[x2,y2]];
                        if(custom)
                          CustomRender(list2,weight);
                        else
                          DefaultRender(list2,weight);
                      }
                    }
                  }
                }
              }
            }
          }
          
          // Solve the extras for a new line or a tab.
          //
          // Everything is scaled according to the size,
          // but the tab is fixed.
          // Therefor the tab gets a counter-scaling
          // to compensate the overall scaling.
          counter_tab  = 50 * (10 / size);
          tabposition  = counter_tab*floor((_xoffset + counter_tab) / counter_tab);
          charposition = _xoffset+font_definition[dataindex][1]+char_spacing;
          new_xoffset1 = next_char_backspace ? _xoffset : charposition;
          new_xoffset2 = newline ? 0 : new_xoffset1;
          new_xoffset3 = tab     ? tabposition : new_xoffset2; 
          new_yoffset  = newline ? _yoffset - 10 - line_spacing : _yoffset;
          new_index    = next_char_backspace ? _index+2 : _index+1;

          // Call this function recursively for the next character
          text_subdivision(text=string,size=size,font=font,
                           weight=weight,slant=slant,
                           halign=halign,valign=valign,
                           spacing=spacing,line_spacing=line_spacing,
                           method=method,smooth=smooth,
                           fontdefinition=fontdefinition,
                           custom=custom,
                           _index=new_index,
                           _xoffset=new_xoffset3,
                           _yoffset=new_yoffset);
        }
      }
    }
  }
}

// DefaultRender()
// ---------------
// The default render function to make the
// shape of the characters.
// A shape is a circle or a hull over two circles.