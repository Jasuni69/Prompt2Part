function linear_sweep(
    region, height, center,
    twist=0, scale=1, shift=[0,0],
    slices, maxseg, style="default", caps=true, 
    cp, atype="hull", h,
    texture, tex_size=[5,5], tex_reps, tex_counts,
    tex_inset=false, tex_rot=0,
    tex_scale, tex_depth, tex_samples, h, l, length, 
    anchor, spin=0, orient=UP
) =
    assert(num_defined([tex_reps,tex_counts])<2, "In linear_sweep() the 'tex_counts' parameter has been replaced by 'tex_reps'.  You cannot give both.")
    assert(num_defined([tex_scale,tex_depth])<2, "In linear_sweep() the 'tex_scale' parameter has been replaced by 'tex_depth'.  You cannot give both.")
    let(
        region = force_region(region),
        tex_reps = is_def(tex_counts)? echo("In linear_sweep() the 'tex_counts' parameter is deprecated and has been replaced by 'tex_reps'")tex_counts
                 : tex_reps,
        tex_depth = is_def(tex_scale)? echo("In linear_sweep() the 'tex_scale' parameter is deprecated and has been replaced by 'tex_depth'")tex_scale
                  : default(tex_depth,1)
    )
    assert(is_region(region), "Input is not a region or polygon.")
    assert(is_num(scale) || is_vector(scale))
    assert(is_vector(shift, 2), str(shift))
    assert(is_bool(caps) || is_bool_list(caps,2), "caps must be boolean or a list of two booleans")
    let(
        h = one_defined([h, height,l,length],"h,height,l,length",dflt=1)
    )
    !is_undef(texture)? _textured_linear_sweep(
        region, h=h, caps=caps, 
        texture=texture, tex_size=tex_size,
        counts=tex_reps, inset=tex_inset,
        rot=tex_rot, tex_scale=tex_depth,
        twist=twist, scale=scale, shift=shift,
        style=style, samples=tex_samples,
        anchor=anchor, spin=spin, orient=orient
    ) :
    let(
        caps = is_bool(caps) ? [caps,caps] : caps, 
        anchor = center==true? "origin" :
            center == false? "original_base" :
            default(anchor, "original_base"),
        regions = region_parts(region),
        slices = default(slices, max(1,ceil(abs(twist)/5))),
        scale = is_num(scale)? [scale,scale] : point2d(scale),
        topmat = move(shift) * scale(scale) * rot(-twist),
        trgns = [
            for (rgn = regions) [
                for (path = rgn) let(
                    p = list_unwrap(path),
                    path = is_undef(maxseg)? p : [
                        for (seg = pair(p,true)) each
                        let( steps = ceil(norm(seg.y - seg.x) / maxseg) )
                        lerpn(seg.x, seg.y, steps, false)
                    ]
                ) apply(topmat, path)
            ]
        ],
        vnf = vnf_join([
            for (rgn = regions)
            for (pathnum = idx(rgn)) let(
                p = list_unwrap(rgn[pathnum]),
                path = is_undef(maxseg)? p : [
                    for (seg=pair(p,true)) each
                    let(steps=ceil(norm(seg.y-seg.x)/maxseg))
                    lerpn(seg.x, seg.y, steps, false)
                ],
                verts = [
                    for (i=[0:1:slices]) let(
                        u = i / slices,
                        scl = lerp([1,1], scale, u),
                        ang = lerp(0, -twist, u),
                        off = lerp([0,0,-h/2], point3d(shift,h/2), u),
                        m = move(off) * scale(scl) * rot(ang)
                    ) apply(m, path3d(path))
                ]
            ) vnf_vertex_array(verts, caps=false, col_wrap=true, style=style),
            if (caps[0]) for (rgn = regions) vnf_from_region(rgn, down(h/2), reverse=true),
            if (caps[1]) for (rgn = trgns) vnf_from_region(rgn, up(h/2), reverse=false)
        ]),
        anchors = [
            named_anchor("original_base", [0,0,-h/2], DOWN),
            named_anchor("original_top", [0,0,h/2], UP),
        ],
        cp = default(cp, "centroid"),
        geom = atype=="hull"?  attach_geom(cp=cp, region=region, h=h, extent=true, shift=shift, scale=scale, twist=twist, anchors=anchors) :
            atype=="intersect"?  attach_geom(cp=cp, region=region, h=h, extent=false, shift=shift, scale=scale, twist=twist, anchors=anchors) :
            atype=="bbox"?
                let(
                    bounds = pointlist_bounds(flatten(region)),
                    size = bounds[1] - bounds[0],
                    midpt = (bounds[0] + bounds[1])/2
                )
                attach_geom(cp=[0,0,0], size=point3d(size,h), offset=point3d(midpt), shift=shift, scale=scale, twist=twist, anchors=anchors) :
            assert(in_list(atype, ["hull","intersect","bbox"]), "Anchor type must be \"hull\", \"intersect\", or \"bbox\".")
    ) reorient(anchor,spin,orient, geom=geom, p=vnf);


// Function&Module: rotate_sweep()
// Synopsis: Create a surface of revolution from a path with optional texturing. 
// SynTags: VNF, Geom
// Topics: Extrusion, Sweep, Revolution, Textures
// See Also: linear_sweep(), sweep(), spiral_sweep(), path_sweep(), offset_sweep()
// Usage: As Function
//   vnf = rotate_sweep(shape, [angle], ...);
// Usage: As Module
//   rotate_sweep(shape, [angle], ...) [ATTACHMENTS];
// Usage: With Texturing
//   rotate_sweep(shape, texture=, [tex_size=]|[tex_reps=], [tex_depth=], [tex_samples=], [tex_rot=], [tex_inset=], ...) [ATTACHMENTS];
// Description:
//   Takes a path or [region](regions.scad) and sweeps it in a rotation around the Z axis, with optional texturing.
//   When called as a function, returns a [VNF](vnf.scad).
//   When called as a module, creates the sweep as geometry.  By default the sweep starts on the X+ axis.  For 360 degree sweeps this
//   may be inconsistent with the native rotate_extrude(), which historically started on the X- axis.  The `start` parameter changes where
//   the sweep starts; set it to 180 to get the historical rotate_extrude() behavior.  
//   .
//   The region or path that you provide to sweep is defined in the XY plane and cannot have any negative x values.  By default a path is treated as a closed shape.
//   (Regions are always composed of closed polygons.)  When you apply a texture, no path in your region can have more than one edge on the Y axis.  
//   If you give a path whose endpoints are not on the Y axis and specify `caps=true` then the path
//   endpoints are connected to the Y axis by a horizontal segment at each end, and the corresponding top and bottom surfaces in the revolution do not receive texture.
//   You can terminate just one end of the path on the Y axis and in this case, you get a single untextured cap.  If your texture is not zero at the
//   edges, the endcaps may appear textured: they will not be flat because the top perimeter will follow the texture.  
//   .
//   When `caps=true` you can use `tex_taper` to change the depth of the texture along the length of the path given in `shape`.  This
//   can be useful for forcing flat caps on a textured object by forcing the texture depth to zero at the ends.  
//   The simplest option is to set `tex_taper` to a value between 0 and 0.5.  In this case, the texture depth linearly falls to zero
//   at both ends, starting at the specified fraction from the end.  For example, if `tex_taper=1/3` then the center third of the object
//   will have the normal texture depth, and the texture will fall to zero over the top and bottom thirds.  For more control over the texture
//   tapering you can also set `tex_taper` to a lookup table suited to the `lookup()` function.  The lookup table will be evaluated at 0 to
//   determine the texture depth multiplier at the bottom and at 1 to determine the texture depth multiplier at the top.  The final option is
//   to set `tex_taper` to a function which takes one parameter and is defined on [0,1].  Using these more sophisticated methods you can actually
//   change the shape of the object.  If you want to ensure flat caps, simply make sure that your lookup table or function maps both zero and one to zero.
//   Texture multipliers can be any number.  If the multiplier is negative it will invert the texture, and if the multiplier exceeds one, the texture will
//   scale to larger than your specified `tex_depth` value.  
//   .
//   If you want to place just one or a few copies of a texture onto an object rather than texturing the entire object you can do that by using
//   and angle smaller than 360.  However, if you want to control the aspect ratio of the resulting texture you will have to carefully calculate the proper
//   angle to use to ensure that the arc length in the horizontal direction is the proper length compared to the arc length in the vertical direction.
//   To simplify this process you can use `pixel_aspect` or `tex_aspect`.  You can set `tex_aspect` for any type of tile and it specifies
//   the desired aspect ratio (width/height) for the tiles.  You must specify `tex_reps` in order to use this feature.  For heightfields you can instead provide
//   a pixel aspect ratio, which is suited to the case where your texture is a non-square image that you want to place on a curved object.  For a simple cylinder
//   it is obvious what the horizontal arc length is; for other objects this is computed based on the average radius of the longest path in `shape`.  
// Arguments:
//   shape = The polygon or [region](regions.scad) to sweep around the Z axis.
//   angle = If given, specifies the number of degrees to sweep the region around the Z axis, counterclockwise from the X+ axis.  Default: 360 (full rotation)
//   ---
//   start = Start extrusion at this angle counterclockwise from the X+ axis.  Default:0
//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.
//   tex_size = An optional 2D target size (2-vector or scalar) for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`
//   tex_reps = If given instead of tex_size, a scalar or 2-vector giving the integer number of texture tile repetitions in the horizontal and vertical directions.
//   tex_inset = If numeric, lowers the texture into the surface by the specified proportion, e.g. 0.5 would lower it half way into the surface.  If `true`, insets by exactly its full depth.  Default: `false`
//   tex_rot = Rotate texture by specified angle, which must be a multiple of 90 degrees.  Default: 0
//   tex_depth = Specify texture depth; if negative, invert the texture.  Default: 1.
//   tex_samples = Minimum number of "bend points" to have in VNF texture tiles.  Default: 8
//   tex_taper = If `caps=true`, scales the texture depth along the path given in `shape`.  If set to a scalar between 0 and 0.5, adjusts the specfied top and bottom fraction of the path linearly to zero depth.  You can also provide a lookup table or function defining the scala factor over the range [0,1].  Default: no taper
//   tex_aspect = Choose the angle of the revolution to maintain this aspect ratio for the tiles.  You must specify tex_reps.  Overrides any angle specified.  
//   pixel_aspect = Choose the angle of the revolution to maintain this apsect ratio for pixels in a heightfield texture.  You must specify tex_reps.  Overrides any angle specified.
//   style = {{vnf_vertex_array()}} style.  Default: "min_edge"
//   caps = If true and `shape` is a path whose endpoints are to the right of the Y axis, then adds untextured caps to the top and/or bottom of the revolved surface.  Ignored if `shape` is not a path or if its endpoints are on the Y axis.   Default: `false`
//   convexity = (Module only) Convexity setting for use with polyhedron.  Default: 10
//   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
//   atype = Select "hull" or "intersect" anchor types.  Default: "hull"
//   anchor = Translate so anchor point is at the origin. Default: "origin"
//   spin = Rotate this many degrees around Z axis after anchor. Default: 0
//   orient = Vector to rotate top toward after spin (module only)
// Named Anchors:
//   "origin" = The native position of the shape.  
// Anchor Types:
//   "hull" = Anchors to the virtual convex hull of the shape.
//   "intersect" = Anchors to the surface of the shape.
// Example(3D,NoAxes,VPR=[60.20,0.00,41.80],VPD=151.98,VPT=[0.85,-2.95,3.10]): Sweeping a shape that looks like a plus sign
//   rgn = right(30,
//           union([for (a = [0, 90])
//                    zrot(a, rect([15,5]))]));
//   rotate_sweep(rgn);
// Example(3D,NoAxes,VPR=[50.40,0.00,28.50],VPD=208.48,VPT=[0.23,-1.89,5.20]): Sweeping a region with multiple components
//   rgn = [
//       for (a = [0, 120, 240]) let(
//           cp = polar_to_xy(15, a) + [30,0]
//       ) each [
//           move(cp, p=circle(r=10)),
//           move(cp, p=hexagon(d=15)),
//       ]
//   ];
//   rotate_sweep(rgn, angle=240);
// Example(3D,NoAxes,VPR=[55.00,0.00,25.00],VPD=292.71,VPT=[1.59,1.80,-1.35]): Torus with bricks texture
//   path = right(50, p=circle(d=40));
//   rotate_sweep(path, texture="bricks_vnf",tex_size=10,
//                  tex_depth=0.5, style="concave");
// Example(3D,NoAxes,VPR=[76.30,0.00,44.60],VPD=257.38,VPT=[2.58,-5.21,0.37]): Applying a texture to a region.  Both the inside and outside receive texture.
//   rgn = [
//       right(40, p=circle(d=50)),
//       right(40, p=circle(d=40,$fn=6)),
//   ];
//   rotate_sweep(
//       rgn, texture="diamonds",
//       tex_size=[10,10], tex_depth=1,
//       angle=240, style="concave");
// Example(NoAxes): The simplest way to create a cylinder with just a single line segment and `caps=true`.  With this cylinder, the top and bottom have no texture.  
//   rotate_sweep([[20,-10],[20,10]], texture="dots",
//                tex_reps=[6,2],caps=true);
// Example(NoAxes): If we manually connect the top and bottom then they also receive texture.  
//   rotate_sweep([[0,-10],[20,-10],[20,10],[0,10]], 
//                tex_reps=[6,6],tex_depth=1.5,
//                texture="dots");
// Example(NoAxes,VPR=[95.60,0.00,69.80],VPD=74.40,VPT=[5.81,5.74,1.97]): You can connect just the top or bottom alone instead of both to get texture on one and a flat cap on the other.  Here you can see that the sloped top has texture but the bottom does not.  Also note that the texture doesn't fit neatly on the side and top like it did in the previous two examples, but makes a somewhat ugly transition across the corner.  You have to size your object carefully so that the tops and sides each fit an integer number of texture tiles to avoid this type of transition.  
//   rotate_sweep([[15,-10],[15,10],[0,15]],
//                texture="dots", tex_reps=[6,6],
//                angle=90,caps=true,tex_depth=1.5);
// Example(NoAxes,VPR=[55.00,0.00,25.00],VPD=126.00,VPT=[1.37,0.06,-0.75]): Ribbed sphere. 
//   path = arc(r=20, $fn=64, angle=[-90, 90]);
//   rotate_sweep(path, 360, texture = texture("wave_ribs",n=15),
//                tex_size=[8,1.5]);
// Example(3D,NoAxes,VPR=[60.20,0.00,56.50],VPD=231.64,VPT=[4.18,-2.66,1.31]): This model uses `caps=true` to create the untextured caps with a user supplied texture.  They are flat because the texture is zero at its edges.
//   tex = [
//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
//       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
//       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
//       [0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1],
//       [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1],
//       [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1],
//       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1],
//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
//       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   ];
//   path = arc(cp=[0,0], r=40, start=60, angle=-120);
//   rotate_sweep(
//       path, caps=true, 
//       texture=tex, tex_size=[20,20],
//       tex_depth=1, style="concave");
// Example(3D,NoAxes,VPR=[60.20,0.00,56.50],VPD=187.63,VPT=[2.07,-4.53,2.58]):  An example with a more complicated path.  Here the caps are not flat because the diamonds texture is not zero at the edges.  
//   bezpath = [
//       [15, 30], [10,15],
//       [10,  0], [20, 10], [30,12],
//       [30,-12], [20,-10], [10, 0],
//       [10,-15], [15,-30]
//   ];
//   path = bezpath_curve(bezpath, splinesteps=32);
//   rotate_sweep(
//       path, caps=true, 
//       texture="diamonds", tex_size=[10,10],
//       tex_depth=1, style="concave");
// Example(3D,NoAxes,VPR=[70.00,0.00,58.60],VPD=208.48,VPT=[1.92,-3.81,2.21]): The normal direction at the ends is perpendicular to the Z axis, so even though the texture is not zero, the caps are flat, unlike the previous example.
//   path = [
//       [20, 30], [20, 20],
//       each arc(r=20, corner=[[20,20],[10,0],[20,-20]]),
//       [20,-20], [20,-30],
//   ];
//   rotate_sweep(
//       path, caps=true, 
//       texture="diamonds",
//       tex_size=[5,5], tex_depth=1,
//       style="concave",
//       convexity=10);
// Example(3D,NoAxes,VPR=[59.20,0.00,226.90],VPD=113.40,VPT=[-4.53,3.03,3.84]): The top cap is definitely not flat.  
//   rotate_sweep(
//       arc(r=20,angle=[-45,45],n=45),
//       caps=true, texture="diamonds",
//       tex_size=[5,5], tex_depth=2,
//       convexity=10);
// Example(3D,NoAxes,VPR=[59.20,0.00,226.90],VPD=113.40,VPT=[-4.53,3.03,3.84]): Setting `tex_taper=0` abruptly tapers right at the caps so that the cap is flat:
//   rotate_sweep(
//       arc(r=20,angle=[-45,45],n=45),
//       caps=true, texture="diamonds",
//       tex_size=[5,5], tex_depth=2,
//       tex_taper=0, convexity=10);
// Example(3D,NoAxes,VPR=[59.20,0.00,226.90],VPD=113.40,VPT=[-4.53,3.03,3.84]): Setting `tex_taper=0.5` tapers gradually across the entire shape:
//   rotate_sweep(
//       arc(r=20,angle=[-45,45],n=45),
//       caps=true, texture="diamonds",
//       tex_size=[5,5], tex_depth=2,
//       tex_taper=.5, convexity=10);
// Example(3D,VPR=[59.20,0.00,91.10],VPD=126.00,VPT=[4.29,2.29,2.31],NoAxes): The path given here starts and ends on the Y axis, but you can still request (zero size) caps so that you can use tapering, which is only permitted when caps are enabled.  
//   rotate_sweep(
//      arc(r=20, angle=[-90,90], n=45), texture="dots",
//      caps=true, tex_reps=[15,10], tex_taper=0.5, tex_depth=2);
// Example(3D, NoAxes): Tapering of textures via lookup table to be maximal at the bottom and 0 at the top.  
//   path = [
//       [20, 30], [20, 20],
//       each arc(r=20, corner=[[20,20],[10,0],[20,-20]]),
//       [20,-20], [20,-30],
//   ];
//   rotate_sweep(
//       path, caps=true, 
//       texture="trunc_pyramids",
//       tex_size=[5,5], tex_depth=1,
//       tex_taper=[[0,1], [1,0]],
//       style="convex",
//       convexity=10);
// Example(3D,NoAxes,VPR=[106.10,0.00,158.30],VPD=155.56,VPT=[-2.68,-0.92,1.07]): Here we use a cosine function (lifted so it stays nonnegative) to scale the texture.  Since the taper function rises as high as 2 the effective texture depth is 4 at the peaks.
//   rotate_sweep([[20,-20],[20,20]],texture="trunc_diamonds",
//                caps=true, tex_reps=[20,16], tex_depth=2,
//                tex_taper=function(x) 1-cos(360*3*x));
// Example(3D,NoAxes,VPR=[83.70,0.00,195.40],VPD=82.67,VPT=[-1.69,4.43,0.46]): Here we use a sine function that goes below zero in the top half of the object.  This inverts the texture and the result is that the inverted texture bulges outward with the change in the texture depth that the taper applies.  In the bottom section, the scaling applies directly.  
//   rotate_sweep([[10,-12],[10,12]], caps=true, tex_reps=[16,6],
//                tex_taper=function(x) sin(360*x),tex_depth=2,
//                texture="dots");
// Example(3D,NoAxes,VPR=[83.70,0.00,195.40],VPD=82.67,VPT=[-1.69,4.43,0.46]): We adjust the VNF texture from the previous example so its "zero" level is at 1/2.  This makes the result symmetric between the positive and negative taperings.  
//      tex = up(1/2,zscale(1/2,texture("dots")));
//      rotate_sweep([[10,-12],[10,12]], caps=true, tex_reps=[16,6],
//                   tex_taper=function(x) sin(360*x),tex_depth=2,
//                   texture=tex);
// Example(3D,NoAxes,VPR=[72.50,0.00,119.10],VPD=155.56,VPT=[7.95,8.65,3.01]): Here we create a texture effect entirely with tapering using a constant "texture" of 3/4.  The inverted texture is 1-3/4 = 1/4, so the negative regions of the function create shallower bands.  
//    rotate_sweep([[20,-20],[20,20]], caps=true, tex_reps=[30,45], texture=[[3/4]],
//                 tex_taper=function(x) sin(2.5*360*x),tex_depth=4);
// Example(3D,NoAxes,Med,VPT=[-2.92656,1.26781,0.102897],VPR=[62.7,0,222.4],VPD=216.381): This VNF tile makes a closed shape and the actual main extrusion is not created.  We give `caps=true` to prevent the shape from being closed on the outside, but because the VNF tile has no edges, no actual cap is created.  
//   shape = skin([rect(2/5),
//                 rect(2/3),
//                 rect(2/5)],
//                z=[0,1/2,1],
//                slices=0,
//                caps=false);
//   tile = move([0,1/2,2/3],yrot(90,shape));
//   path = [for(y=[-30:30]) [ 20-3*(1-cos((y+30)/60*360)),y]];
//   rotate_sweep(path, caps=false, texture=tile, 
//                tex_size=[10,10], tex_depth=5);
// Example(3D,Med,VPT=[1.04269,4.35278,-0.716624],VPR=[98.4,0,43.9],VPD=175.268): Adding the angle parameter cuts off the extrusion.  Note how each extruded component is capped.  
//   shape = skin([rect(2/5),
//                 rect(2/3),
//                 rect(2/5)],
//                z=[0,1/2,1],
//                slices=0,
//                caps=false);
//   tile = move([0,1/2,2/3],yrot(90,shape));
//   path = [for(y=[-30:30]) [ 20-3*(1-cos((y+30)/60*360)),y]];
//   rotate_sweep(path, caps=true, texture=tile, 
//                tex_size=[10,15], tex_depth=5, angle=215);
// Example(3D,NoAxes,Med,VPT=[1.00759,3.89216,-1.27032],VPR=[57.1,0,34.8],VPD=240.423): Turning the texture 90 degrees with `tex_rot` produces a texture that ends at the top and bottom.
//   shape = skin([rect(2/5),
//                 rect(2/3),
//                 rect(2/5)],
//                z=[0,1/2,1],
//                slices=0,
//                caps=false);
//   tile = move([0,1/2,2/3],yrot(90,shape));
//   path = [for(y=[-30:30]) [ 20-3*(1-cos((y+30)/60*360)),y]];
//   rotate_sweep(path, caps=true, texture=tile, tex_rot=90,
//                tex_size=[12,8], tex_depth=9, angle=360);
// Example(3D,Med,NoAxes,VPR=[78.1,0,199.3],VPT=[-4.55445,1.37814,-4.39897],VPD=192.044): A basket weave texture, here only halfway around the circle to avoid clutter.  
//     diag_weave_vnf = [
//         [[0.2, 0, 0], [0.8, 0, 0], [1, 0.2, 0.5], [1, 0.8, 0.5], [0.7, 0.5, 0.5],
//          [0.5, 0.3, 0], [0.2, 0, 0.5], [0.8, 0, 0.5], [1, 0.2, 1], [1, 0.8, 1],
//          [0.7, 0.5, 1], [0.5, 0.3, 0.5], [1, 0.2, 0], [1, 0.8, 0], [0.8, 1, 0.5],
//          [0.2, 1, 0.5], [0.5, 0.7, 0.5], [0.7, 0.5, 0], [0.8, 1, 1], [0.2, 1, 1],
//          [0.5, 0.7, 1], [0.8, 1, 0], [0.2, 1, 0], [0, 0.8, 0.5], [0, 0.2, 0.5],
//          [0.3, 0.5, 0.5], [0.5, 0.7, 0], [0, 0.8, 1], [0, 0.2, 1], [0.3, 0.5, 1],
//          [0, 0.8, 0], [0, 0.2, 0], [0.3, 0.5, 0], [0.2, 0, 1], [0.8, 0, 1], [0.5, 0.3, 1]],
//         [[0, 1, 5], [1, 2, 4, 5], [7, 11, 10, 8], [8, 10, 9], [7, 8, 2, 1], [9, 10, 4, 3],
//          [10, 11, 5, 4], [0, 5, 11, 6], [12, 13, 17], [13, 14, 16, 17], [3, 4, 20, 18],
//          [18, 20, 19], [3, 18, 14, 13], [19, 20, 16, 15], [20, 4, 17, 16], [12, 17, 4, 2],
//          [21, 22, 26], [22, 23, 25, 26], [15, 16, 29, 27], [27, 29, 28], [15, 27, 23, 22],
//          [28, 29, 25, 24], [29, 16, 26, 25], [21, 26, 16, 14], [30, 31, 32], [31, 6, 11, 32],
//          [24, 25, 35, 33], [33, 35, 34], [24, 33, 6, 31], [34, 35, 11, 7],
//          [35, 25, 32, 11], [30, 32, 25, 23]]
//     ];
//     path = [for(y=[-30:30]) [ 20-3*(1-cos((y+30)/60*360)),y]];
//     down(31)linear_extrude(height=1)arc(r=23,angle=[0,180], wedge=true);
//     rotate_sweep(path, caps=true, texture=diag_weave_vnf, angle=180,
//                  tex_size=[10,10], convexity=12, tex_depth=2);
// Example(3D,VPR=[59.20,0.00,159.20],VPD=74.40,VPT=[7.45,6.83,1.54],NoAxes): Textures can be used to place images onto objects.  If you want to place an image onto a cylinder you probably don't want it to cover the whole cylinder, or to create many small copies.  To do this you can create a textured cylinder with an angle less than 360 degrees to hold the texture.  In this example we calculate the angle so that the output has the same aspect ratio.  The default `tex_extra` of zero for a single tile ensures that the image appears without an extra border.  
//   img = [
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   ];
//   h = 20;
//   r = 15;
//   ang = len(img[0])/len(img)*h/(2*PI*r)*360;
//   rotate_sweep([[r,-h/2],[r,h/2]], texture=img,
//                tex_reps=1,angle=ang, caps=true);
// Example(3D,VPR=[80.20,0.00,138.40],VPD=82.67,VPT=[6.88,7.29,1.77],NoAxes): Here we have combined the above model with a suitable cylinder.  Note that with a coarse texture like this you need to either match the `$fn` of the cylinder to the texture, or choose a sufficiently fine cylinder to avoid conflicting facets.  
//   img = [
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   ];
//   h = 20;
//   r = 15;
//   ang = len(img[0])/len(img)*h/(2*PI*r)*360;
//   rotate_sweep([[r,-h/2],[r,h/2]], texture=img,
//                tex_reps=1,angle=ang, caps=true);
//   cyl(r=r,h=27,$fn=128);
// Example(3D,VPR=[68.30,0.00,148.90],VPD=91.85,VPT=[-0.56,5.78,-0.90],NoAxes): Above we explicitly calculated the required angle to produce the correct aspect ratio.  Here we use `pixel_aspect` which produces an output whose average width has the desired aspect ratio.  
//   img = [
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   ];
//   rotate_sweep([[15,-10],[5,10]], texture=img,
//                tex_reps=[1,1], caps=true, pixel_aspect=1);
//   cyl(r1=16,r2=4,h=24,$fn=128);
// Example(3D,VPR=[96.30,0.00,133.50],VPD=54.24,VPT=[1.94,2.85,-0.47]): Here we apply the texture to a sphere using the automatic `pixel_aspect` to determine the angle.  Note that using {{spheroid()}} with the circum option eliminates artifacts arising due to mimatched faceting.  
//   img = [
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0,.5,.5, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
//      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
//      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   ];
//   arc = arc(r=10, angle=[-44,44],n=100);
//   rotate_sweep(arc, texture=img, tex_reps=[1,1],
//                caps=true, pixel_aspect=1);
//   spheroid(10,$fn=64,circum=true);