module LinEx(h=5,h2=0,h22,scale=0.85,scale2,twist,twistcap=1,slices,$d,$r=5,grad,grad2,mantelwinkel=0,center=false,rotCenter=false,end=0,fnEnd,name,help,n,convexity=5,lap=0.0001,scaleCenter=1,gradC,fn){


$info=is_undef(name)?is_undef($info)?false:$info:name;
$helpM=0;
$idxON=false;

lap=is_list(lap)?lap:[lap,lap];
ifn=$fn;
end=is_bool(end)?end?[1,1]:[0,0]:is_list(end)?end:[end,end];
fnEnd=fn?[fn,fn]:is_list(fnEnd)?fnEnd:[fnEnd,fnEnd];
name=is_undef(n)?name:n;

$r=is_undef($d)?$r:$d/2;
$d=2*$r;
h=max(0,h);
h22=abs(is_undef(h22)?is_list(h2)?h2[1]:h2:h22);
h2=abs(is_list(h2)?h2[0]:h2);    
hc=max(0,h-h2-h22);
twistcap=hc>0?is_list(twistcap)?twistcap:[twistcap,twistcap]:
[0,0];
gradC=is_undef(gradC)?gradC:is_list(gradC)?gradC:[gradC,gradC];
scaleCenter=is_undef(gradC)?scaleCenter:
                            is_list($r)?[($r.x-(hc/tan(gradC.x)))/$r.x,($r.y-(hc/tan(gradC.y)))/$r.y]:
                                        [($r-(hc/tan(gradC.x)))/$r,($r-(hc/tan(gradC.y)))/$r];

scale2=is_undef(grad2)?
    is_undef(grad)?
    is_undef(scale2)?h22?scale:1:scale2
    :is_list(grad)?is_list($r)?[($r[0]-(h22/tan(grad[0])))/($r[0]),($r[1]-(h22/tan(grad[1])))/($r[1])]:
                               [($r-(h22/tan(grad[0])))/($r),($r-(h22/tan(grad[1])))/($r)]:
                   is_list($r)?[($r.x-(h22/tan(grad)))/($r.x),($r.y-(h22/tan(grad)))/($r.y)]:
                                ($r-(h22/tan(grad)))/($r):
    is_list(grad2)?
        is_list($r)?[($r[0]-(h22/tan(grad2[0])))/($r[0]),($r[1]-(h22/tan(grad2[1])))/($r[1])]:[($r-(h22/tan(grad2[0])))/($r),($r-(h22/tan(grad2[1])))/($r)]:($r-(h22/tan(grad2)))/($r);
scale=h2?is_undef(grad)?scale:
    is_list(grad)?
        is_list($r)?[($r[0]-(h2/tan(grad[0])))/($r[0]),($r[1]-(h2/tan(grad[1])))/($r[1])]:
                    [($r-(h2/tan(grad[0])))/($r),($r-(h2/tan(grad[1])))/($r)]:
        is_list($r)?[($r.x-(h2/tan(grad)))/($r.x),($r.y-(h2/tan(grad)))/($r.y)]:
        ($r-(h2/tan(grad)))/($r):
     1;    
    


grad=h2?is_list(scale)?
          is_list($r)?[atan(h2/($r[0]-$r[0]*scale[0])),atan(h2/($r[1]-$r[1]*scale[1]))]:
                      [atan(h2/($r-$r*scale[0])),atan(h2/($r-$r*scale[1]))]:
          is_list($r)?[atan(h2/($r.x-$r.x*scale)),atan(h2/($r.y-$r.y*scale))]:
                      atan(h2/($r-$r*scale)):
    0;
    
grad2=h22?is_list(scale2)?
            is_list($r)?[atan(h22/($r[0]-$r[0]*scale2[0])),atan(h22/($r[1]-$r[1]*scale2[1]))]:
                        [atan(h22/($r-$r*scale2[0])),atan(h22/($r-$r*scale2[1]))]:
            is_list($r)?[atan(h22/($r.x-$r.x*scale2)),atan(h22/($r.y-$r.y*scale2))]:
                        atan(h22/($r-$r*scale2)):
         0;

mantelwinkel=is_undef(twist)?mantelwinkel:atan(twist*PI*$d/360/hc);    
twist=is_undef(twist)?mantelwinkel?360*tan(mantelwinkel)*hc/(2*PI*$r):0:twist;
segments=is_undef(slices)?0:slices*8;

/*
slices=is_undef(slices)?$preview?twist?fn:
                                       1:
                                 max(1,round(min(abs(twist)/hc*10,hc/l(2))) ):
                        slices;
    
*/
    
  InfoTxt("LinEx",
  [ "core h",str(hc,"mm - twist per mm= ",twist/(hc),"°, Fase für $d= ",$d,"mm ist ",grad,"°/",grad2,"° d=",vMult($d,scale),"/",vMult(vMult($d,scale2),scaleCenter),"mm - r= ",vMult($r,scale),"/",vMult(vMult($r,scale2),scaleCenter),"mm \n Mantelwinkel für $d/$r=",$d,"/",$r,"mm⇒ ",mantelwinkel,"° twist=",twist,"°")
  , scaleCenter!=1?str("\n scaled center $d/$r= ",vMult($d*scaleCenter),"/",vMult($r*scaleCenter)," base angle= ",
  is_list($r)&&is_list(scaleCenter)?[atan(hc/($r.x-scaleCenter.x*$r.x)),atan(hc/($r.y-scaleCenter.y*$r.y))]:
  is_list($r)?[atan(hc/($r.x-scaleCenter*$r.x)),atan(hc/($r.y-scaleCenter*$r.y))]:
  is_list(scaleCenter)?[atan(hc/($r-scaleCenter.x*$r)),atan(hc/($r-scaleCenter.y*$r))]:
  atan(hc/($r-vMult(scaleCenter,$r))),"°",", slices" ) : "slices",slices ],name); 
    

    
  Echo(str(name," LinEx Höhe center=",hc,"mm"),color="red",condition=hc<0);
    
    if(is_list(grad2)?$r*tan(min(grad2[0],grad2[1]))<(is_list($r)?[h22,h22]:h22)&&min(grad2[0],grad2[1])<90&&min(grad2[0],grad2[1])>0:$r*tan(grad2)<(is_list($r)?[h22,h22]:h22)&&grad2<90&&grad2>0)Echo(str(name," LinEx Höhe h22=",h22," mm zu groß oder winkel/$r zu klein min=",atan(h22/$r),"° max=",is_list(grad2)?$r*tan(min(grad2[0],grad2[1])):$r*tan(grad2),"mm"),color="red");
        
    if(is_list(grad)?min($r)*tan(min(grad))<h2&&min(grad)<90&&min(grad)>0:
                     min($r)*tan(grad)<h2&&grad<90&&grad>0)Echo(str(name," LinEx Höhe h2=",h2," mm zu groß oder winkel/$r zu klein min=",atan(h2/$r),"° max=",$r*tan(min(grad)),"mm"),color="red");    
    
    HelpTxt("LinEx",["h",h,"h2",h2,"h22",h22,"scale",scale,"scale2",scale2,"twist",twist,"twistcap",twistcap,"slices",slices,"$d",$d,"grad",grad,"grad2",grad2,", mantelwinkel",mantelwinkel,"center",center,"rotCenter",rotCenter,"end",end,"fnEnd",fnEnd,"name",name,"convexity",convexity,"lap",lap,"scaleCenter",scaleCenter],help);  
    


  rotate(center?0:rotCenter?-twist/2:-twist/2+(twistcap[0]&&hc?-twist/hc*h2:0))
    T(z=center?-h/2:0){
    
if(version()[0]>2021){
    union(){
    $info=false;
    $idx=is_undef($idx)?true:$idx;
    $noInfo=true;
    //capoben
    if(h22)T(z=h-h22)rotate(-twist/2)linear_extrude(h22+(end[1]?lap[1]:0),scale=scale2,twist=twistcap[1]?twist/(hc)*h22:0,convexity=convexity,slices=is_undef(slices)?slices:max(1,slices/hc*h22),$fn=0,segments=segments)scale(scaleCenter){
      $fn=ifn;
      children();
      }
    
    //capunten
    if(h2)Tz(h2)rotate(twist/2)mirror([0,0,1])linear_extrude(h2+(end[0]?lap[0]:0),scale=scale,twist=twistcap[0]?-twist/(hc)*h2:0,convexity=convexity,slices=is_undef(slices)?slices:max(1,slices/hc*h2),$fn=0,segments=segments){
      $fn=ifn;
      children();
      }
    }

    //center
    Tz(h2-lap[0]){
      //$idx=is_undef($idx)?0:$idx;
      $tab=is_undef($tab)?1:b($tab,false)+1;
      rotate(twist/2)linear_extrude(hc+lap[0]+lap[1],scale=scaleCenter,convexity=convexity,twist=twist,slices=slices,center=false,segments=segments)children();
    }
  } else {
      union(){
    $idx=true;
    //capoben
    if(h22)T(z=h-h22)rotate(-twist/2)linear_extrude(h22+(end[1]?lap[1]:0),scale=scale2,twist=twistcap[1]?twist/(hc)*h22:0,convexity=convexity,slices=max(1,slices/hc*h22),$fn=0)scale(scaleCenter){
      $fn=ifn;
      children();
      }
    
    //capunten
    if(h2)Tz(h2)rotate(twist/2)mirror([0,0,1])linear_extrude(h2+(end[0]?lap[0]:0),scale=scale,twist=twistcap[0]?-twist/(hc)*h2:0,convexity=convexity,slices=max(1,slices/hc*h2),$fn=0){
      $fn=ifn;
      children();
      }
    }

    //center
    Tz(h2-lap[0]){
      //$idx=is_undef($idx)?0:$idx;
      $tab=is_undef($tab)?1:b($tab,false)+1;
      rotate(twist/2)linear_extrude(hc+lap[0]+lap[1],scale=scaleCenter,convexity=convexity,twist=twist,slices=slices,center=false)children();
    }
  
  }
    
    
    if(end[0]){ // Ende Unten
    $idx=true;
     rotate(twist/2+(twistcap[0]?twist/(hc)*h2:0))rotate(sign(end[0])>+0?[-90,0,-90]:[-90,0,0]) RotEx(cut=true,grad=180,fn=fnEnd[0])scale(scale)rotate(sign(end[0])>0?90:0)children();
        }
     if(end[1]){ // Ende Oben
    $idx=true;
         Tz(h)rotate(-twist/2-(twistcap[1]?twist/(hc)*h22:0))rotate(sign(end[1])>+0?[-90,0,-90]:[-90,0,0])RotEx(cut=true,grad=-180,fn=fnEnd[1])
        scale(scale2*scaleCenter)rotate(sign(end[1])>0?90:0)children();
     }

    }
    MO(!$children);

}








}//fold // // ΔΔ Generator ΔΔ \ \\
{//fold // \∇∇ Basic Objects ∇∇/ //


/*
points=[[0,0,-2],for(i=[0:35])[sin(i*10),cos(i*10),0],for(i=[0:35])[sin(i*10),cos(i*10),5],[0,0,7]];
points1=[for(i=[0:36])[sin(i*10),cos(i*10),0]*1.5,for(i=[0:36])[sin(i*10),cos(i*10),5],for(i=[0:36])[sin(i*10)*0.75,cos(i*10)*1.5,10]];
pointsE1=[[0,0,-2],for(i=[0:35])[sin(i*10),cos(i*10),0],for(i=[0:35])[sin(i*10),cos(i*10),5]];
pointsE2=[for(i=[0:35])[sin(i*10),cos(i*10),0],for(i=[0:35])[sin(i*10),cos(i*10),5],[0,0,7]];

  
//Points(points1,loop=36,start=36*2);
//echo(points1[36]);
union(){
PolyH(points,loop=36,pointEnd=true,end=true,name="pointy");
T(10)PolyH(pointsE1,loop=36,pointEnd=1,end=true,name="point∇");
T(-10)PolyH(pointsE2,loop=36,pointEnd=2,end=true,name="pointΔ");//WIP
T(0,-10)PolyH(points1,loop=37,pointEnd=0,end=true);
T(0,10)PolyH(octa(5));
}
// */

// PolyH(concat([[0,0,-10]],kreis(rand=0,z=0,endPoint=false),[[0,0,10]]),fn,pointEnd=true);


/** \page Generator