function cubic_spline(points, N = 100) = let( //! Interpolate the list of points given to produce N points on a cubic spline that passes through points given.
        N = N - 1,
        n = len(points),
        ass1 = assert(n >= 3, "must be at least 3 points")0,

        dx = [for(i = [0 : n - 2]) points[i + 1].x - points[i].x], // x deltas
        ass2 = assert(min(dx) > 0, "X must strictly increase")0,

        //
        // A and C are diagonals above and below the main diagonal B, which is all 2's
        //
        A = [for(i = [0 : n - 3]) dx[i] / (dx[i] + dx[i + 1]), 0],
        C = [0, for(i = [0 : n - 3]) dx[i + 1] / (dx[i] + dx[i + 1]), 0],
        //
        // D are the target values on the right hand side of the equation
        //
        D = [0, for(i = [1 : n - 2]) 6 * ((points[i + 1].y - points[i].y) / dx[i] - (points[i].y - points[i - 1].y) / dx[i - 1]) / (dx[i] + dx[i - 1]), 0],
        //
        // Solve the tridiagonal equation using the Thomas algorithm
        //
        c = [for(i = 1, c = 0; i < n; c = C[i] / (2 - c * A[i - 1]), i = i + 1) c, 0],
        d = [for(i = 1, d = 0; i < n; d = (D[i] - d * A[i - 1]) / (2 - c[i - 1] * A[i - 1]), i = i + 1) d, 0],
        M = [for(i = n - 2, x = 0; i >= 0; x = d[i] - c[i] * x, i = i - 1) x, 0],
        //
        // Calculate the coefficients of each cubic curve
        //
        coefficients = [for(i = [0 : n - 2], dx2 = sqr(dx[i]), j = n - 1 - i)
                            [(M[j - 1] - M[j]) * dx2 / 6,
                             M[j] * dx2 / 2,
                             points[i + 1].y - points[i].y - (M[j - 1] + 2 * M[j]) * dx2 / 6,
                             points[i].y]
                       ],
        //
        // Use the coefficients to interpolate between the points
        //
        x0 = points[0].x,
        x1 = points[n - 1].x,
        spline = [for(i = 0, j = 0, z = 0, x = x0; i <= N + 1;
                      x = x0 + (x1 - x0) * i / N,
                      j = i < N - 1 && x > points[j + 1].x ? j + 1 : j,
                      z = (x - points[j].x) / dx[j],
                      i = i + 1,
                      C = coefficients[j]
                     ) if(i) [x, (((C[0] * z) + C[1]) * z + C[2]) * z + C[3]]
                 ]
    ) spline;