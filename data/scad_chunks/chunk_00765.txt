module psu(type) { //! Draw a power supply
    vitamin(str("psu(", type[0], "): PSU ", psu_name(type)));

    for(part = psu_accessories(type))
        vitamin(part);

    l = psu_length(type);
    w = psu_width(type);
    h = psu_height(type);
    faces = psu_faces(type);
    left = psu_left_bay(type);
    right = psu_right_bay(type);
    $fa = fa; $fs = fs;

    if(len(faces) < 2)
        translate_z(h / 2)
            color("silver") cube([l, w, h], center = true);
    else {
        for(i = [0 : 1 : len(faces) - 1]) {
            f = faces[i];
            t = psu_face_thickness(f);
            xw = [l, l - left - right, w, w, l, l - left - right][i];
            yw = [w, w, h, h, h, h][i];
            xo = [0, left / 2 - right / 2, 0, 0, 0, left / 2 - right / 2][i];
            fan = psu_face_fan(f);
            iec = psu_face_iec(f);
            switch = psu_face_switch(f);
            vents = psu_face_vents(f);

            multmatrix(psu_face_transform(type, i))
                translate([xo, 0, -t]) {
                    color("silver") linear_extrude(t)
                        union() {
                            difference() {
                                square([xw, yw], center = true);

                                cutouts = psu_face_cutouts(f);
                                if(cutouts)
                                    for(cutout = cutouts)
                                        polygon([for(p = cutout) p]);

                                for(h = psu_face_holes(f))
                                    translate([h.x, h.y])
                                        hull() {
                                            drill(psu_screw(type) == false ? psu_screw_hole_radius(type) : screw_pilot_hole(psu_screw(type)), 0);
                                            if (is_list(h[2]))
                                                translate([h[2].x, h[2].y])
                                                    drill(psu_screw(type) == false ? psu_screw_hole_radius(type) : screw_pilot_hole(psu_screw(type)), 0);
                                        }

                                g = psu_face_grill(f);
                                if(g) {
                                    list = is_list(g);
                                    hole = list ? g[0] : 4.5;
                                    gap = list ? g[1] : 1.5;
                                    fn = list ? g[2] : 0;
                                    margins = list ? g[3] : [6, 6, 6, 6];
                                    avoid = list ? g[4] : [];
                                    mx1 = margins[0];
                                    mx2 = margins[1];
                                    my1 = i == f_top && psu_face_grill(faces[f_back]) ? 0 : margins[2];
                                    my2 = i == f_back && psu_face_grill(faces[f_top]) ? 0 : margins[3];
                                    translate([(mx1 - mx2) / 2, (my2 - my1) / 2])
                                        psu_grill(xw - mx1 - mx2, yw - my1 - my2, grill_hole = hole, grill_gap = gap, fn = fn, avoid = avoid);
                                }
                                if(fan)
                                    translate([fan.x, fan.y]) intersection() {
                                        fan_holes(fan.z, h = 0);

                                        difference() {
                                            square(big, true);

                                            fan_guard(fan.z, thickness = 0, grill = true);
                                        }
                                    }
                                if(iec)
                                    translate([iec.x, iec.y])
                                        rotate(iec.z)
                                            iec_holes(iec[3], 0);
                                if(switch)
                                    translate([switch.x, switch.y])
                                        rotate(switch.z)
                                            rocker_hole(switch[3], 0);
                                if(vents)
                                    for(i = [0 : len(vents) - 1]) {
                                        // vent is of form: [ [pos.x, pos.y, angle], [size.x, size.y], corner radius ]
                                        vent = vents[i];
                                        translate([vent[0].x, vent[0].y])
                                            rotate(vent[0].z)
                                                rounded_square(vent[1], vent[2]-eps, center = true);
                                    }
                             }
                        }

                    not_on_bom() no_explode() {
                        if(fan)
                            translate([fan.x, fan.y, -fan_depth(fan.z) / 2]) {
                                fan(fan.z);

                                screw = alternate_screw(hs_cs_cap, fan_screw(fan.z));
                                fan_hole_positions(fan.z)
                                    translate_z(t + eps)
                                        screw(screw, 8);

                            }

                        if(iec)
                            translate([iec.x, iec.y, t])
                                rotate(iec.z)
                                    iec_assembly(iec[3], t);

                        if(switch)
                            translate([switch.x, switch.y, t])
                                rotate(switch.z)
                                    rocker(switch[3]);
                    }
                }
        }
    }
    // Special case for lighting type PSUs with terminals at the end
    terminals = psu_terminals(type);
    if(terminals) {
        ft = psu_face_thickness(faces[f_front]);
        bt = psu_face_thickness(faces[f_back]);
        rt = psu_face_thickness(faces[f_right]);
        lt =  psu_face_thickness(faces[f_left]);
        cutout = psu_face_cutouts(faces[f_left])[0];
        z = psu_terminal_block_z(type);
        pcb =  [l - right - rt, w - ft - bt, 1.6];
        heatsink_offset = 13.5;
        color("#FCD67E")
            translate([(-right - rt) / 2, (ft - bt) / 2, z - pcb.z])
                linear_extrude(pcb.z)
                    difference() {
                        square([pcb.x, pcb.y], center = true);

                        translate([-pcb.x / 2, -pcb.y / 2])
                            square(16, center = true);
                    }

        tab_w = w / 2 + cutout[2].x;
        // if the cutout is too wide, then don't draw earth strap, pillar and screw
        if (tab_w - bt > 0) {
            // earth strap
            color("silver")
                translate([-l / 2, w / 2 - tab_w, z])
                    cube([left, tab_w - bt, lt]);

            // Earth pillar and screw
            earth_inset = 4.5;
            earth_d = 5;
            translate([-l / 2 + earth_inset, w / 2 - tab_w / 2]) {
                color("silver")
                    cylinder(d = earth_d, h = z - pcb.z);

                translate_z(z + lt)
                    not_on_bom() no_explode()
                        spring_washer(M3_washer)
                            screw(M3_pan_screw, 8);
            }
        }

        // terminal block
        tb = terminals[2];
        if(tb)
           translate([-l / 2, w / 2 - terminals.y, z])
                terminal_block(tb, terminals[0]);

        // Heatsink
        //
        heatsink_cutout = psu_face_cutouts(faces[f_right])[0];
        if(right && heatsink_cutout) {
            z_top = heatsink_cutout[1].y + h / 2;
            length = heatsink_cutout[2].x + w / 2 - 1.5;

            color("silver")
                translate([l / 2, -w / 2])
                    rotate([90, 0, 180])
                        linear_extrude(length) {
                            translate([right + rt, z_top])
                                rotate(135)
                                    square([rt, right * sqrt(2)]);

                            square([rt,  z_top - right]);

                            translate([rt, z_top - right])
                                sector(rt, 135, 180);
                        }
        }
    }
    // PCB
    pcb = psu_pcb(type);
    if (pcb) {
        translate(pcb[0])
            pcb(pcb[1]);
    }

}