function _sort_pairs0(arr) =
    len(arr)<=1 ? arr : 
    let(
        pivot   = arr[floor(len(arr)/2)][0],
        lesser  = [ for (y = arr) if (y[0].x  < pivot.x || (y[0].x==pivot.x && y[0].y<pivot.y)) y ],
        equal   = [ for (y = arr) if (y[0] == pivot) y ],
        greater = [ for (y = arr) if (y[0].x > pivot.x || (y[0].x==pivot.x && y[0].y>pivot.y)) y ]
    ) 
    concat( _sort_pairs0(lesser), equal, _sort_pairs0(greater) );


// Function: vnf_boundary()
// Synopsis: Returns the boundary of a VNF as a list of paths
// SynTags: VNF
// Topics: VNF Manipulation
// See Also: vnf_halfspace(), vnf_merge_points()
// Usage:
//   boundary = vnf_boundary(vnf, [merge=], [idx=]);
// Description:
//   Returns the boundary of a VNF as a list of paths.  **The input VNF must not contain duplicate points.**  By default, vnf_boundary() calls {{vnf_merge_points()}}
//   to remove duplicate points.  Note, however, that this operation can be slow.  If you are **certain** there are no duplicate points you can
//   set `merge=false` to disable the automatic point merge and save time.  The result of running on a VNF with duplicate points is likely to
//   be incorrect or invalid; it may produce obscure errors.   
//   .
//   The output is a list of closed 3D paths.  If the VNF has no boundary then the output is `[]`.  The boundary path(s) are
//   traversed in the same direction as the edges in the original VNF.  
//   .
//   It is sometimes desirable to have the boundary available as an index list into the VNF vertex list.  However, merging the points in the VNF changes the 
//   VNF vertex point list.  If you set `merge=false` you can also set `idx=true` to get an index list.  As noted above, you must be certain
//   that your in put VNF has no duplicate vertices, perhaps by running {{vnf_merge_points()}} yourself on it.  With `idx=true`
//   the output consists of indices into the VNF vertex list, which enables you to associate the vertices on the boundary path with the original VNF.
// Arguments:
//   vnf = input vnf
//   ---
//   merge = set to false to suppress the automatic invocation of {{vnf_merge_points()}}.  Default: true
//   idx = if true, return indices into VNF vertices instead of actual 3D points.  Must set `merge=false` to enable this.  Default: false
// Example(3D,NoAxes,VPT=[7.06325,-20.8414,20.1803],VPD=292.705,VPR=[55,0,25.7]):  In this example we know that the bezier patch VNF has no duplicate vertices, so we do not need to run {{vnf_merge_points()}}.
//   patch = [
//        // u=0,v=0                                         u=1,v=0
//        [[-50,-50,  0], [-16,-50,  20], [ 16,-50, -20], [50,-50,  0]],
//        [[-50,-16, 20], [-16,-16,  20], [ 16,-16, -20], [50,-16, 20]],
//        [[-50, 16, 20], [-16, 16, -20], [ 16, 16,  20], [50, 16, 20]],
//        [[-50, 50,  0], [-16, 50, -20], [ 16, 50,  20], [50, 50,  0]],
//        // u=0,v=1                                         u=1,v=1
//   ];                
//   bezvnf = bezier_vnf(patch);
//   boundary = vnf_boundary(bezvnf);
//   vnf_polyhedron(bezvnf);
//   stroke(boundary,color="green");
// Example(3D,NoAxes,VPT=[-11.1252,-19.7333,8.39927],VPD=82.6686,VPR=[71.8,0,335.3]): An example with two path components on the boundary.  The output from {{vnf_halfspace()}} can contain duplicate vertices, so we must invoke {{vnf_merge_points()}}.  
//   vnf = torus(id=20,od=40,$fn=28);
//   cutvnf=vnf_halfspace([0,1,0,0],
//            vnf_halfspace([-1,.5,-2.5,-12], vnf, closed=false),
//            closed=false);
//   vnf_polyhedron(cutvnf);
//   boundary = vnf_boundary(vnf_merge_points(cutvnf));
//   stroke(boundary,color="green");