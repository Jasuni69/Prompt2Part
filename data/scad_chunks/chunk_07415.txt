module Coil(
r=20,
d=5,
r2,
od,
id,
grad=3*360,
p,
pitch=10,
h,
points,
twist=0,
scale=1,
fn,fn2,fs=fs,fa,
center=true,
rot=0,
open=true,//open Path
rev=true,
convexity=15,
name,
help){

d=is_num(od)&&is_num(id)?(od-id)/2 : d;
r=is_undef(points)?is_num(od)?(od-d)/2:is_num(id)?(id+d)/2:r:r;
r2=is_undef(r2)?r:r2;
fn=is_undef(fn)||fn<1?fs2fn(fs=fs,r=max(abs(r),abs(r2)),fa=fa,minf=36):fn;
fn2=is_undef(fn2)||fn<4?fs2fn(fs=fs,r=d/2,minf=12):fn2;
p=is_undef(p)?pitch:p;
$d=d;
Echo("Coil using points - od, id, h or d can't compute",color="warning",condition=points&&od||points&&id);
Echo("Coil intersecting",color="warning",condition=!points&&norm([(r-r2)/grad*360,pitch])<d);
scale=is_list(scale)?scale:[scale,scale];

ipoints=is_undef(points)?arc(r=d/2,fn=fn2-1,deg=360-360/fn2,z=0,rot=rot):points;
grad=is_undef(grad)?(h-d/2-d/2*scale.y)/p*360
                   :grad;

pitch=is_undef(h)?p:(h-d/2-d/2*scale.y)/grad*360;
h=abs(pitch*grad/360+d/2+d/2*scale.y);
Echo("Coil h < d",color="warning",condition=h<d);

iFN=ceil(fn*abs(grad)/360*max(1,twist/360/3));

path=[for(i=rev?[iFN:-1:0]:[0:iFN])
let(deg=grad/iFN,
p=is_undef(p)?pitch/360*abs(deg):p/360*abs(deg),
rDiff=(r2-r)/iFN
)
[sin(i*deg)*(r+rDiff*i),cos(i*deg)*(r+rDiff*i),p*i]];

translate([0,0,center?b(center,false)<0?-h/2+d/2
                                       :0
                      :d/2*(rev?scale.y:1)])
  PolyH(
          pathPoints(ipoints,path,twist=twist,scale=scale,open=open),
        loop=len(ipoints),name=false,convexity=convexity);
      
InfoTxt("Coil",concat(["length",pathLength(path),"heigth(h)",h,"grad",grad,"turns",grad/360],pitch?["pitch",pitch]:[],r==r2?[]:["endRadius r2",r2] ),name);
HelpTxt("Coil",["r",r,"d",d,"r2",r2,"od",od,"id",id,"grad",grad,"pitch",is_undef(p)?pitch:p,"h",h,"points","kreis(d=d)","twist",twist,"scale",scale,"fn",fn,"fn2",fn2,"fs",fs,"fa",fa,"center",center,"rot",rot,"open",open,"convexity",convexity],help);
}