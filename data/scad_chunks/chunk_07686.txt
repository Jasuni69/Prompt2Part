module Bezier(
p0=[+0,+10,0],
p1=[15,-10,0],
p2,
p3=[0,-10,0],
w=1,//weighting
max=1.0,
min=+0.0,
fn=50,
fn2=fn,
ex,//extrude X
pabs=false, //p1/p2 absolut/relativ p0/p3
messpunkt=true,
mpRot,
twist=0,
scale=1,
hull=true,
points,
d,
name,
help

){
   mpRot=is_undef(mpRot)?search(["RotEx"],parentList())[0]?true:
                            mpRot:
                    mpRot;
    //echo(search(["RotEx"],parentList())[0],parentList());
  
  messpunkt=is_bool(messpunkt)?messpunkt?pivotSize:0:messpunkt;//$info?messpunkt:0;
  3D=is_list(points)||d&&!$children?true:false;
  p0=v3(p0);
  p3=v3(p3);  
  p1=v3(pabs?p1*w:v3(p1)*w+p0);  
  p2=is_undef(p2)?p1:v3(pabs?p2*w:v3(p2)*w+p3);
  
 $fn=hull?fn:$fn;
 $fa=fa;
 $fs=fs; 


    if($children){
        twist=v3(twist);
        $helpM=0;
        $info=is_undef(name)?is_undef($info)?false:$info:name; 
        step=((max-min)/fn);
        for (t=[min:step:max-step]){
            
            $rot=vektorWinkel(Bezier(t,p0,p1,p2,p3),Bezier(t+step,p0,p1,p2,p3))+twist/(max-step)*t;
            $tab=true;
            $idx=t;
            if (hull) Color(1/(max-step)*t,$idxON=false)hull(){
                translate(Bezier(t,p0,p1,p2,p3))rotate($rot)scale(1-(1-scale)/(max-step)*t)children();
                 union(){
                    $idx=t+step;
                    $rot=t>=max-step?vektorWinkel(p2,p3)+twist: // last segment
                                     vektorWinkel(Bezier(t+step,p0,p1,p2,p3),Bezier(t+step*2,p0,p1,p2,p3))+twist/(max-step)*(t+step);
                    translate(Bezier(t+step,p0,p1,p2,p3))rotate($rot)scale(1-(1-scale)/(max-step)*(t+step))children();
                }
             }
            else Color(1/(max-step)*t,$idxON=false)
              translate(Bezier(t,p0,p1,p2,p3))rotate($rot)scale(1-(1-scale)/(max-step)*t)children();
            
        }
    
}
    if(!$children&&3D==false){
    if (is_undef(ex)) polygon([for (t=[min:((max-min)/fn):(max+(max-min)/fn)-((max-min)/fn)])Bezier(t,
            [p0[0],p0[1]],
            [p1[0],p1[1]],        
            [p2[0],p2[1]],       
            [p3[0],p3[1]]        
        )]);
        
    else polygon(concat(
      [[0,p0[1]]],
      [for (t=[min:((max-min)/fn):(max+(max-min)/fn)-((max-min)/fn)])Bezier(t,
        [p0[0]+ex,p0[1]],
        [p1[0]+ex,p1[1]],        
        [p2[0]+ex,p2[1]], 
        [p3[0]+ex,p3[1]] )],
      [[0,p3[1]]]
      ));        
        
 
    }
    
    if(3D){
      points=is_undef(points)?kreis(d=d,rand=0,fn=fn2,z=0):
                              len(points[0])==3?points:
                                                [for(iPoint=points)concat(iPoint,0)];

      loop=len(points);
      path=[for (t=[min:((max-min)/fn):(max+(max-min)/fn)-((max-min)/fn)])Bezier(t,p0,p1,p2,p3)];

     PolyH(pathPoints(points=points,path=path,scale=scale,twist=twist),loop=loop,name=false);

    }
    
    
    
    if(messpunkt){
        ex=is_undef(ex)?0:ex;
         vpr=mpRot?[90,0,0]:$vpr;
        Pivot(mpRot?[p0[0]+ex,0,p0[1]]:p0+[ex,0,0],messpunkt,txt="p0",vpr=vpr);
        Pivot(mpRot?[p1[0]+ex,0,p1[1]]:p1+[ex,0,0],messpunkt/2,txt=str("p1",p1==p2?"     ":""),vpr=vpr);
        Pivot(mpRot?[p2[0]+ex,0,p2[1]]:p2+[ex,0,0],messpunkt/2,txt="p2",vpr=vpr);
        Pivot(mpRot?[p3[0]+ex,0,p3[1]]:p3+[ex,0,0],messpunkt,txt="p3",vpr=vpr);
      d=b(messpunkt,false)/20;
        %Line(mpRot?[p0[0]+ex,0,p0[1]]:p0+[ex,0,0],mpRot?[p1[0]+ex,0,p1[1]]:p1+[ex,0,0],d=d,center=true);
        %Line(mpRot?[p3[0]+ex,0,p3[1]]:p3+[ex,0,0],mpRot?[p2[0]+ex,0,p2[1]]:p2+[ex,0,0],d=d,center=true);
        
        }
    
    if(name&&!$children)Echo("No Bezier object using polygon!",color="green");

HelpTxt("Bezier",[   
  "p0",p0,
  "p1",p1,
  "p2",p2,
  "p3",p3,
  "w/*weighting*/",w,
  "max",max,
  "min",min,
  "fn",fn,
  "fn2",fn2,
  "ex/*extrude X*/",ex,
  "pabs/*p1/p2 absolut/relativ */",pabs, 
  "messpunkt",messpunkt,
  "mpRot",mpRot,
  "twist",twist,
  "hull",hull,
  "points",points?"points":undef,
  "d/*for 3D*/",d,
  "name",name]
  ,help);
}