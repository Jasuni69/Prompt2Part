module cuboid(
	size=[1,1,1],
	p1=undef, p2=undef,
	chamfer=undef,
	fillet=undef,
	edges=EDGES_ALL,
	trimcorners=true,
	align=[0,0,0],
	center=undef
) {
	size = scalar_vec3(size);
	if (is_def(p1)) {
		if (is_def(p2)) {
			translate([for (v=array_zip([p1,p2],fill=0)) min(v)]) {
				cuboid(size=vabs(p2-p1), chamfer=chamfer, fillet=fillet, edges=edges, trimcorners=trimcorners, align=V_ALLPOS);
			}
		} else {
			translate(p1) {
				cuboid(size=size, chamfer=chamfer, fillet=fillet, edges=edges, trimcorners=trimcorners, align=V_ALLPOS);
			}
		}
	} else {
		majrots = [[0,90,0], [90,0,0], [0,0,0]];
		
		// Not the most elegant, but should work fine.
		// Size for edge E can be ignored if there are only zeros in both edges !E
		relevantsize = [for(a=[0:2]) if(max(edges[(a+1)%3]+edges[(a+2)%3])>0) size[a]];
		
		if (chamfer != undef && len(relevantsize) > 0) assertion(chamfer <= min(relevantsize)/2, "chamfer must be smaller than half the cube width, length, or height.");
		if (fillet != undef && len(relevantsize) > 0 )  assertion(fillet <= min(relevantsize)/2, "fillet must be smaller than half the cube width, length, or height.");
		algn = (!is_def(center))? (is_scalar(align)? align*V_UP : align) : (center==true)? V_CENTER : V_ALLPOS;
		translate(vmul(size/2, algn)) {
			if (chamfer != undef) {
				isize = [for (v = size) max(0.001, v-2*chamfer)];
				if (edges == EDGES_ALL && trimcorners) {
					hull() {
						cube([size[0], isize[1], isize[2]], center=true);
						cube([isize[0], size[1], isize[2]], center=true);
						cube([isize[0], isize[1], size[2]], center=true);
					}
				} else {
					difference() {
						cube(size, center=true);

						// Chamfer edges
						for (i = [0:3], axis=[0:2]) {
							if (edges[axis][i]>0) {
								translate(vmul(EDGE_OFFSETS[axis][i], size/2)) {
									rotate(majrots[axis]) {
										zrot(45) cube([chamfer*sqrt(2), chamfer*sqrt(2), size[axis]+0.01], center=true);
									}
								}
							}
						}

						// Chamfer triple-edge corners.
						if (trimcorners) {
							for (za=[-1,1], ya=[-1,1], xa=[-1,1]) {
								if (corner_edge_count(edges, [xa,ya,za]) > 2) {
									translate(vmul([xa,ya,za]/2, size-[1,1,1]*chamfer*4/3)) {
										rot(from=V_UP, to=[xa,ya,za]) {
											upcube(chamfer*3);
										}
									}
								}
							}
						}
					}
				}
			} else if (fillet != undef) {
				sides = quantup(segs(fillet),4);
				sc = 1/cos(180/sides);
				isize = [for (v = size) max(0.001, v-2*fillet)];
				if (edges == EDGES_ALL) {
					minkowski() {
						cube(isize, center=true);
						if (trimcorners) {
							rotate_extrude(convexity=2,$fn=sides) {
								polygon([for (i=[0:1:sides/2]) let(a=i*360/sides-90) fillet*sc*[cos(a),sin(a)]]);
							}
						} else {
							intersection() {
								zrot(180/sides) cylinder(r=fillet*sc, h=fillet*2, center=true, $fn=sides);
								rotate([90,0,0]) zrot(180/sides) cylinder(r=fillet*sc, h=fillet*2, center=true, $fn=sides);
								rotate([0,90,0]) zrot(180/sides) cylinder(r=fillet*sc, h=fillet*2, center=true, $fn=sides);
							}
						}
					}
				} else {
					difference() {
						cube(size, center=true);

						// Round edges.
						for (i = [0:3], axis=[0:2]) {
							if (edges[axis][i]>0) {
								difference() {
									translate(vmul(EDGE_OFFSETS[axis][i], size/2)) {
										rotate(majrots[axis]) cube([fillet*2, fillet*2, size[axis]+0.1], center=true);
									}
									translate(vmul(EDGE_OFFSETS[axis][i], size/2 - [1,1,1]*fillet)) {
										rotate(majrots[axis]) zrot(180/sides) cylinder(h=size[axis]+0.2, r=fillet*sc, center=true, $fn=sides);
									}
								}
							}
						}

						// Round triple-edge corners.
						if (trimcorners) {
							for (za=[-1,1], ya=[-1,1], xa=[-1,1]) {
								if (corner_edge_count(edges, [xa,ya,za]) > 2) {
									difference() {
										translate(vmul([xa,ya,za], size/2)) {
											cube(fillet*2, center=true);
										}
										translate(vmul([xa,ya,za], size/2-[1,1,1]*fillet)) {
											zrot(180/sides) sphere(r=fillet*sc*sc, $fn=sides);
										}
									}
								}
							}
						}
					}
				}
			} else {
				cube(size=size, center=true);
			}
		}
	}
}



// Module: cube2pt()
// Status: DEPRECATED, use `cuboid(p1,p2)` instead.
//
// Usage:
//   cube2pt(p1,p2)
//
// Description:
//   Creates a cube between two points.
//
// Arguments:
//   p1 = Coordinate point of one cube corner.
//   p2 = Coordinate point of opposite cube corner.