function mask2d_roundover(r, inset=0, mask_angle=90, excess=0.01, clip_angle, flat_top, quarter_round=false, d, h, height, cut, joint, anchor=CENTER, spin=0) =
    assert(num_defined([r,d,cut,joint])<=1, "Must define at most one of r, d, cut and joint")
    assert(num_defined([h,height])<=1, "Must define at most one of h and height")
    assert(all_nonnegative([excess]), "excess must be a nonnegative value")
    assert(is_finite(mask_angle) && mask_angle>0 && mask_angle<180)
    assert(is_finite(inset)||is_vector(inset,2))
    assert(is_bool(quarter_round))
    let(flat_top=default(flat_top, quarter_round))
    assert(is_bool(flat_top))
    assert(is_undef(clip_angle) || (is_finite(clip_angle) && clip_angle<=90 && clip_angle>(quarter_round?90:mask_angle)-90),
           str("\nclip_angle must be between ",(quarter_round?90:mask_angle)-90," and 90"))
    let(
        inset = is_list(inset)? inset : [inset,inset],
        r = get_radius(r=r,d=d,dflt=undef),
        dummy2=assert(is_def(r) || !quarter_round,"Must give r / d when quarter_round is true"),
        h = u_add(one_defined([h,height],"h,hight",dflt=undef),flat_top || mask_angle>=90?0:-inset.x*cos(mask_angle)),
        // compute [joint length, radius] for different types of input
        rcalc = is_def(r) ?  assert(all_positive([r]), "r / d must be a positive value") r
              : is_def(joint) ? assert(all_positive([joint]), "joint must be a positive value") joint*tan(mask_angle/2)
              : is_def(cut) ? assert(all_positive([cut]),"cut must be a positive value") cut/(1/sin(mask_angle/2)-1)
              : undef,
        jra = is_def(clip_angle)?
                      assert(num_defined([rcalc,h])==1, "When clip_angle is given must give exactly one of r, joint, h/height, or cut")
                      let(  r = is_def(rcalc) ? rcalc
                              : h/(sin(mask_angle)/tan(mask_angle/2)-1+sin(clip_angle))
                         )
                      [r/tan(mask_angle/2), r, clip_angle]
            : num_defined([rcalc,h])==2 ? let( a=-sin(mask_angle)/tan(mask_angle/2)+1)
                                           assert(h/rcalc + a <= 1,str("\nheight cannot be larger than ", rcalc*(1-a)))
                                          [rcalc/tan(mask_angle/2) ,rcalc, asin(h/rcalc + a)]
            : is_def(rcalc) ? [rcalc/tan(mask_angle/2), rcalc, 90]
            : [ each h/sin(mask_angle)*[1,tan(mask_angle/2)], 90],
        dist=jra[0],
        radius=jra[1],
        clip_angle = jra[2], 
        
        clipshift = clip_angle==90 ? [0,0]
                  : let( v=1-cos(90-clip_angle))
                    radius*[v/tan(mask_angle),v],
        quarter_round_top = approx(mask_angle,90) ? 0
                          : radius/tan(mask_angle),
        extra = radius/20,  // Exact solution is tangent, which will make bad geometry, so insert an offset factor
        quarter_round_shift = !quarter_round || mask_angle<=90 ? 0
                            : radius/sin(180-mask_angle)-radius+extra,
        outside_corner = _inset_corner(
                            quarter_round ?
                            [
                              [quarter_round_top,radius],
                              [0,0],
                              [radius+quarter_round_top+quarter_round_shift,0]
                              ]
                           :
                            [
                              dist*[cos(mask_angle),sin(mask_angle)],
                              [0,0],
                              [dist,0]
                            ],
                            mask_angle, inset, excess, flat_top),
        // duplicates arise at one or both ends if excess and inset are both zero there
        cornerpath = !quarter_round ? outside_corner[1]
                   : mask_angle<=90 ? outside_corner[1]+[[0,0],[quarter_round_top,0],[0,0]]
                   : [ outside_corner[1][0]+[quarter_round_shift,0],
                       [outside_corner[1][0].x+quarter_round_shift,inset.y],
                       outside_corner[1][2]
                     ],
        dummy=assert(last(cornerpath).x>=0,str("inset.y is too large to fit roundover at angle ",mask_angle)),
        arcpath = let (basic = arc(corner=cornerpath, r=radius))
                  clip_angle==90 ? basic
                :
                  let(
                       cutind = [for(i=idx(basic)) if (basic[i].y-inset.y < clipshift.y) i],
                       ipt = line_intersection([basic[cutind[0]-1],basic[cutind[0]]], [[0,clipshift.y+inset.y],[1,clipshift.y+inset.y]])
                  )
                  move(-clipshift, [ each select(basic, 0,cutind[0]), ipt]),
          path = deduplicate([
                             [last(arcpath).x,-excess],
                             outside_corner[0][1],
                             move(-clipshift, outside_corner[0][2]),
                             each arcpath,
                             [last(arcpath).x,inset.y]
                           ]
                          ,closed=true)
    ) reorient(anchor,spin, two_d=true, path=path, extent=false, p=path);



// Function&Module: mask2d_teardrop()
// Synopsis: Creates a 2D teardrop shape with specified max angle from vertical.
// SynTags: Geom, Path
// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D), FDM Optimized
// See Also: corner_profile(), edge_profile(), face_profile()
// Usage: As Module
//   mask2d_teardrop(r|d=, [angle], [inset] [mask_angle], [excess], [cut=], [joint=], [h=|height=]) [ATTACHMENTS];
// Usage: As Function
//   path = mask2d_teardrop(r|d=, [angle], [inset], [mask_angle], [excess], [cut=], [joint=], [h=|height=]);
// Description:
//   Creates a 2D teardrop mask shape that is useful for extruding into a 3D mask for an edge.
//   Conversely, you can use that same extruded shape to make an interior teardrop fillet between two walls.
//   As a 2D mask, this is designed to be differenced away from the edge of a shape that with its corner at the origin and one edge on the X+ axis and the other mask_angle degrees counterclockwise from the X+ axis.  
//   If called as a function, returns a 2D path of the outline of the mask shape.
//   This is particularly useful to make partially rounded bottoms, that don't need support to print.
//   The roundover can be specified by radius, diameter, height, cut, or joint length.
//   ![Types of Roundovers](images/rounding/figure_1_1.png)
// Arguments:
//   r = Radius of the rounding.
//   angle = The angle from vertical of the flat section.  Must be between mask_angle-90 and 90 degrees.  Default: 45.  
//   inset = Optional bead inset size perpendicular to edges.  Default: 0
//   mask_angle = Number of degrees in the corner angle to mask.  Default: 90
//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape. Default: 0.01
//   ---
//   d = Diameter of the rounding.
//   h / height = Mask height excluding inset and excess.  Given instead of r or d when you want a consistent mask height, no matter what the mask angle.
//   cut = Cut distance.  IE: How much of the corner to cut off.  See [Types of Roundovers](rounding.scad#section-types-of-roundovers).
//   joint = Joint distance.  IE: How far from the edge the roundover should start.  See [Types of Roundovers](rounding.scad#section-types-of-roundovers).
//   flat_top = If true, the top inset of the mask will be horizontal instead of angled by the mask_angle.  Default: true.
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
// Example(2D): 2D Teardrop Mask
//   mask2d_teardrop(r=10,$fn=64);
// Example(2D): 2D Teardrop Mask for acute angle
//   mask2d_teardrop(r=10, mask_angle=75,$fn=64);
// Example(2D): 2D Teardrop Mask for obtuse angle, specifying height
//   mask2d_teardrop(h=10, mask_angle=115,$fn=128);
// Example(2D): Increasing Excess
//   mask2d_teardrop(r=10, mask_angle=75, excess=2);
// Example(2D): Using a Custom Angle
//   mask2d_teardrop(r=10,angle=30,$fn=128);
// Example(2D): With an acute mask_angle you can choose an angle of zero:
//   mask2d_teardrop(r=10,mask_angle=44,angle=0);
// Example(2D): With an acute mask_angle you can even choose a negative angle
//   mask2d_teardrop(r=10,mask_angle=44,angle=-15);
// Example(2D): With an obtuse angle you need to choose a larger angle.  Here we add inset.
//   mask2d_teardrop(h=10, mask_angle=135,angle=60, inset=2);
// Example(2D): Same thing with `flat_top=true`.  
//   mask2d_teardrop(h=10, mask_angle=135,angle=60, inset=2, flat_top=true);
// Example: Masking by Edge Attachment
//   diff()
//   cube([50,60,70],center=true)
//       edge_profile(BOT)
//           mask2d_teardrop(r=10, angle=40);
// Example: Making an interior teardrop fillet
//   %render() difference() {
//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);
//       cube(310, anchor=BOT+LEFT);
//   }
//   xrot(90)
//       linear_extrude(height=30, center=true)
//           mask2d_teardrop(r=10);