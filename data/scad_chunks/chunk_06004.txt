module hirth(n, ir, or, id, od, tooth_angle=60, cone_angle=0, chamfer, rounding, base=1, crop=false,skew=0, rot=false, orient,anchor,spin)
{
  ir = get_radius(r=ir,d=id);
  or = get_radius(r=or,d=od);
  dummy = assert(all_positive([ir]), "ir/id must be a positive value")
          assert(all_positive([or]), "or/od must be a positive value")
          assert(is_int(n) && n>1, "n must be an integer larger than 1")
          assert(is_finite(skew) && abs(skew)<=1, "skew must be a number between -1 and 1")
          assert(ir<or, "inside radius (ir/id) must be smaller than outside radius (or/od)")
          assert(all_positive([tooth_angle]) && tooth_angle<360*(n-1)/2/n, str("tooth angle must be between 0 and ",360*(n-1)/2/n," for spline with ",n," teeth."))
          assert(num_defined([chamfer,rounding]) <=1, "Cannot define both chamfer and rounding")
          assert(is_undef(chamfer) || all_nonnegative([chamfer]) && chamfer<1/2, "chamfer must be a non-negative value smaller than 1/2")
          assert(is_undef(rounding) || all_nonnegative([rounding]) && rounding<1/2, "rounding must be a non-negative value smaller than 1/2")
          assert(all_positive([base]), "base must be a positive value") ;
  tooth_height = sin(180/n) / tan(tooth_angle/2);     // Normalized tooth height
  cone_height = -tan(cone_angle);                        // Normalized height change corresponding to the cone angle
  ridge_angle = atan(tooth_height/2 + cone_height);
  valley_angle = atan(-tooth_height/2 + cone_height);
  angle = 180/n;    // Half the angle occupied by each tooth going around the circle
  
  factor = crop ? 3 : 1;   // Make it oversized when crop is true

// project spherical coordinate point onto cylinder of radius r
  cyl_proj = function (r,theta_phi)
     [for(pt=theta_phi)
        let(xyz = spherical_to_xyz(1,pt[0], 90-pt[1]))
        r * xyz / norm(point2d(xyz))];

  edge = cyl_proj(or,[[-angle, valley_angle], [0, ridge_angle]]);
  cutfrac = first_defined([chamfer,rounding,0]);
  rounding = rounding==0? undef:rounding;
  ridgecut=xyz_to_spherical(lerp(edge[0],edge[1], 1-cutfrac));
  valleycut=xyz_to_spherical(lerp(edge[0],edge[1], cutfrac/2));
  ridge_chamf = [ridgecut.y,90-ridgecut.z];
  valley_chamf = [valleycut.y,90-valleycut.z];
  basicprof = [
                if (is_def(rounding)) [-angle, valley_chamf.y],
                valley_chamf,
                ridge_chamf
              ];
  full = deduplicate(concat(basicprof, reverse(xflip(basicprof))));
  skewed = back(valley_angle, skew(sxy=skew*angle/(ridge_angle-valley_angle),fwd(valley_angle,full)));
  pprofile = is_undef(rounding) ? skewed
          :
            let(
                segs = max(16,segs(or*rounding)),
                                // Using computed values for the joints lead to round-off error issues
                joints = [(skewed[1]-skewed[0]).x, (skewed[3]-skewed[2]).x/2, (skewed[3]-skewed[2]).x/2,(skewed[5]-skewed[4]).x ],
                roundpts = round_corners(skewed, joint=joints, closed=false,$fn=segs)
            )
            roundpts;
  profile = [
               for(i=[0:1:len(pprofile)-2]) each [pprofile[i],
                                                  if (pprofile[i+1].x-pprofile[i].x > 90)    // Interpolate an extra point if angle > 90 deg
                                                       let(
                                                            edge = cyl_proj(or, select(pprofile,i,i+1)),
                                                            cutpt = xyz_to_spherical(lerp(edge[0],edge[1],.48))  // Exactly .5 is too close to or crosses the origin
                                                       )
                                                       [cutpt.y,90-cutpt.z]
                                                 ], 
               last(pprofile)
             ];

  // This code computes the realized tooth angle
  //  out = cyl_proj(or, pprofile);
  //  in = cyl_proj(ir,pprofile);
  //  p1 = plane3pt(out[0], out[1], in[1]);
  //  p2 = plane3pt(out[2], out[1], in[1]);
  //  echo(toothang=vector_angle(plane_normal(p1), plane_normal(p2)));
  
  bottom = min([tan(valley_angle)*ir,tan(valley_angle)*or])-base-cone_height*ir;
  ang_ofs = !rot ? -skew*angle
          :  n%2==0 ? -(angle-skew*angle)  - skew*angle
          :  -angle*(2-skew)-skew*angle;

  topinner = down(cone_height*ir,[for(ang=lerpn(0,360,n,endpoint=false))
                                  each zrot(ang+ang_ofs,cyl_proj(ir/factor,profile))]);
  topouter = down(cone_height*ir,[for(ang=lerpn(0,360,n,endpoint=false))
                                  each zrot(ang+ang_ofs,cyl_proj(factor*or,profile))]);

  safebottom = min(min(column(topinner,2)), min(column(topouter,2))) - base - (crop?1:0);
  
  botinner = [for(val=topinner) [val.x,val.y,safebottom]];
  botouter = [for(val=topouter) [val.x,val.y,safebottom]];  
  vert = [topouter, topinner, botinner, botouter];

  datamin = min(min(column(topinner,2)), min(column(topouter,2)));
  
  anchors = [
             named_anchor("teeth_bot", [0,0,bottom], DOWN)
            ];
  attachable(anchor=anchor,spin=spin,orient=orient, r=or, h=-2*bottom,anchors=anchors){
      intersection(){
        vnf_polyhedron(vnf_vertex_array(vert, reverse=true, col_wrap=true, row_wrap=true),convexity=min(10,n));
        if (crop)
           zmove(bottom)tube(or=or,ir=ir,height=4*or,anchor=BOT,$fa=1,$fs=1);
      }
    children();
  }
}

// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap