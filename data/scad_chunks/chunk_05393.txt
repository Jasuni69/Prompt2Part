module edge_profile(edges=EDGES_ALL, except=[], excess=0.01, convexity=10) {
    req_children($children);
    check1 = assert($parent_geom != undef, "No object to attach to!");
    conoid = $parent_geom[0] == "conoid";
    edges = !conoid? _edges(edges, except=except) :
        edges==EDGES_ALL? [TOP,BOT] :
        assert(all([for (e=edges) in_list(e,[TOP,BOT])]), "Invalid conoid edge spec.")
        edges;
    vecs = conoid
      ? [for (e=edges) e+FWD]
      : [
            for (i = [0:3], axis=[0:2])
            if (edges[axis][i]>0)
            EDGE_OFFSETS[axis][i]
        ];
    all_vecs_are_edges = all([for (vec = vecs) sum(v_abs(vec))==2]);
    check2 = assert(all_vecs_are_edges, "All vectors must be edges.");
    default_tag("remove")
    for ($idx = idx(vecs)) {
        vec = vecs[$idx];
        anch = _find_anchor(vec, $parent_geom);
        path_angs_T = _attach_geom_edge_path($parent_geom, vec);
        path = path_angs_T[0];
        vecs = path_angs_T[1];
        post_T = path_angs_T[2];
        $attach_to = undef;
        $attach_anchor = anch;
        $profile_type = "edge";
        multmatrix(post_T) {
            for (i = idx(path,e=-2)) {
                pt1 = select(path,i);
                pt2 = select(path,i+1);
                cp = (pt1 + pt2) / 2;
                v1 = vecs[i][0];
                v2 = vecs[i][1];
                $edge_angle = 180 - vector_angle(v1,v2);
                if (!approx(pt1,pt2)) {
                    seglen = norm(pt2-pt1) + 2 * excess;
                    move(cp) {
                        frame_map(x=-v2, z=unit(pt2-pt1)) {
                            linear_extrude(height=seglen, center=true, convexity=convexity)
                                mirror([-1,1]) children();
                        }
                    }
                }
            }
        }
    }
}


// Module: edge_profile_asym()
// Synopsis: Extrudes an asymmetric 2D profile into a mask on the given edges and corners of the parent.
// SynTags: Geom
// Topics: Attachments, Masking
// See Also: attachable(), position(), attach(), face_profile(), edge_profile(), corner_profile(), edge_mask(), face_mask(), corner_mask()
// Usage:
//   PARENT() edge_profile([edges], [except], [convexity=], [flip=], [corner_type=]) CHILDREN;
// Description:
//   Takes an asymmetric 2D mask shape and attaches it to the selected edges and corners, with the appropriate
//   orientation and extruded length to be `diff()`ed away, to give the edges and corners a matching profile.
//   If no tag is set then `edge_profile_asym()` sets the tag for children to "remove" so that it will work
//   with the default {{diff()}} tag.  For details on specifying the edges to mask see [Specifying Edges](attachments.scad#subsection-specifying-edges).
//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).
//   .
//   The asymmetric profiles are joined consistently at the corners.  This is impossible if all three edges at a corner use the profile, hence
//   this situation is not permitted.  The profile orientation can be inverted using the `flip=true` parameter.
//   .
//   The standard profiles are located in the first quadrant and have positive X values.  If you provide a profile located in the second quadrant,
//   where the X values are negative, then it will produce a fillet.  You can flip any of the standard profiles using {{xflip()}}.  
//   Fillets are always asymmetric because at a given edge, they can blend in two different directions, so even for symmetric profiles,
//   the asymmetric logic is required.  You can set the `corner_type` parameter to select rounded, chamfered or sharp corners.
//   However, when the corners are inside (concave) corners, you must provide the size of the profile ([width,height]), because the
//   this information is required to produce the correct corner and cannot be obtain from the profile itself, which is a child object.  
// Arguments:
//   edges = Edges to mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: All edges.
//   except = Edges to explicitly NOT mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: No edges.
//   ---
//   excess = Excess length to extrude the profile to make edge masks.  Default: 0.01
//   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10
//   flip = If true, reverses the orientation of any external profile parts at each edge.  Default false
//   corner_type = Specifies how exterior corners should be formed.  Must be one of `"none"`, `"chamfer"`, `"round"`, or `"sharp"`.  Default: `"none"`
//   size = If given the width and height of the 2D profile, will enable rounding and chamfering of internal corners when given a negative profile.
// Side Effects:
//   Tags the children with "remove" (and hence sets `$tag`) if no tag is already set.
//   `$idx` is set to the index number of each edge.
//   `$attach_anchor` is set for each edge given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.
//   `$profile_type` is set to `"edge"`.
//   `$edge_angle` is set to the inner angle of the current edge.
// Example:
//   ogee = [
//       "xstep",1,  "ystep",1,  // Starting shoulder.
//       "fillet",5, "round",5,  // S-curve.
//       "ystep",1,  "xstep",1   // Ending shoulder.
//   ];
//   diff()
//   cuboid(50) {
//       edge_profile_asym(FRONT)
//          mask2d_ogee(ogee);
//   }
// Example: Flipped
//   ogee = [
//       "xstep",1,  "ystep",1,  // Starting shoulder.
//       "fillet",5, "round",5,  // S-curve.
//       "ystep",1,  "xstep",1   // Ending shoulder.
//   ];
//   diff()
//   cuboid(50) {
//       edge_profile_asym(FRONT, flip=true)
//          mask2d_ogee(ogee);
//   }
// Example: Negative Chamfering
//   cuboid(50) {
//       edge_profile_asym(FWD, flip=false)
//           xflip() mask2d_chamfer(10);
//       edge_profile_asym(BACK, flip=true, corner_type="sharp")
//           xflip() mask2d_chamfer(10);
//   }
// Example: Negative Roundings
//   cuboid(50) {
//       edge_profile_asym(FWD, flip=false)
//           xflip() mask2d_roundover(10);
//       edge_profile_asym(BACK, flip=true, corner_type="round")
//           xflip() mask2d_roundover(10);
//   }
// Example: Cornerless
//   cuboid(50) {
//       edge_profile_asym(
//           "ALL", except=[TOP+FWD+RIGHT, BOT+BACK+LEFT]
//        ) xflip() mask2d_roundover(10);
//   }
// Example: More complicated edge sets
//   cuboid(50) {
//       edge_profile_asym(
//           [FWD,BACK,BOT+RIGHT], except=[FWD+RIGHT,BOT+BACK],
//           corner_type="round"
//        ) xflip() mask2d_roundover(10);
//   }
// Example: Mixing it up a bit.
//   diff()
//   cuboid(60) {
//       tag("keep") edge_profile_asym(LEFT, flip=true, corner_type="chamfer")
//           xflip() mask2d_chamfer(10);
//       edge_profile_asym(RIGHT)
//           mask2d_roundover(10);
//   }
// Example: Chamfering internal corners.
//   cuboid(40) {
//       edge_profile_asym(
//           [FWD+DOWN,FWD+LEFT],
//           corner_type="chamfer", size=[10,10]/sqrt(2)
//        ) xflip() mask2d_chamfer(10);
//   }
// Example: Rounding internal corners.
//   cuboid(40) {
//       edge_profile_asym(
//           [FWD+DOWN,FWD+LEFT],
//           corner_type="round", size=[10,10]
//        ) xflip() mask2d_roundover(10);
//   }