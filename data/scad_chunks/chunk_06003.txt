module rabbit_clip(type, length, width,  snap, thickness, depth, compression=0.1,  clearance=.1, lock=false, lock_clearance=0,
                   splinesteps=8, anchor, orient, spin=0)
{
  legal_types = ["pin","socket","male","female","double"];
  check =
    assert(is_num(width) && width>0,"Width must be a positive value")
    assert(is_num(length) && length>0, "Length must be a positive value")
    assert(is_num(thickness) && thickness>0, "Thickness must be a positive value")
    assert(is_num(snap) && snap>=0, "Snap must be a non-negative value")
    assert(is_num(depth) && depth>0, "Depth must be a positive value")
    assert(is_num(compression) && compression >= 0, "Compression must be a nonnegative value")
    assert(is_bool(lock))
    assert(is_num(lock_clearance))
    assert(in_list(type,legal_types),str("type must be one of ",legal_types));
  if (type=="double") {
    attachable(size=[width+2*compression, depth, 2*length], anchor=default(anchor,BACK), spin=spin, orient=default(orient,BACK)){
      union(){
        rabbit_clip("pin", length=length, width=width, snap=snap, thickness=thickness, depth=depth, compression=compression,
                    lock=lock, anchor=BOTTOM, orient=UP);
        rabbit_clip("pin", length=length, width=width, snap=snap, thickness=thickness, depth=depth, compression=compression,
                    lock=lock, anchor=BOTTOM, orient=DOWN);
        cuboid([width-thickness, depth, thickness]);
      }
      children();
    }
  } else {
    anchor = default(anchor,BOTTOM);
    is_pin = in_list(type,["pin","male"]);
    //default_overlap = 0.01 * (is_pin?1:-1);    // Shift by this much to undo default overlap
    default_overlap = 0;
    extra = 0.02;  // Amount of extension below nominal based position for the socket, must exceed default overlap of 0.01
    clearance = is_pin ? 0 : clearance;
    compression = is_pin ? compression : 0;
    orient =  is_def(orient) ? orient
            : is_pin ? UP
            : DOWN;
    earwidth = 2*thickness+snap;
    point_length = earwidth/2.15;
    // The adjustment is using cos(theta)*earwidth/2 and sin(theta)*point_length, but the computation
    // is obscured because theta is atan(length/2/snap)
    scaled_len = length - 0.5 * (earwidth * snap + point_length * length) / sqrt(sqr(snap)+sqr(length/2));
    bottom_pt = [0,max(scaled_len*0.15+thickness, 2*thickness)];
    ctr = [width/2,scaled_len] + line_normal([width/2-snap, scaled_len/2], [width/2, scaled_len]) * earwidth/2;
    inside_pt = circle_circle_tangents(0, bottom_pt, earwidth/2, ctr)[0][1];
    sidepath =[
               [width/2,0],
               [width/2-snap,scaled_len/2],
               [width/2+(is_pin?compression:0), scaled_len],
               ctr - point_length * line_normal([width/2,scaled_len], inside_pt),
               inside_pt
              ];
    fullpath = concat(
                      sidepath,
                      [bottom_pt],
                      reverse(apply(xflip(),sidepath))
                      );
    dummy2 = assert(fullpath[4].y < fullpath[3].y, "Pin is too wide for its length");

    snapmargin = -snap + last(sidepath).x;// - compression;
    if (is_pin){
      if (snapmargin<0) echo("WARNING: The snap is too large for the clip to squeeze to fit its socket")
      echo(snapmargin=snapmargin);
    }
    // Force tangent to be vertical at the outer edge of the clip to avoid overshoot
    fulltangent = list_set(path_tangents(fullpath, uniform=false),[2,8], [[0,1],[0,-1]]);

    subset = is_pin ? [0:10] : [0,1,2,3, 7,8,9,10];  // Remove internal points from the socket
    tangent = select(fulltangent, subset);
    path = select(fullpath, subset);

    socket_smooth = .04;
    pin_smooth = [.075, .075, .15, .12, .06];
    smoothing = is_pin
                  ? concat(pin_smooth, reverse(pin_smooth))
                  : let(side_smooth=select(pin_smooth, 0, 2))
                    concat(side_smooth, [socket_smooth], reverse(side_smooth));
    bez = path_to_bezpath(path,relsize=smoothing,tangents=tangent);
    rounded = bezpath_curve(bez,splinesteps=splinesteps);
    bounds = pointlist_bounds(rounded);
    extrapt = is_pin ? [] : [rounded[0] - [0,extra]];
    finalpath = is_pin ? rounded
                       : let(withclearance=offset(rounded, r=-clearance, closed=false))
                         concat( [[withclearance[0].x,-extra]],
                                 withclearance,
                                 [[-withclearance[0].x,-extra]]);
    attachable(size=[bounds[1].x-bounds[0].x, depth, bounds[1].y-bounds[0].y], anchor=anchor, spin=spin, orient=orient){
      xrot(90)
        translate([0,-(bounds[1].y-bounds[0].y)/2+default_overlap,-depth/2])
        linear_extrude(height=depth, convexity=10) {
            if (lock)
              xflip_copy()
              right(clearance)
              polygon([sidepath[1]+[-thickness/10,lock_clearance],
                       sidepath[2]-[thickness*.75,0],
                       sidepath[2],
                       [sidepath[2].x,sidepath[1].y+lock_clearance]]);
            if (is_pin)
              offset_stroke(finalpath, width=[thickness,0]);
            else
              polygon(finalpath);
        }
      children();
    }
  }
}



// Section: Splines

// Module: hirth()
// Synopsis: Creates a Hirth face spline that locks together two cylinders.
// SynTags: Geom
// Usage:
//   hirth(n, ir|id=, or|od=, tooth_angle, [cone_angle=], [chamfer=], [rounding=], [base=], [crop=], [anchor=], [spin=], [orient=]
// Description:
//   Create a Hirth face spline.  The Hirth face spline is a joint that locks together two cylinders using radially
//   positioned triangular teeth on the ends of the cylinders.  If the joint is held together (e.g. with a screw) then
//   the two parts will rotate (or not) together.  The two parts of the regular Hirth spline joint are identical.
//   Each tooth is a triangle that grows larger with radius.  You specify a nominal tooth angle; the actual tooth
//   angle will be slightly different.
//   .
//   You can also specify a cone_angle which raises or lowers the angle of the teeth.  When you do this you need to
//   mate splines with opposite angles such as -20 and +20.  The splines appear centered at the origin so that two
//   splines will mate if their centers coincide.  Therefore `attach(CENTER,CENTER)` will produce two mating splines
//   assuming that they are rotated correctly.  The bottom anchors will be at the bottom of the spline base.  The top
//   anchors are at an arbitrary location and are not useful.  
//   .
//   By default the spline is created as a polygon with `2n` edges and the radius is the outer radius to the unchamfered corners.
//   For large choices of `n` this will produce result that is close to circular.  For small `n` the result will be obviously polygonal.
//   If you want a cylindrical result then set `crop=true`, which will intersect an oversized version of the joint with a suitable cylinder.
//   Note that cropping makes the most difference when the tooth count is low.  
//   .
//   The teeth are chamfered proportionally based on the `chamfer` argument which specifies the fraction of the teeth tips
//   to remove.  The teeth valleys are chamfered by half the specified value to ensure that there is room for the parts
//   to mate.  If you use the rounding parameter then the roundings cut away the chamfer corners, so chamfered and rounded
//   joints are compatible with each other.  Note that rounding doesn't always produce a smooth transition to the roundover,
//   particularly with large cone angle.  
//   The base is added based on the unchamfered dimensions of the joint, and the "teeth_bot" anchor is located
//   based on the unchamfered dimensions.
//   .
//   By default the teeth are symmetric, which is ideal for registration and for situations where loading may occur in either
//   direction.   The skew parameter will skew the teeth by the specified amount, where a skew of Â±1 gives a tooth with a vertical
//   side either on the left or the right.  Intermediate values will produce partially skewed teeth.  Note that the skew
//   applies after the tooth profile is computed with the specified tooth_angle, which means that the skewed tooth will
//   have an altered tooth angle from the one specified.
//   .
//   The joint is constructed with a tooth peak aligned with the X+ axis.  
//   For two hirth joints to mate they must have the same tooth count, opposite cone angles, and the chamfer/rounding values
//   must be equal.  (One can be chamfered and one rounded, but with the same value.)  The rotation required to mate the parts
//   depends on the skew and whether the tooth count is odd or even.  To apply this rotation automatically, set `rot=true`.
//   .
//   When you pick extreme parameters such as very large cone angle, or very small tooth count (e.g. 2 or 3), the joint may
//   develop a weird shape, and the shape may be unexpectedly sensitive to things like whether chamfering is enabled.  It is difficult
//   to identify the point where the shapes become odd, or even perhaps invalid.  For example, with 2 teeth a skew of 0.95 works fine, but
//   a skew of 0.97 produces a truncated shape and 0.99 produces a 2-part shape.  A skew of 1 produces a degenerate, invalid shape.  
//   Since it's hard to determine which parameters, exactly, produce "bad" outcomes, we have chosen not to limit the production
//   of the extreme shapes, so take care if using extreme parameter values.  
// Named Anchors:
//   "teeth_bot" = center of the joint, aligned with the bottom of the (unchamfered/unrounded) teeth, pointing DOWN.  
// Arguments:
//   n = number of teeth
//   ir/id = inner radius or diameter
//   or/od = outer radius or diameter
//   tooth_angle = nominal tooth angle.  Default: 60
//   cone_angle = raise or lower the angle of the teeth in the radial direction.  Default: 0
//   skew = skew the tooth shape.  Default: 0
//   chamfer = chamfer teeth by this fraction at tips and half this fraction at valleys.  Default: 0
//   rounding = round the teeth by this fraction at the tips, and half this fraction at valleys.  Default: 0
//   rot = if true rotate so the part will mate (via attachment) with another identical part.  Default: false
//   base = add base of this height to the bottom.  Default: 1
//   crop = crop to a cylindrical shape.  Default: false
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
// Example(3D,NoScale):  Basic uncropped hirth spline
//   hirth(32,20,50);
// Example(3D,NoScale): Raise cone angle
//   hirth(32,20,50,cone_angle=30);
// Example(3D,NoScale): Lower cone angle
//   hirth(32,20,50,cone_angle=-30);
// Example(3D,NoScale): Adding a large base
//   hirth(20,20,50,base=20);
// Example(3D,NoScale): Only 8 teeth, with chamfering
//   hirth(8,20,50,tooth_angle=60,base=10,chamfer=.1);
// Example(3D,NoScale): Only 8 teeth, cropped
//   hirth(8,20,50,tooth_angle=60,base=10,chamfer=.1, crop=true);
// Example(3D,NoScale): Only 8 teeth, with rounding
//   hirth(8,20,50,tooth_angle=60,base=10,rounding=.1);
// Example(3D,NoScale): Only 8 teeth, different tooth angle, cropping with $fn to crop cylinder aligned with teeth
//   hirth(8,20,50,tooth_angle=90,base=10,rounding=.05,crop=true,$fn=48);
// Example(3D,NoScale): Two identical parts joined together (with 1 unit offset to reveal the joint line).  With odd tooth count and no skew the teeth line up correctly:
//   hirth(27,20,50, tooth_angle=60,base=2,chamfer=.05)
//     up(1) attach(CENTER,CENTER)
//       hirth(27,20,50, tooth_angle=60,base=2,chamfer=.05);
// Example(3D,NoScale): Two conical parts joined together, with opposite cone angles for a correct joint.  With an even tooth count one part needs to be rotated for the parts to align:
//   hirth(26,20,50, tooth_angle=60,base=2,cone_angle=30,chamfer=.05)
//     up(1) attach(CENTER,CENTER)
//       hirth(26,20,50, tooth_angle=60,base=2,cone_angle=-30, chamfer=.05, rot=true);
// Example(3D,NoScale): Using skew to create teeth with vertical faces
//   hirth(17,20,50,skew=-1, base=5, chamfer=0.05);
// Example(3D,NoScale): If you want to change how tall the teeth are you do that by changing the tooth angle.  Increasing the tooth angle makes the teeth shorter:
//   hirth(17,20,50,tooth_angle=120,skew=0, base=5, rounding=0.05, crop=true);