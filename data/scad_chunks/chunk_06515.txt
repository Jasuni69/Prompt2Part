function is_2d_transform(t) =    // z-parameters are zero, except we allow t[2][2]!=1 so scale() works
  t[2][0]==0 && t[2][1]==0 && t[2][3]==0 && t[0][2] == 0 && t[1][2]==0 &&
  (t[2][2]==1 || !(t[0][0]==1 && t[0][1]==0 && t[1][0]==0 && t[1][1]==1));   // But rule out zscale()



// Function: apply()
//
// Synopsis: Applies a transformation matrix to a point, list of points, array of points, or a VNF.
// SynTags: Path, VNF, Mat
// Topics: Affine, Matrices, Transforms
// See Also: move(), rot(), scale(), skew()
//
// Usage:
//   pts = apply(transform, points);
//
// Description:
//   Applies the specified transformation matrix `transform` to a point, point list, bezier patch or VNF.
//   When `points` contains 2D or 3D points the transform matrix may be a 4x4 affine matrix or a 3x4 
//   matrix&mdash;the 4x4 matrix with its final row removed.  When the data is 2D the matrix must not operate on the Z axis,
//   except possibly by scaling it.  When points contains 2D data you can also supply the transform as
//   a 3x3 affine transformation matrix or the corresponding 2x3 matrix with the last row deleted.
//   .
//   Any other combination of matrices will produce an error, including acting with a 2D matrix (3x3) on 3D data.
//   The output of apply is always the same dimension as the input&mdash;projections are not supported.
//   .
//   Note that a matrix with a negative determinant such as any mirror reflection flips the orientation of faces.
//   If the transform matrix is square then apply() checks the determinant and if it is negative, apply() reverses the face order so that
//   the transformed VNF has faces with the same winding direction as the original VNF.  This adjustment applies
//   only to VNFs, not to beziers or point lists.  
//
// Arguments:
//   transform = The 2D (3x3 or 2x3) or 3D (4x4 or 3x4) transformation matrix to apply.
//   points = The point, point list, bezier patch, or VNF to apply the transformation to.
//
// Example(3D):
//   path1 = path3d(circle(r=40));
//   tmat = xrot(45);
//   path2 = apply(tmat, path1);
//   #stroke(path1,closed=true);
//   stroke(path2,closed=true);
//
// Example(2D):
//   path1 = circle(r=40);
//   tmat = translate([10,5]);
//   path2 = apply(tmat, path1);
//   #stroke(path1,closed=true);
//   stroke(path2,closed=true);
//
// Example(2D):
//   path1 = circle(r=40);
//   tmat = rot(30) * back(15) * scale([1.5,0.5,1]);
//   path2 = apply(tmat, path1);
//   #stroke(path1,closed=true);
//   stroke(path2,closed=true);
//