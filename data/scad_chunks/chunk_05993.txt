module dovetail(gender, width, height, slide, h, w, angle, slope, thickness, taper, back_width, chamfer, extra=0.01, r, radius, round=false, anchor=BOTTOM, spin=0, orient)
{
    radius = get_radius(r1=radius,r2=r);
    slide = one_defined([slide,thickness],"slide,thickness");
    h = one_defined([h,height],"h,height");
    w = one_defined([w,width],"w,width");
    orient = is_def(orient) ? orient
           : gender == "female" ? DOWN
           : UP;
    count = num_defined([angle,slope]);
    count2 = num_defined([taper,back_width]);
    count3 = num_defined([chamfer, radius]);
    dummy =
        assert(count<=1, "Do not specify both angle and slope")
        assert(count2<=1, "Do not specify both taper and back_width")
        assert(count3<=1 || (radius==0 && chamfer==0), "Do not specify both chamfer and radius");
    slope = is_def(slope) ? slope
          : is_def(angle) ? 1/tan(angle)
          :  6;
    height_slop = gender == "female" ? get_slop() : 0;

    // Need taper angle for computing width adjustment, but not used elsewhere
    taper_ang = is_def(taper) ? taper
              : is_def(back_width) ? atan((back_width-w)/2/slide)
              : 0;
    // This is the adjustment factor for width to grow in the direction normal to the dovetail face
    wfactor = sqrt( 1/slope^2 + 1/cos(taper_ang)^2 );
             // adjust width for increased height    adjust for normal to dovetail surface
    width_slop = 2*height_slop/slope                + 2* height_slop * wfactor;
    width = w + width_slop;
    height = h + height_slop;
    back_width = u_add(back_width, width_slop);

    extra_offset = is_def(taper) ? -extra * tan(taper)
                 : is_def(back_width) ? extra * (back_width-width)/slide/2
                 : 0;

    size = is_def(chamfer) && chamfer>0 ? chamfer
         : is_def(radius) && radius>0 ? radius
         : 0;
    fullsize = round ? [size,size]
             : gender == "male" ? [size,0]
             : [0,size];

    type = is_def(chamfer) && chamfer>0 ? "chamfer" : "circle";

    smallend_half = round_corners(
        move(
            [0,-slide/2-extra,0],
            p=[
                [0,                                     0, height],
                [width/2 - extra_offset,                0, height],
                [width/2 - extra_offset - height/slope, 0, 0     ],
                [width/2 - extra_offset + height,       0, 0     ]
            ]
        ),
        method=type, cut = fullsize, closed=false
    );

    smallend_points = concat(select(smallend_half, 1, -2), [down(extra,p=select(smallend_half, -2))]);
    offset = is_def(taper) ? -slide * tan(taper)
           : is_def(back_width) ? (back_width-width) / 2
           : 0;
    bigend_points = move([offset+2*extra_offset,slide+2*extra,0], p=smallend_points);

    bigenough = all_nonnegative(column(smallend_half,0)) && all_nonnegative(column(bigend_points,0));

    assert(bigenough, "Width (or back_width) of dovetail is not large enough for its geometry (angle and taper");

    //adjustment = $overlap * (gender == "male" ? -1 : 1);  // Adjustment for default overlap in attach()
    adjustment = 0;    // Default overlap is assumed to be zero

    // This code computes the true normal from which the exact width factor can be obtained
    // as the x component.  Comparing to wfactor above shows that they agree.
    //   pts = [smallend_points[0], smallend_points[1], bigend_points[1],bigend_points[0]];
    //   n = -polygon_normal(pts);
    //   echo(n=n);
    //   echo(invwfactor = 1/wfactor, error = n.x-1/wfactor);

    attachable(anchor,spin,orient, size=[width+2*offset, slide, height]) {
        down(height/2+adjustment) {
            //color("red")stroke([pts],width=.1);

            skin(
                [
                    reverse(concat(smallend_points, xflip(p=reverse(smallend_points)))),
                    reverse(concat(bigend_points, xflip(p=reverse(bigend_points))))
                ],
                slices=0, convexity=4
            );
        }
        children();
    }
}


// Section: Tension Clips

// h is total height above 0 of the nub
// nub extends below xy plane by distance nub/2