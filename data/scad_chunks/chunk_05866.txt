function _turtle3d_command(command, parm, parm2, state, index) =
    command == "repeat"?
        assert(is_int(parm) && parm>=0,str("\"repeat\" command requires an integer repeat count at index ",index))
        assert(is_list(parm2),str("\"repeat\" command requires a command list parameter at index ",index))
        _turtle3d_repeat(parm2, state, parm) :
    let(
        trlist = 0,
        prelist = 1,
        movestep=2,
        angle=3,
        arcsteps=4,
        parm = !is_string(parm) ? parm : undef,
        parm2 = command=="arctodir" || command=="arcrot" ? parm2 
              : !is_string(parm2) && !is_list(parm2) ? parm2 : undef,
        needvec = ["jump", "xyzmove","setdir"],
        neednum = ["untilx","untily","untilz","xjump","yjump","zjump","angle","length","scale","addlength"],
        numornothing = ["right","left","up","down","xrot","yrot","zrot", "roll", "move"],
        needtran = ["rot"],
        chvec = !in_list(command,needvec) || is_vector(parm,3),
        chnum = (!in_list(command,neednum) || is_num(parm))
                && (!in_list(command,numornothing) || (is_undef(parm) || is_num(parm))),
        chtran = !in_list(command,needtran) || is_matrix(parm,4,4),
        lastT = last(state[trlist]),
        lastPre = last(state[prelist]),
        lastpt = apply(lastT,[0,0,0])
    )
    assert(chvec,str("\"",command,"\" requires a 3d vector parameter at index ",index))
    assert(chnum,str("\"",command,"\" requires a numeric parameter at index ",index))
    assert(chtran,str("\"",command,"\" requires a 4x4 transformation matrix at index ",index))
    command=="move" ? _tupdate(state, [lastT*right(default(parm,1)*state[movestep])], [lastPre]):
    in_list(command,["untilx","untily","untilz"]) ? (
        let(
            dirlist=[RIGHT, BACK, UP],
            plane = [each dirlist[search([command],["untilx","untily","untilz"])[0]], parm],
            step = [lastpt,apply(lastT,RIGHT)],
            int = plane_line_intersection(plane, step, bounded=[true,false])
        )
        assert(is_def(int), str("\"",command,"\" never reaches desired goal at index ",index))
        let(
            size = is_vector(int,3) ? norm(int-lastpt) / norm(step[1]-step[0]) : 0
        )
        _tupdate(state, [lastT*right(size)], [lastPre])
    ) :
    command=="xmove" ? _tupdate(state,[right(default(parm,1)*state[movestep])*lastT],[lastPre]):
    command=="ymove" ? _tupdate(state,[back(default(parm,1)*state[movestep])*lastT],[lastPre]):
    command=="zmove" ? _tupdate(state,[up(default(parm,1)*state[movestep])*lastT],[lastPre]):
    command=="xyzmove" ? _tupdate(state,[move(parm)*lastT],[lastPre]):
    command=="jump" ? _tupdate(state,[move(parm-lastpt)*lastT],[lastPre]):
    command=="xjump" ? _tupdate(state,[move([parm,lastpt.y,lastpt.z]-lastpt)*lastT],[lastPre]):
    command=="yjump" ? _tupdate(state,[move([lastpt.x,parm,lastpt.z]-lastpt)*lastT],[lastPre]):
    command=="zjump" ? _tupdate(state,[move([lastpt.x,lastpt.y,parm]-lastpt)*lastT],[lastPre]):
    command=="angle" ? assert(parm!=0,str("\"",command,"\" requires nonnegative argument at index ",index))
                       list_set(state, angle, parm) :
    command=="length" ? list_set(state, movestep, parm) :
    command=="scale" ?  list_set(state, movestep, parm*state[movestep]) :
    command=="addlength" ?  list_set(state, movestep, state[movestep]+parm) :
    command=="arcsteps" ?  assert(is_int(parm) && parm>0, str("\"",command,"\" requires a postive integer argument at index ",index))
                           list_set(state, arcsteps, parm) :
    command=="roll" ? list_set(state, trlist, concat(list_head(state[trlist]), [lastT*xrot(parm)])):
    in_list(command,["right","left","up","down"]) ? 
        list_set(state, trlist, concat(list_head(state[trlist]), [lastT*_turtle3d_rotation(command,default(parm,state[angle]))])):
    in_list(command,["xrot","yrot","zrot"]) ?
        let(
             Trot = _rotpart(lastT),      // Extract rotational part of lastT
             shift = _transpart(lastT)    // Translation part of lastT
        )
        list_set(state, trlist, concat(list_head(state[trlist]),
                                       [move(shift)*_turtle3d_rotation(command,default(parm,state[angle])) * Trot])):
    command=="rot" ?
        let(
             Trot = _rotpart(lastT),      // Extract rotational part of lastT
             shift = _transpart(lastT)    // Translation part of lastT
        )
        list_set(state, trlist, concat(list_head(state[trlist]),[move(shift) * parm * Trot])):
    command=="setdir" ?
        let(
             Trot = _rotpart(lastT),
             shift = _transpart(lastT)
        )
        list_set(state, trlist, concat(list_head(state[trlist]),
                                       [move(shift)*rot(from=apply(Trot,RIGHT),to=parm) * Trot ])):
    in_list(command,["arcleft","arcright","arcup","arcdown"]) ?
        assert(is_num(parm),str("\"",command,"\" command requires a numeric radius value at index ",index))
        let(
            radius = state[movestep]*parm,
            myangle = default(parm2,state[angle])
        )
        assert(myangle!=0, str("\"",command,"\" command requires a nonzero angle at index ",index))
        let(
            length = 2*PI*radius * abs(myangle)/360, 
            center = [0,
                      command=="arcleft"?radius:command=="arcright"?-radius:0,
                      command=="arcdown"?-radius:command=="arcup"?radius:0],
            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps]
        )    
        _tupdate(state,
                 [for(n=[1:1:steps]) lastT*_turtle3d_rotation(command,myangle*n/steps,center)],
                 repeat(lastPre,steps)):
    in_list(command,["arcxrot","arcyrot","arczrot"]) ?
        assert(is_num(parm),str("\"",command,"\" command requires a numeric radius value at index ",index))  
        let(
            radius = state[movestep]*parm,
            myangle = default(parm2,state[angle])
        )
        assert(myangle!=0, str("\"",command,"\" command requires a nonzero angle at index ",index))
        let(
            length = 2*PI*radius * abs(myangle)/360, 
            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps],
            Trot = _rotpart(lastT),
            shift = _transpart(lastT),
            v = apply(Trot,RIGHT),
            dir = command=="arcxrot" ? RIGHT
                : command=="arcyrot" ? BACK
                : UP,
            projv = v - (dir*v)*dir,
            center = sign(myangle) * radius * cross(dir,projv),
            slope = dir*v / norm(projv),
            vshift = dir*slope*length
        )
        assert(!all_zero(projv), str("Rotation acts as twist, which does not produce a valid arc, at index ",index))
        _tupdate(state,
                 [for(n=[1:1:steps]) move(shift+vshift*n/steps)*_turtle3d_rotation(command,myangle*n/steps,center)*Trot],
                 repeat(lastPre,steps)):
    command=="arctodir" || command=="arcrot"?
        assert(command!="arctodir" || is_vector(parm2,3),str("\"",command,"\" command requires a direction vector at index ",index))
        assert(command!="arcrot" || is_matrix(parm2,4,4),str("\"",command,"\" command requires a transformation matrix at index ",index))  
        let(
            Trot = _rotpart(lastT),
            shift = _transpart(lastT),
            v = apply(Trot,RIGHT),
            rotparms = command=="arctodir"
                              ? rot_decode(rot(from=v,to=parm2))
                              : rot_decode(parm2),
            dir = rotparms[1],
            myangle = rotparms[0],
            projv = v - (dir*v)*dir,
            slope = dir*v / norm(projv),
            radius = state[movestep]*parm,
            length = 2*PI*radius * myangle/360, 
            vshift = dir*slope*length,
            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps],
            center = radius * cross(dir,projv)
        )
        assert(!all_zero(projv), str("Rotation acts as twist, which does not produce a valid arc, at index ",index))
        _tupdate(state,
                 [for(n=[1:1:steps]) move(shift+vshift*n/steps)*rot(n/steps*myangle,v=rotparms[1],cp=center)*Trot],
                 repeat(lastPre,steps)):
    is_list(command) ?
        let(list_update = _turtle3d_list_command(command, state[arcsteps], state[movestep], lastT, lastPre, index))
        _tupdate(state, list_update[0], list_update[1]):
    assert(false,str("Unknown turtle command \"",command,"\" at index",index))
    [];