function _textured_revolution(
    shape, texture, tex_size, tex_scale=1,
    inset=false, rot=false, shift=[0,0],
    taper, closed=true, angle=360,
    inhibit_y_slicing,tex_aspect, pixel_aspect, 
    counts, samples, start=0,tex_extra,
    style="min_edge", atype="intersect",
    anchor=CENTER, spin=0, orient=UP
) =
    assert(angle>0 && angle<=360)
    assert(is_path(shape,[2]) || is_region(shape))
    assert(is_undef(samples) || is_int(samples))
    assert(is_bool(closed))
    assert(counts==undef || is_int(counts) || (all_integer(counts) && len(counts)==2), "tex_reps must be an integer or list of two integers")
    assert(tex_size==undef || is_vector(tex_size,2) || is_finite(tex_size))
    assert(is_bool(rot) || in_list(rot,[0,90,180,270]))
    assert(in_list(atype, _ANCHOR_TYPES), "Anchor type must be \"hull\" or \"intersect\"")
    assert(is_undef(tex_extra) || is_finite(tex_extra) || is_vector(tex_extra,2), "tex_extra must be a number of 2-vector")
    assert(num_defined([tex_aspect, pixel_aspect])<=1, "Cannot give both tex_aspect and pixel_aspect")
    assert(is_undef(taper) || !closed, "Cannot give tex_taper if caps=false")
    //assert(num_defined([tex_aspect, pixel_aspect])==0 || is_undef(angle), "Cannot give tex_aspect or pixel_aspect if you give angle") 
    let(
        inhibit_y_slicing = default(inhibit_y_slicing, is_path(shape) && len(shape)==2 ? true : false), 
        regions = !is_path(shape,2)? region_parts(shape)
                : closed? region_parts([shape]) 
                : let(
                      testpoly = [[0,shape[0].y], each shape, [0,last(shape).y]]
                  )
                  [[is_polygon_clockwise(testpoly) ? shape : reverse(shape)]],
        checks = [
            for (rgn=regions, path=rgn)
                assert(all(path, function(pt) pt.x>=0),"All points in the shape must have non-negative x value"),
            //for(reg=regions, path=reg, edge=pair(path,wrap=closed))
            //              assert(edge[0].x>0 || edge[1].x>0,
            //                     str("The shape cannot have any edges on the axis of rotation",closed?" (including the segment that closes the shape)":""))
        ]
    )
    assert(closed || is_path(shape,2), "caps=true is only allowed with paths")
    let(
        counts = is_undef(counts) ? undef : force_list(counts,2),
        tex_size = force_list(tex_size,2),
        texture = _get_texture(texture, rot),
        tex_extra_try = is_vnf(texture) ? [1,1]
                      : is_def(tex_extra) ? force_list(tex_extra,2)
                      : counts==[1,1] ? [0,0]
                      : [1,1],
        tex_extra = angle==360 ? [1,tex_extra_try.y] : tex_extra_try,
        dummy = assert(is_def(counts) || num_defined([pixel_aspect,tex_aspect])==0, "Must specify tex_counts (not tex_size) when using pixel_aspect or tex_aspect")
                assert(is_undef(pixel_aspect) || !is_vnf(texture), "Cannot give pixel_aspect with a VNF texture")
                assert(is_undef(samples) || is_vnf(texture), "You gave the tex_samples argument with a heightfield texture, which is not permitted.  Use the n= argument to texture() instead"),
        inset = is_num(inset)? inset : inset? 1 : 0,
        samples = !is_vnf(texture)? len(texture)
                : is_num(samples)? samples
                : 8,
        bounds = pointlist_bounds(flatten(flatten(regions))),
        maxx = bounds[1].x,
        miny = bounds[0].y,
        maxy = bounds[1].y,
        h = maxy - miny,
        circumf = 2 * PI * maxx,
        texcnt = is_vnf(texture) ? undef : [len(texture[0]), len(texture)],
        angle = num_defined([tex_aspect,pixel_aspect])==0 ? angle
              : let(
                     paths = flatten(regions),
                     lengths = [for(path=paths) path_length(path,closed=closed)],
                     ind = max_index(lengths),
                     rpath = resample_path(paths[ind], n=counts.y * samples + (closed?0:tex_extra.y), closed=closed),
                     h = path_length(rpath), 
                     r = mean(column(rpath,0)),
                     width = counts.x/counts.y * (is_def(pixel_aspect) ? (texcnt.x+tex_extra.x-1)/(texcnt.y+tex_extra.y-1) : tex_aspect) * h + (is_def(pixel_aspect)?1:0),
                     ang = 360 * width / (2*PI*r)
                )
                assert(ang<=360, str("Angle required for requested tile counts and aspect is ",ang, " which exceeds 360 degrees."))
                360 * width / (2*PI*r),

        tile = !is_vnf(texture) || samples==1 ? texture
             :
              let(
                  s = 1 / samples,
                  slices = list([s : s : 1-s/2]),
                  vnfx = vnf_slice(texture, "X", slices),
                  vnfy = inhibit_y_slicing? vnfx : vnf_slice(vnfx, "Y", slices),
                  zvnf = vnf_triangulate(vnf_quantize(vnfy,1e-4))
              ) zvnf,
        edge_paths = is_vnf(tile) ? _tile_edge_path_list(tile,1) : undef,
        edge_closed_paths = is_def(edge_paths) ? edge_paths[1] : [],
        side_paths = angle==360 || !is_vnf(tile) ? undef
                   : _tile_edge_path_list(tile,0),
        side_open_path = is_undef(side_paths) ? undef : len(side_paths[0])==0 ? [] : side_paths[0][0],
        side_closed_paths = is_undef(side_paths) ? [] : side_paths[1], 
        counts_x = is_def(counts)? counts.x : max(1,round(angle/360*circumf/tex_size.x)),
        adj_angle = is_vnf(texture)?angle
                  : angle*(1-(tex_extra.x-1)/(texcnt.x*counts_x+tex_extra.x-1)),  // adjusted angle for strip positions taking tex_extra into account
        taperfunc = closed || is_undef(taper)? function (x) 1
                  : is_finite(taper)?
                         let(
                              taper = taper<=1 ? taper
                                    : echo("The tex_taper now uses a value from 0-1.  Your entry was larger than 1 and has been scaled by 1/100.")
                                      taper/100
                         )
                         assert(taper>=0 && taper<=0.5, str("tex_taper must be between 0 and 0.5 but was ",taper))
                         function (x) lookup(x, [[0,0],
                                                 if (taper==0.5) [taper,1]
                                                 else each [[taper+EPSILON,1],[1-taper-EPSILON,1]],
                                                 [1,0]])
                  : is_path(taper,2) ?
                         let(
                             taper = max(column(taper,0)) <= 1 ? taper
                                   : assert("The tex_taper table now uses values from 0-1.  Your entry was larger than 1 and has been scaled by 1/100.")
                                     xscale(1/100,taper)
                         )
                         function(x) lookup(x,taper)
                  : is_function(taper) ? taper
                  : assert(false,"tex_taper must be a function, scalar or list of pairs"),
        // Checks a path to see if it has segments on the Y axis.  More than 1 is an error.  If no segments return
        // path unchanged with closed=true.  If there is 1 segment, delete that segment (by rotating the path so it's
        // at the end) and return closed=false.  This prevents textures from continuing into the inside of a shape.  
        open_axis_paths = function(path,closed)
                            !closed ? [path,closed]
                          : let(
                               axind = [for(i=[0:1:len(path)-1]) if (approx(path[i].x,0) && approx(select(path,i+1).x,0)) i],
                               dummy = assert(len(axind)<=1, "Found path with more than 1 segment on the Y axis, which is not supported with texturing.")
                            )
                            len(axind)==0 ? [path,true]
                          :
                            [list_rotate(path, (axind[0]+1)%len(path)), false],
        transform_point = function(tileind, tilez, counts_y, bases, norms)
                             let(
                                 part = tileind * samples,
                                 ind = floor(part),
                                 frac = part - ind,
                                 base = lerp(select(bases,ind), select(bases,ind+1), frac),
                                 norm = unit(lerp(select(norms,ind), select(norms,ind+1), frac)),
                                 scale = tex_scale * taperfunc(1-tileind/counts_y) * base.x/maxx,
                                 texh = scale<0 ? -(1-tilez - inset) * scale
                                                :  (tilez - inset) * scale
                             )
                             base - norm * texh,
        full_vnf = vnf_join([
            for (rgn = regions) let(
                rgn_wall_vnf = vnf_join(
                   [for (path = rgn) let(
                        path_closed = open_axis_paths(path,closed),
                        path = path_closed[0],
                        closed = path_closed[1], 
                        plen = path_length(path, closed=closed),
                        counts_y = is_def(counts) ? counts.y : max(1,round(plen/tex_size.y)),
                        obases = resample_path(path, n=counts_y * samples + (closed?0:tex_extra.y), closed=closed),
                        onorms = path_normals(obases, closed=closed),
                        bases = xrot(90, p=path3d(obases)),
                        norms = xrot(90, p=path3d(onorms)),
                        vnf = is_vnf(texture)
                          ? let(strip=
                                  vnf_join([ // VNF tile texture
                                             for (j = [0:1:counts_y-1])
                                                [
                                                   [
                                                       for (vert = tile[0])
                                                            let(xyz = transform_point(j + (1-vert.y),vert.z,counts_y,bases, norms))
                                                            zrot(vert.x*angle/counts_x, p=xyz)
                                                   ],
                                                tile[1]
                                                ]
                                           ]),
                                full_wall = vnf_join([
                                              for (i = [0:1:counts_x-1])
                                                 zrot(i*angle/counts_x, strip)
                                            ])
                            )
                            full_wall
                          : let( // Heightfield texture
                                tiles = [
                                    for (j = [0,1], tj = [0:1:texcnt.x-1])
                                      if (j == 0 || tj < max(1,tex_extra.x))
                                        let(
                                            v = (j * texcnt.x + tj) / (texcnt.x*counts_x+tex_extra.x-1),
                                            mat = zrot(v*angle)
                                        )
                                        apply(mat, [
                                                    for (i = [0:1:counts_y-(closed?1:0)], ti = [0:1:texcnt.y-1])
                                                      if (i != counts_y || ti < tex_extra.y)
                                                         transform_point(i + (ti/texcnt.y),texture[ti][tj],counts_y, bases, norms)
                                               ])
                                ],
                                strip_pts = transpose(select(tiles,0,texcnt.x)),
                                last_pts = transpose(select(tiles,0,texcnt.x-1+tex_extra.x)),
                                strip_vnf = vnf_vertex_array(strip_pts, caps=false, style=style,col_wrap=false, row_wrap=closed),
                                last_vnf = vnf_vertex_array(last_pts, caps=false, style=style,col_wrap=false, row_wrap=closed),
                                full_wall = vnf_join([
                                                       for (i = [0:1:counts_x-2]) zrot(i*adj_angle/counts_x, strip_vnf),
                                                       zrot((counts_x-1)*adj_angle/counts_x, last_vnf)
                                                     ])
                            )
                            full_wall
                      )
                      vnf
                   ]),
                sidecap_vnf = angle == 360? EMPTY_VNF :
                    let(
                        cap_rgn = side_open_path == [] ? [] 
                           : [ for (path = rgn)
                                 let(
                                   path_closed = open_axis_paths(path,closed),
                                   path = path_closed[0],
                                   closed = path_closed[1], 
                                   plen = path_length(path, closed=closed),
                                   counts_y = is_def(counts) ? counts.y : max(1,round(plen/tex_size.y)),
                                   bases = resample_path(path, n=counts_y * samples + (closed?0:tex_extra.y), closed=closed),
                                   norms = path_normals(bases, closed=closed),
                                   ppath = is_vnf(texture)
                                         ? let( onepath = [ // VNF tile texture
                                                             for (j = [0:1:counts_y-1], vert=side_open_path)
                                                               transform_point(j + (1 - vert.y),vert.z,counts_y,bases, norms)
                                                          ]
                                           )
                                           [onepath,onepath]
                                        :
                                           [for(j=[0,1])    // Heightfield texture
                                              [ 
                                               for (i = [0:1:counts_y-(closed?1:0)], ti = [0:1:texcnt.y-1])
                                                 if (i != counts_y || ti < tex_extra.y)
                                                   transform_point(i + (ti/texcnt.y),texture[ti][(j*(texcnt.x-1+tex_extra.x))%texcnt.x],counts_y, bases, norms)
                                              ]
                                          ], 
                                   paths = [for(p=ppath)
                                              deduplicate([
                                                           if (!closed) [0, p[0].y],
                                                           each p,
                                                           if (!closed) [0, last(p).y]
                                                          ],
                                                          closed=closed)]
                                 )
                                 paths
                             ],
                        cap_vnfs = cap_rgn == [] ? [EMPTY_VNF]
                                 : [for(i=[0,1]) vnf_from_region(column(cap_rgn,i), rot([90,0,i*angle]), reverse=i==1)],
                        extra_paths = side_closed_paths==[] ? [] 
                           : [for (path = rgn) let(
                                path_closed = open_axis_paths(path,closed),
                                path = path_closed[0],
                                closed = path_closed[1], 
                            
                                plen = path_length(path, closed=closed),
                                counts_y = is_def(counts) ? counts.y : max(1,round(plen/tex_size.y)),
                                bases = resample_path(path, n=counts_y * samples + (closed?0:1), closed=closed),
                                norms = path_normals(bases, closed=closed),
                                modpaths = [for (j = [0:1:counts_y-1], cpath=side_closed_paths)
                                              [for(vert=cpath)
                                                 transform_point(j + (1 - vert.y),vert.z,counts_y,bases, norms)]
                                           ]
                             )
                             each modpaths
                            ],
                        extra_vnfs = [
                           if (len(extra_paths)>0) for(path=extra_paths) [xrot(90,path3d(path)), [count(len(path))]],
                           if (len(extra_paths)>0) for(path=extra_paths) [rot([90,0,angle],p=path3d(path)), [count(len(path),reverse=true)]],
                        ]
                    ) vnf_join(concat(cap_vnfs, extra_vnfs)),
                endcaps_vnf = closed? EMPTY_VNF :
                    let(
                        path_closed = open_axis_paths(rgn[0],closed),
                        path = path_closed[0],
                        closed = path_closed[1], 
                        plen = path_length(path, closed=closed),
                        counts_y = is_def(counts) ? counts.y : max(1,round(plen/tex_size.y)),
                        obases = resample_path(path, n=counts_y * samples + (closed?0:tex_extra.y), closed=closed),
                        onorms = path_normals(obases, closed=closed),
                        bases = xrot(90, p=path3d(obases)),
                        norms = xrot(90, p=path3d(onorms)),
                        bpath = is_def(edge_paths)
                                   ? len(edge_paths[0])==0 ? [] : repeat(hstack([column(edge_paths[0][0],0), column(edge_paths[0][0],2)]),2)
                                   :  
                                     [ for(j=[texcnt.y-1+tex_extra.y,0])
                                         [for (i = [0:1:texcnt.x-1+max(1,tex_extra.x)])
                                             [i/texcnt.x, texture[j%texcnt.y][i%texcnt.x]]]],
                        caps_vnf = vnf_join([
                            for (epath=edge_closed_paths, j = [-1,0])
                                    let(
                                        base = select(bases,j),
                                        norm = unit(select(norms,j)),
                                        ppath = [
                                            for (vert = epath) let(
                                                uang = vert.x / counts_x,
                                                tex_scale = tex_scale * taperfunc(j+1),
                                                texh = tex_scale<0 ? -(1-vert.z - inset) * tex_scale * (base.x / maxx)
                                                                   : (vert.z - inset) * tex_scale * (base.x / maxx),
                                                xyz = base - norm * texh
                                            ) zrot(angle*uang, p=xyz)
                                        ],
                                        faces = [count(ppath,reverse=j==0)]
                                    )
                                    for(i=[0:1:counts_x-1])
                                        [zrot(i*angle/counts_x, ppath), faces],
                            if (len(bpath)>0)
                                for (j = [-1,0])
                                    let(
                                         base = select(bases,j),
                                         norm = unit(select(norms,j)),
                                         ppath = [
                                             for (vert = bpath[j+1]) let(
                                                 uang = vert.x / counts_x,
                                                 tex_scale = tex_scale * taperfunc(j+1),
                                                 texh = tex_scale<0 ? -(1-vert.y - inset) * tex_scale * (base.x / maxx)
                                                                    : (vert.y - inset) * tex_scale * (base.x / maxx),
                                                 xyz = base - norm * texh
                                             ) zrot(adj_angle*uang, p=xyz)
                                         ],
                                         pplen = is_def(texcnt) ? texcnt.x+1 : len(ppath), 
                                         last_len = len(ppath)-(tex_extra.x==0?1:0), 
                                         zed = j<0? max(column(ppath,2)): min(column(ppath,2)),
                                         slice_vnf = [
                                             [
                                                 each select(ppath,0,pplen-1),
                                                 [0, 0, zed],
                                             ], [
                                                 for (i = [0:1:pplen-2])
                                                     j<0? [pplen, i, (i+1)%pplen]
                                                        : [pplen, (i+1)%pplen, i]
                                             ]
                                         ],
                                         last_slice = [
                                             [
                                                 each select(ppath,0,last_len-1),
                                                 [0, 0, zed],
                                             ], [
                                                 for (i = [0:1:last_len-2])
                                                     j<0? [last_len, i, (i+1)%last_len]
                                                        : [last_len, (i+1)%last_len, i]
                                             ]
                                         ]
                                    )
                                    for (i = [0:counts_x-1])
                                       i<counts_x-1 ? zrot(i*adj_angle/counts_x, slice_vnf)
                                                    : zrot((counts_x-1)*adj_angle/counts_x, last_slice)
                        ])
                    ) caps_vnf
            ) vnf_join([rgn_wall_vnf, sidecap_vnf, endcaps_vnf])
        ]),
        skmat = zrot(start) * down(-miny) * skew(sxz=shift.x/h, syz=shift.y/h) * up(-miny),
        skvnf = apply(skmat, full_vnf),
        geom = atype=="intersect"
              ? attach_geom(vnf=skvnf, extent=false)
              : attach_geom(vnf=skvnf, extent=true)
    ) reorient(anchor,spin,orient, geom=geom, p=skvnf);