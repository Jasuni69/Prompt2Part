function _Subdivision11Path(list,divisions) =
  divisions > 0 && len(list) > 2 ?
    let (n = len(list)-2)
    let (list2 = [ for(i=[0:n]) (list[i] + list[i+1])/2 ])
    _Subdivision11Path([ list[0], for(i=[1:n]) each [ (list[i] + list2[i-1])/2, (list[i] + list2[i])/2 ], list[n+1]], divisions-1) : list;


// My own attempt with variable weighting.
// The goal was a smoothing algoritme that feels
// like NURBS.
// Explanation:
//   The average points between the original
//   points are calculated. These are kept.
//   A second set of average points between 
//   those average points are temporarely calculated.
//   A new point is created on the line between
//   an original point and the temporarely point.
//   The position on that line is defined by
//   a 'weight' variable.
//   The result is the combination of the
//   kept points and the new points.
//
// When the 'weight' variable is set to
// sqrt(2) - 1, then the result approximates 
// a circle when the control points is a square.
// It is some kind of cubic B-spline, but I don't 
// know if it matches with one of the known algoritmes.