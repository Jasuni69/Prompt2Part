function grid_copies(spacing, n, size, stagger=false, inside=undef, nonzero, p=_NO_ARG) =
    let(
        dummy = assert(in_list(stagger, [false, true, "alt"])),
        bounds = is_undef(inside)? undef :
            is_path(inside)? pointlist_bounds(inside) :
            assert(is_region(inside))
            pointlist_bounds(flatten(inside)),
        nonzero = is_path(inside) ? default(nonzero,false)
                : assert(is_undef(nonzero), "nonzero only allowed if inside is a polygon")
                  false,
        size = is_num(size)? [size, size] :
            is_vector(size)? assert(len(size)==2) size :
            bounds!=undef? [
                for (i=[0:1]) 2*max(abs(bounds[0][i]),bounds[1][i])
            ] : undef,
        spacing = is_num(spacing)? (
                stagger!=false? polar_to_xy(spacing,60) :
                [spacing,spacing]
            ) :
            is_vector(spacing)? assert(len(spacing)==2) spacing :
            size!=undef? (
                is_num(n)? v_div(size,(n-1)*[1,1]) :
                is_vector(n)? assert(len(n)==2) v_div(size,n-[1,1]) :
                v_div(size,(stagger==false? [1,1] : [2,2]))
            ) :
            undef,
        n = is_num(n)? [n,n] :
            is_vector(n)? assert(len(n)==2) n :
            size!=undef && spacing!=undef? v_floor(v_div(size,spacing))+[1,1] :
            [2,2],
        offset = v_mul(spacing, n-[1,1])/2,
        mats = stagger == false
          ? [
                for (row = [0:1:n.y-1], col = [0:1:n.x-1])
                let( pos = v_mul([col,row],spacing) - offset )
                if (
                    is_undef(inside) ||
                    (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||
                    (is_region(inside) && point_in_region(pos, inside)>=0)
                )
                translate(pos)
            ]
          : // stagger == true or stagger == "alt"
            let(
                staggermod = (stagger == "alt")? 1 : 0,
                cols1 = ceil(n.x/2),
                cols2 = n.x - cols1
            )
            [
                for (row = [0:1:n.y-1])
                let( rowcols = ((row%2) == staggermod)? cols1 : cols2 )
                if (rowcols > 0)
                for (col = [0:1:rowcols-1])
                let(
                    rowdx = (row%2 != staggermod)? spacing.x : 0,
                    pos = v_mul([2*col,row],spacing) + [rowdx,0] - offset
                )
                if (
                    is_undef(inside) ||
                    (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||
                    (is_region(inside) && point_in_region(pos, inside)>=0)
                )
                translate(pos)
            ]
    )
    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];


//////////////////////////////////////////////////////////////////////
// Section: Rotating copies of all children
//////////////////////////////////////////////////////////////////////

// Function&Module: rot_copies()
// Synopsis: Rotates copies of children.
// SynTags: MatList, Trans
// Topics: Transformations, Distributors, Rotation, Copiers
// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() 
//
// Usage:
//   rot_copies(rots, [cp=], [sa=], [delta=], [subrot=]) CHILDREN;
//   rot_copies(rots, v, [cp=], [sa=], [delta=], [subrot=]) CHILDREN;
//   rot_copies(n=, [v=], [cp=], [sa=], [delta=], [subrot=]) CHILDREN;
// Usage: As a function to translate points, VNF, or Bezier patches
//   copies = rot_copies(rots, [cp=], [sa=], [delta=], [subrot=], p=);
//   copies = rot_copies(rots, v, [cp=], [sa=], [delta=], [subrot=], p=);
//   copies = rot_copies(n=, [v=], [cp=], [sa=], [delta=], [subrot=], p=);
// Usage: Get Translation Matrices
//   mats = rot_copies(rots, [cp=], [sa=], [delta=], [subrot=]);
//   mats = rot_copies(rots, v, [cp=], [sa=], [delta=], [subrot=]);
//   mats = rot_copies(n=, [v=], [cp=], [sa=], [delta=], [subrot=]);
// Description:
//   When called as a module:
//   - Given a list of [X,Y,Z] rotation angles in `rots`, rotates copies of the children to each of those angles, regardless of axis of rotation.
//   - Given a list of scalar angles in `rots`, rotates copies of the children to each of those angles around the axis of rotation.
//   - If given a vector `v`, that becomes the axis of rotation.  Default axis of rotation is UP.
//   - If given a count `n`, makes that many copies, rotated evenly around the axis.
//   - If given an offset `delta`, translates each child by that amount before rotating them into place.  This makes rings.
//   - If given a centerpoint `cp`, centers the ring around that centerpoint.
//   - If `subrot` is true, each child will be rotated in place to keep the same size towards the center when making rings.
//   - The first (unrotated) copy will be placed at the relative starting angle `sa`.
//   .
//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.
//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.
//
// Arguments:
//   rots = A list of [X,Y,Z] rotation angles in degrees.  If `v` is given, this will be a list of scalar angles in degrees to rotate around `v`.
//   v = If given, this is the vector of the axis to rotate around.
//   cp = Centerpoint to rotate around.  Default: `[0,0,0]`
//   ---
//   n = Optional number of evenly distributed copies, rotated around the axis.
//   sa = Starting angle, in degrees.  For use with `n`.  Angle is in degrees counter-clockwise.  Default: 0
//   delta = [X,Y,Z] amount to move away from cp before rotating.  Makes rings of copies.  Default: `[0,0,0]`
//   subrot = If false, don't sub-rotate children as they are copied around the ring.  Instead maintain their native orientation.  The false setting is only allowed when `delta` is given.  Default: `true`
//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.
//
// Side Effects:
//   `$ang` is set to the rotation angle (or XYZ rotation triplet) of each child copy, and can be used to modify each child individually.
//   `$idx` is set to the index value of each child copy.
//   `$axis` is set to the axis to rotate around, if `rots` was given as a list of angles instead of a list of [X,Y,Z] rotation angles.
//
//
// Example:
//   #cylinder(h=20, r1=5, r2=0);
//   rot_copies([[45,0,0],[0,45,90],[90,-45,270]]) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   rot_copies([45, 90, 135], v=DOWN+BACK)
//       yrot(90) cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   rot_copies(n=6, v=DOWN+BACK)
//       yrot(90) cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   rot_copies(n=6, v=DOWN+BACK, delta=[10,0,0])
//       yrot(90) cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   rot_copies(n=6, v=UP+FWD, delta=[10,0,0], sa=45)
//       yrot(90) cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   rot_copies(n=6, v=DOWN+BACK, delta=[20,0,0], subrot=false)
//       yrot(90) cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);