module BB(
achse=5,
od=20,
h,
r,
ball,
rand=1,
e,
spiel=0.125,
support=0.15,
top,
cage=false,
cyl=true,
rad=[.5,.5],
pip=pip,
wFase,
cFase,
center=true,
name,
help

){
rad=is_num(rad)?[rad,rad]:rad;
rand=is_list(rand)?rand:[rand,rand]; 
top=is_undef(top)?rand[0]/2:top;
ball=max(is_undef(ball)?od/2-achse/2-vSum(rand)-spiel*2:
                        ball
                    ,2); // min ball size 2
h=is_undef(h)?ball+top*2:h;
r=max(is_undef(r)?is_undef(od)?achse/2+ball/2+rand[1]+spiel:
                          is_undef(achse)?od-ball/2-rand[0]-spiel:
                                          od/4+achse/4+(rand[1]-rand[0])/2:
             r
      ,ball/2+rand[1]);

walzen=wFase?true:false;
wFase=is_undef(wFase)?ball/4:wFase;
cFase=is_undef(cFase)?0:is_bool(cFase)&&cFase?wFase:walzen?cFase:0; // center

if(h<ball) Echo("BB h kleiner ball diameter",color="red");
if(h>ball+top*2||walzen) Echo("BB Kugel = Walze!",color="green");    
achseDia=is_undef(achse)?r*2-ball-2*rand[1]-2*spiel:min(r*2-ball-2*rand[1]-2*spiel,achse);
oDia=is_undef(od)? r*2+ball+2*rand[0]+2*spiel:max(od,r*2+ball+2*rand[0]+2*spiel);  
e=is_undef(e)?floor(360/gradS(r=r,s=ball+spiel)):min(e,floor(360/gradS(r=r,s=ball+spiel)));

if(achse&&achse>r*2-ball-2*rand[1]-2*spiel+.0000001)Echo(str("BB Achse (",achse,") zu groß - limited↦ ",achseDia),color="red"); 

if(od&&od<r*2+ball+2*rand[0]+2*spiel)Echo(str("BB OD (",od,") zu klein - limited↦ ",oDia),color="red");

  InfoTxt("BB",["Achse",achseDia,"Hoch",h,"OD",oDia,"Kugel∅",h>ball+top*2?str(ball,"×",h-top*2):ball,"Anzahl",e],name);


 
 Tz(center?0:h/2){
  $info=false;
  $helpM=false; 
// Roller
    Polar(e,r)if(h>ball+top*2||walzen)
      if(cFase){
        MKlon(tz=-.001)Pille(h/2-top,d=ball,rad=[cFase,wFase],fn2=walzen?1:0,center=false);
        cylinder(h=cFase*2,r=ball/2-cFase+.2,center=true);
      }
      else Pille(h-top*2,d=ball,rad=walzen?wFase:undef,fn2=walzen?1:0);
      else sphere(d=ball);
// Rings
    difference(){
        union(){
            //Pille(h,d=oDia,rad=rad[0]);//Body
            Loch(h=h,l=0,d=oDia,h2=rad[0],rad=rad[0],deg=-45,center=true,cuts=0,extrude=0);//Body
            Tz(center?0:-h/2)children();
        }
      if(achseDia) Loch(h=h,l=0,d=achseDia,h2=rad[1],rad=rad[1],deg=45,center=true,cuts=0);
      //Strebe(h,d=achseDia,rad=rad[1],center=true);// Achse    
        
        if(h>ball+top*2||walzen)Torus(trx=r,d=ball+spiel*2)
          if(!walzen)MKlon(mx=1)Pille(h-top*2+spiel*2,d=$d, use2D=+1);
          else if(cFase){
            MKlon(ty=-.001)Quad(ball+spiel*2,h/2-(top-spiel),rad=[wFase,wFase,cFase,cFase]+spiel*[1,1,0,0],fn=1,center=[1,0]);
            square([ball-cFase*2+.4+spiel*4,cFase*2],center=true);
            }
            else Quad(ball+spiel*2,h-(top-spiel)*2,rad=wFase+spiel,fn=1);
          
         else Torus(trx=r,d=ball+spiel*2);////Rille
        
        MKlon(tz=h/2+1.25)Torus(trx=r,d=ball,fn2=6);//innenfase
        if(walzen)Mklon(tz=h/2+sqrt(3)/2*(ball-wFase*2)-top-.001)Torus(trx=r,r=ball-wFase*2,fn2=6);//innenfase
        MKlon(tz=h/2-top-.5)Ring(h+1,d=r*2,rand=walzen?ball-wFase*2+spiel*2:ball/2,rcenter=true,center=false);//Trennspalt
    }
    
 if (cage) difference(){
    union(){
        if(h>ball+top*2||walzen)Torus(trx=r,d=ball+spiel*2-pip*2)
          if(!walzen)MKlon(mx=1)Pille(h-top*2+spiel*2-pip*2,d=$d, use2D=+1);
          else if(cFase){
            MKlon(ty=-.001)Quad(ball+(spiel-pip)*2,h/2-(top-spiel),rad=[wFase,wFase,cFase,cFase]+(spiel)*[1,1,0,0],fn=1,center=[1,0]);
            square([ball-cFase*2+.4+spiel*4-pip*2,cFase*2],center=true);
            }
          else Quad(ball+(spiel-pip)*2,h-(top-spiel-pip)*2,rad=(ball/2+spiel-pip)/2,fn=1);
          
         else Torus(trx=r,d=ball+spiel*2-pip*2);
        Ring(h=h,d=r*2,rand=ball/2,rcenter=true,center=true);
    }
    Polar(e,r){
      if(h>ball+top*2||walzen)Pille(h-top*2+pip*2,d=ball+pip*2,rad=walzen?wFase+pip:undef,fn2=walzen?1:0); else sphere(d=ball+pip*2);
      Tz(-h/2)cylinder(h=h,d=ball/2-.5+pip*2,center=true);
    }
    if(support) Tz(-h/2) Ring(h=top,d=r*2,rand=ball,rcenter=true,center=false);
 }  

//supportbrim
 if(support&&!cyl)difference(){
     Tz(-h/2)union(){
      Ring(h=walzen?top-support:top+.2,d=r*2,rand=ball/2-.5,rcenter=true,center=false);
      if(walzen)Polar(e,r)Kegel(d2=ball-wFase*2-support*2,d1=ball-wFase*2-top*2);
      }
     
     if(!walzen)if (h>ball+top*2) Tz(-h/2+top+ball/2)Polar(e,r)sphere(r=ball/2+support);
         else Polar(e,r)sphere(r=ball/2+support);
 }
 if(cyl)Tz(-h/2){
     Polar(e,r){
      cylinder(h=h/2,d=ball/2-.5);
      if(walzen)Tz(top+0.001)R(180)Kegel(d1=ball-wFase*2,d2=ball-wFase*2-top*2);
     }
     if(support)Ring(l(2),r=r,rand=n(2),rcenter=true);
 }
 }
HelpTxt("BB",["achse",achse,"od",od,"h",h,"r",r,"ball",ball,"rand",rand,"e",e,"spiel",spiel,"support",support,"top",top,"cage",cage,"cyl",cyl,"rad",rad,"pip",pip,"wFase",wFase,"cFase",cFase,"center",center,"name",name],help); 
}

/** \page Products
* \name Pin
Pin() creates a pin or Peg to fix or swivel with 45°(deg) lip
\param l length ↦ [bottom,top]
\param d diameter of core body
\param cut number incisions [bottom,top]
\param cutDepth  depth of the cuts
\param cutDeg   angle of cuts
\param mitte middle lip
\param lippe lip size (od=d+2×lip)
\param spiel lip height and clearance between connected parts
\param center center pin
\param deg   lip angle
\param flat  flat sides (true or num for thickness)
\param print orient for printing
\param fn fs  fraqments number size

*/

//Pin(l=[3,7],deg=[60,30]);
//Pin(10,flat=true,cut=4,grad=85);

/*
difference(){
  cube(20);
  Pin(spiel=0.2,cut=false);
  }
Cut()Pin();
//*/