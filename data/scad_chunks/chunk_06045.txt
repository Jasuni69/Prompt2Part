function path_copies(path, n, spacing, sp=undef, dist, rotate_children=true, dist, closed, p=_NO_ARG) =
    let(
        is_1reg = is_1region(path),
        path = is_1reg ? path[0] : path,
        closed = default(closed, is_1reg),
        length = path_length(path,closed),
        distind = is_def(dist) ? sortidx(dist) : undef,
        distances =
            is_def(dist) ? assert(is_undef(n) && is_undef(spacing) && is_undef(sp), "Can't use n, spacing or undef with dist")
                           select(dist,distind)
          : is_def(sp)? (   // Start point given
                is_def(n) && is_def(spacing)? count(n,sp,spacing) :
                is_def(n)? lerpn(sp, length, n) :
                list([sp:spacing:length])
            )
          : is_def(n) && is_undef(spacing)? lerpn(0,length,n,!closed) // N alone given
          : (      // No start point and spacing is given, N maybe given
            let(
                n = is_def(n)? n : floor(length/spacing)+(closed?0:1),
                ptlist = count(n,0,spacing),
                listcenter = mean(ptlist)
            ) closed?
                sort([for(entry=ptlist) posmod(entry-listcenter,length)]) :
                [for(entry=ptlist) entry + length/2-listcenter ]
          ),
        distOK = min(distances)>=0 && max(distances)<=length,
        dummy = assert(distOK,"Cannot fit all of the copies"),
        cutlist = path_cut_points(path, distances, closed, direction=true),
        planar = len(path[0])==2,
        mats = [
            for(i=[0:1:len(cutlist)-1])
            translate(cutlist[i][0]) * (
                !rotate_children? ident(4) :
                planar? rot(from=[0,1],to=cutlist[i][3]) :
                frame_map(x=cutlist[i][2], z=cutlist[i][3])
            )
        ]
    )
    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];



//////////////////////////////////////////////////////////////////////
// Section: Making a copy of all children with reflection
//////////////////////////////////////////////////////////////////////

// Function&Module: xflip_copy()
// Synopsis: Makes a copy of children mirrored across the X axis.
// SynTags: MatList, Trans
// Topics: Transformations, Distributors, Translation, Copiers
// See Also: yflip_copy(), zflip_copy(), mirror_copy(), path_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() 
//
// Usage:
//   xflip_copy([offset], [x]) CHILDREN;
// Usage: As a function to translate points, VNF, or Bezier patches
//   copies = xflip_copy([offset], [x], p=);
// Usage: Get Translation Matrices
//   mats = xflip_copy([offset], [x]);
//
// Description:
//   When called as a module, makes a copy of the children, mirrored across the X axis.
//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.
//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.
//
// Arguments:
//   offset = Distance to offset children right, before copying.
//   x = The X coordinate of the mirroring plane.  Default: 0
//   ---
//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.
//
// Side Effects:
//   `$orig` is true for the original instance of children.  False for the copy.
//   `$idx` is set to the index value of each copy.
//
//
// Example:
//   xflip_copy() yrot(90) cylinder(h=20, r1=4, r2=0);
//   color("blue",0.25) cube([0.01,15,15], center=true);
//
// Example:
//   xflip_copy(offset=5) yrot(90) cylinder(h=20, r1=4, r2=0);
//   color("blue",0.25) cube([0.01,15,15], center=true);
//
// Example:
//   xflip_copy(x=-5) yrot(90) cylinder(h=20, r1=4, r2=0);
//   color("blue",0.25) left(5) cube([0.01,15,15], center=true);