function vnf_triangulate(vnf) =
    let(
        verts = vnf[0],
        faces = [for (face=vnf[1])
                    each (len(face)==3 ? [face] :
                    let( tris = polygon_triangulate(verts, face) )
                    assert( tris!=undef, "\nSome VNF face cannot be triangulated.")
                    tris ) ]
    )
    [verts, faces];



// Function: vnf_unify_faces()
// Synopsis: Remove triangulation from VNF, returning a copy with full faces
// SynTags: VNF
// Topics: VNF Manipulation
// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_triangulate(), vnf_slice() 
// Usage:
//   newvnf = vnf_unify_faces(vnf);
// Description:
//   When a VNF has been triangulated, the polygons that form the true faces have been chopped up into
//   triangles.  This can create problems for algorithms that operate on the VNF itself, where you might
//   want to be able to identify the true faces.  This function merges together the triangles that
//   form those true faces, turning a VNF where each true face is represented by a single entry
//   in the faces list of the VNF.  This function requires that the true faces have no internal vertices.
//   This is always true for a triangulated VNF, but might fail for a VNF with some other
//   face partition. If internal vertices are present, the output includes backtracking paths from
//   the boundary to all of those vertices.
// Arguments:
//   vnf = vnf whose faces you want to unify
// Example(3D,Med,NoAxes): Original prism on the left is triangulated.  On the right, the result of unifying the faces.
//   $fn=16;
//   poly = linear_sweep(hexagon(side=10),h=35);
//   vnf = vnf_unify_faces(poly);
//   vnf_wireframe(poly);
//   color([0,1,1,.70])vnf_polyhedron(poly);
//   right(25){
//     vnf_wireframe(vnf);
//     color([0,1,1,.70])vnf_polyhedron(vnf);
//   }