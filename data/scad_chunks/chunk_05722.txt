function vnf_tri_array(
    points,
    caps, cap1, cap2,
    col_wrap=false,
    row_wrap=false,
    reverse=false,
    limit_bunching=true
) =
    assert(!(any([caps,cap1,cap2]) && row_wrap), "\nCannot combine caps with row_wrap.")
    let(
        plen = len(points),
        // append first vertex of each polygon to its end if wrapping columns
        st = col_wrap ? [
            for(i=[0:plen-1])
            points[i][0] != points[i][len(points[i])-1]
                ? concat(points[i], [points[i][0]])
                : points[i]
        ] : points,
        addcol = col_wrap ? len(st[0])-len(points[0]) : 0,
        rowstarts = [ for(i=[0:plen-1]) len(st[i]) ],
        capfirst = first_defined([cap1,caps,false]),
        caplast = first_defined([cap2,caps,false]),
        pcumlen = [0, each cumsum(rowstarts)],
        faces = flatten([
            // close first end
            if (capfirst)
                if (reverse) [[ for(i=[0:rowstarts[0]-1-addcol]) i ]]
                else [[ for(i=[rowstarts[0]-1-addcol:-1:0]) i ]],
            // triangulate between the two polygons
            for(i = [0:plen-2+(row_wrap?1:0)])
                let(
                    j = (i+1)%plen,
                    max_extra_edges = limit_bunching ? max(1, abs(len(st[i])-len(st[j]))) : INF
                ) _lofttri(st[i], st[j], pcumlen[i], pcumlen[j], rowstarts[i], rowstarts[j], reverse, trimax=max_extra_edges),
            // close up the last end
            if (caplast)
                if (reverse) [[ for(i=[pcumlen[plen]-1-addcol:-1:pcumlen[plen-1]]) i ]]
                else [[ for(i=[pcumlen[plen-1]:pcumlen[plen]-1-addcol]) i ]]
        ]),
        vnf = [flatten(st), faces]
    ) col_wrap ? vnf_merge_points(vnf) : vnf;

/*
Recursively triangulate between two 3D paths (which can be different
in length by any amount), starting at index 0 and generate a list of
triangles with minimum new-side length.
The first side of the first triangle always connects the two first
vertices of each path.
To triangulate between two closed paths, the first and last vertices
must be the same.
Parameters:
    p1 = first path, an array of [x,y,z] vertices
    p2 = second path, an array of [x,y,z] vertices
    i1offset = index offset of first vertex in the first path
        (sum of any prior path lengths)
    i2offset = index offset of first vertex in the second path
        (sum of any prior path lengths)
    n1 = number of vertices in first path
    n2 = number of vertices in second path
    reverse = if true, assume a polygon path goes around
        counterclockwise with respect to the direction from
        p1 to p2 (right hand rule), clockwise if false
Other parameters are for internal use:
    trilist[] = array of triangles to return
    i1 = vertex index on p1 of the next triangle
    i2 = vertex index on p2 of the next triangle
    tricount1 = number extra triangles generated on vertex i2 to row p1
    tricount2 = number extra triangles generated on vertex i1 to row p2
    trimax = max number of extra triangles that can be created on any point in a row
(next triangle vertex found can be on either p1 or p2, depending
on which triangle is smaller.)

Returns an array of triangles using vertex indices offset by
i1offset and i2offset
*/