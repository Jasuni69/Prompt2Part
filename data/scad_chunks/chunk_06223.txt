function textured_tile(
    texture, 
    size,
    ysize, height, w1, w2, ang, h, shift, thickness,
    tex_size,
    tex_reps,       
    tex_inset=false,
    tex_rot=0,      
    tex_depth=1,    
    style="min_edge",
    atype="tex",
    tex_extra,
    tex_skip=0,
    anchor, spin=0, orient=UP,
    _return_anchor=false
) =
    assert(in_list(atype,["tex","std"]), "atype must be \"tex\" or \"std\"")
    assert(is_undef(tex_reps) || is_int(tex_reps) || (all_integer(tex_reps) && len(tex_reps)==2), "tex_reps must be an integer or list of two integers")
    assert(is_undef(tex_size) || is_vector(tex_size,2) || is_finite(tex_size))
    assert(num_defined([tex_size, tex_reps])==1, "Must give exactly one of tex_size and tex_reps")
    assert(is_undef(size) || is_num(size) || is_vector(size,2) || is_vector(size,3), "size must be a 2-vector or 3-vector")
    assert(is_undef(size) || num_defined([ysize,h, height, thickness, w1,w2,ang])==0, "Cannot combine size with any other dimensional specifications")
    let(
        anchor = default(anchor, atype=="tex" ? BOTTOM : CENTER), 
        inset = is_num(tex_inset)? tex_inset : tex_inset? 1 : 0,
        default_thick = inset>0 ? 0.1+abs(tex_depth)*inset : 0.1,
        extra_ht = max(0,abs(tex_depth)*(1-inset)),
        h_w1_w2_shift = is_def(size) ? undef
                      : assert(is_undef(ysize) || is_finite(ysize))
                        assert(is_undef(w1) || is_finite(w1))
                        assert(is_undef(w2) || is_finite(w2))
                        assert(is_undef(ang) || is_finite(ang) || is_vector(ang,2))
                        assert(num_defined([ysize, w1, w2, ang]) == 3, "Must give exactly 3 of the arguments ysize, w1, w2, and angle.")
                        assert(is_undef(shift) || is_finite(shift))
                        assert(num_defined([shift,ang])<2, "Cannot specify shift and ang together")
                        _trapezoid_dims(ysize,w1,w2,shift,ang),
        ysize=h_w1_w2_shift[0],
        w1=h_w1_w2_shift[1],
        w2=h_w1_w2_shift[2],
        shift=h_w1_w2_shift[3],
        height = is_def(size) ? default(size.z,default_thick) : one_defined([h,height,thickness],"h,height,thickness",dflt=default_thick),
        size = is_def(size) ? is_num(size) ? [size,size,1] : point3d(size,1)        // We only use the x and y components of size
             : [w1,ysize],

        texture = _get_texture(texture, tex_rot),
        
        tex_reps = is_def(tex_reps) ? force_list(tex_reps,2)
                 : let(tex_size=force_list(tex_size,2))
                   [round(size.x/tex_size.x), round(size.y/tex_size.y)],
        extra = is_undef(tex_extra)? tex_reps == [1,1] ? [0,0] : [1,1]
                                   : force_list(tex_extra,2), 
        skip = force_list(tex_skip,2), 
        scale = [size.x/tex_reps.x, size.y/tex_reps.y],
        setz=function (v,z)  [v.x,v.y,z], 
        vnf = !is_vnf(texture) ?
                    let(         
                        texsteps = [len(texture[0]), len(texture)], 
                        xn=tex_reps.x*texsteps.x+extra.x-skip.x,
                        yn=tex_reps.y*texsteps.y+extra.y-skip.y,
                        checks = assert(yn>=2, "Skipped too many points in the y direction: decrease skip.y")
                                 assert(xn>=2, "Skipped too many points in the x direction: decrease skip.x"),
                        xpts=lerpn(-size.x/2,size.x/2,xn),
                        ypts=lerpn(size.y/2,-size.y/2,yn),
                        scaled_tex = tex_depth < 0 ? [for(row=texture) [for(p=row) -(1-p-inset)*tex_depth]]
                                                   : [for(row=texture) [for(p=row)  (p-inset)*tex_depth]],
                        check = [for(row=scaled_tex, p=row) if (p<=-height) p],
                        dummy=assert(check==[], str("texture extends too far below zero (",min([each check,0]),") to fit entirely within height ",height)),
                        pts=[for(y=idx(ypts))
                               [ [xpts[0],ypts[y],-height/2],
                                 for(x=idx(xpts))
                                   [xpts[x],ypts[y], height/2 + scaled_tex[(y+skip.y)%texsteps.y][(x+skip.x)%texsteps.x]],
                                 [last(xpts), ypts[y], -height/2]
                               ]
                             ]
                    )
                    vnf_vertex_array(pts,col_wrap=true,caps=true,style=style)
            :
                let(
                    zadj_vnf = [
                                  [for(p=texture[0]) [p.x, p.y, height/2 + _tex_height(tex_depth,inset,p.z)]],
                                  texture[1]
                               ],
                    minz = min(column(zadj_vnf[0],2)),
                    dummy=assert(minz>-height/2, str("texture extends too far below zero (",minz-height/2,") to fit entirely within height ",height)),
                    
                    scaled_vnf = scale(scale, zadj_vnf), 
                    tiled_vnf = [for(i=[0:1:tex_reps.x-1], j=[0:1:tex_reps.y-1]) move([scale.x*i,scale.y*j], scaled_vnf)],

                    yedge_list = _tile_edge_path_list(zadj_vnf, 0),
                    xedge_list = _tile_edge_path_list(zadj_vnf, 1),

                    front_back_closed = [for(i=[0:1:tex_reps.x-1], cpath=xedge_list[1])
                                                                  each [[xscale(scale.x,xmove(i,cpath)), [count(cpath)]],
                                                                        [xscale(scale.x,move([i,size.y],cpath)),[count(cpath,reverse=true)]]]],
                    sides_closed = [for(j=[0:1:tex_reps.y-1], cpath=yedge_list[1])
                                                                  each [[yscale(scale.y,ymove(j,cpath)), [count(cpath)]],
                                                                        [yscale(scale.y,move([size.x, j], cpath)),[count(cpath,reverse=true)]]]],

                    leftpath = yedge_list[0]==[] ? []
                              : deduplicate([for(j=[0:1:tex_reps.y-1]) each reverse(yscale(scale.y,ymove(j,yedge_list[0][0])))]), 
                    frontpath = xedge_list[0]==[] ? []
                              : deduplicate([for(i=[0:1:tex_reps.x-1]) each xscale(scale.x,xmove(i,xedge_list[0][0]))]),

                    base = frontpath==[] || leftpath==[] ? [] 
                         : [
                            [
                             [setz(frontpath[0],-height/2),
                              each frontpath,
                              setz(last(frontpath), -height/2)
                             ],
                             [count(len(frontpath)+2)]
                           ],
                            [
                             [setz(last(leftpath),-height/2),
                              each reverse(leftpath),
                              setz(leftpath[0], -height/2)
                             ],
                             [count(len(leftpath)+2)]
                           ],
                            [
                             back(size.y,
                             [setz(last(frontpath),-height/2),
                              each reverse(frontpath),
                              setz(frontpath[0],-height/2)
                             ]),
                             [count(len(frontpath)+2)]
                           ],
                            [right(size.x,
                             [setz(leftpath[0],-height/2),
                              each leftpath,
                              setz(last(leftpath),-height/2)
                             ]),
                             [count(len(leftpath)+2)]
                           ]
                            ],

                    bottom = [path3d(rect(point2d(size),anchor=FWD+LEFT),-height/2), [[3,2,1,0]]],
                    result = vnf_join(concat(tiled_vnf,front_back_closed, sides_closed,base,[bottom])) 
                )
                move([-size.x/2,-size.y/2],result),
        trans_vnf = is_undef(h_w1_w2_shift) ? vnf
                  : let(
                        newpts = [for(p=vnf[0])
                                    let(factor=p.y/ysize+1/2)
                                    [lerp(1,w2/w1,factor)*p.x+factor*shift, p.y, p.z]]
                    )
                    [newpts, vnf[1]],
        anch_ht = atype=="tex" ? extra_ht : height,
        shifted_vnf = down(atype=="tex" ? height/2+extra_ht/2 : 0, trans_vnf),
        geom = is_def(h_w1_w2_shift) ? atype=="std" ? attach_geom(axis=BACK, size=[w1,anch_ht,ysize],size2=[w2,anch_ht],shift=[-shift,0])
                                                    : attach_geom(axis=BACK, size=[w1,anch_ht,ysize],size2=[w2,anch_ht],shift=[-shift,0])
                                     : attach_geom(size=[size.x,size.y,anch_ht])
    )
    _return_anchor ? [reorient(anchor,spin,orient,geom=geom,p=shifted_vnf), [size.x,size.y,height],h_w1_w2_shift]
                   : reorient(anchor,spin,orient,geom=geom,p=shifted_vnf);



// Module: rect_tube()
// Synopsis: Creates a rectangular tube.
// SynTags: Geom
// Topics: Shapes (3D), Attachable, VNF Generators
// See Also: tube()
// Usage: Typical Rectangular Tubes
//   rect_tube(h, size, isize, [center], [shift]);
//   rect_tube(h, size, wall=, [center=]);
//   rect_tube(h, isize=, wall=, [center=]);
// Usage: Tapering Rectangular Tubes
//   rect_tube(h, size1=, size2=, wall=, ...);
//   rect_tube(h, isize1=, isize2=, wall=, ...);
//   rect_tube(h, size1=, size2=, isize1=, isize2=, ...);
// Usage: Chamfered
//   rect_tube(h, size, isize, chamfer=, ...);
//   rect_tube(h, size, isize, chamfer1=, chamfer2= ...);
//   rect_tube(h, size, isize, ichamfer=, ...);
//   rect_tube(h, size, isize, ichamfer1=, ichamfer2= ...);
//   rect_tube(h, size, isize, chamfer=, ichamfer=, ...);
// Usage: Rounded
//   rect_tube(h, size, isize, rounding=, ...);
//   rect_tube(h, size, isize, rounding1=, rounding2= ...);
//   rect_tube(h, size, isize, irounding=, ...);
//   rect_tube(h, size, isize, irounding1=, irounding2= ...);
//   rect_tube(h, size, isize, rounding=, irounding=, ...);
// Usage: Attaching Children
//   rect_tube(...) ATTACHMENTS;
//
// Description:
//   Creates a rectangular or prismoid tube with optional roundovers and/or chamfers.
//   You can only round or chamfer the vertical(ish) edges.  For those edges, you can
//   specify rounding and/or chamferring per-edge, and for top and bottom, inside and
//   outside  separately.
//   .
//   By default if you specify a chamfer or rounding then it applies as specified to the
//   outside, and an inside rounding is calculated that will maintain constant width
//   if your wall thickness is uniform.  If the wall thickness is not uniform, the default
//   inside rounding is calculated based on the smaller of the two wall thicknesses.
//   Note that the values of the more specific chamfers and roundings inherit from the
//   more general ones, so `rounding2` is determined from `rounding`.  The constant
//   width default will apply when the inner rounding and chamfer are both undef.
//   You can give an inner chamfer or rounding as a list with undef entries if you want to specify
//   some corner roundings and allow others to be computed.  
// Arguments:
//   h/l/height/length = The height or length of the rectangular tube.  Default: 1
//   size = The outer [X,Y] size of the rectangular tube.
//   isize = The inner [X,Y] size of the rectangular tube.
//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=UP`.
//   shift = [X,Y] amount to shift the center of the top end with respect to the center of the bottom end.
//   ---
//   wall = The thickness of the rectangular tube wall.
//   size1 = The [X,Y] size of the outside of the bottom of the rectangular tube.
//   size2 = The [X,Y] size of the outside of the top of the rectangular tube.
//   isize1 = The [X,Y] size of the inside of the bottom of the rectangular tube.
//   isize2 = The [X,Y] size of the inside of the top of the rectangular tube.
//   rounding = The roundover radius for the outside edges of the rectangular tube.
//   rounding1 = The roundover radius for the outside bottom corner of the rectangular tube.
//   rounding2 = The roundover radius for the outside top corner of the rectangular tube.
//   chamfer = The chamfer size for the outside edges of the rectangular tube.
//   chamfer1 = The chamfer size for the outside bottom corner of the rectangular tube.
//   chamfer2 = The chamfer size for the outside top corner of the rectangular tube.
//   irounding = The roundover radius for the inside edges of the rectangular tube. Default: Computed for uniform wall thickness (see above)
//   irounding1 = The roundover radius for the inside bottom corner of the rectangular tube.
//   irounding2 = The roundover radius for the inside top corner of the rectangular tube.
//   ichamfer = The chamfer size for the inside edges of the rectangular tube.  Default: Computed for uniform wall thickness (see above)
//   ichamfer1 = The chamfer size for the inside bottom corner of the rectangular tube.
//   ichamfer2 = The chamfer size for the inside top corner of the rectangular tube.
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `BOTTOM`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
// Examples:
//   rect_tube(size=50, wall=5, h=30);
//   rect_tube(size=[100,60], wall=5, h=30);
//   rect_tube(isize=[60,80], wall=5, h=30);
//   rect_tube(size=[100,60], isize=[90,50], h=30);
//   rect_tube(size1=[100,60], size2=[70,40], wall=5, h=30);
// Example:
//   rect_tube(
//       size1=[100,60], size2=[70,40],
//       isize1=[40,20], isize2=[65,35], h=15
//   );
// Example: With rounding
//   rect_tube(size=100, wall=5, rounding=10, h=30);
// Example: With rounding
//   rect_tube(size=100, wall=5, chamfer=10, h=30);
// Example: Outer Rounding Only
//   rect_tube(size=100, wall=5, rounding=10, irounding=0, h=30);
// Example: Outer Chamfer Only
//   rect_tube(size=100, wall=5, chamfer=5, ichamfer=0, h=30);
// Example: Outer Rounding, Inner Chamfer
//   rect_tube(size=100, wall=5, rounding=10, ichamfer=8, h=30);
// Example: Inner Rounding, Outer Chamfer
//   rect_tube(size=100, wall=5, chamfer=10, irounding=8, h=30);
// Example: Gradiant Rounding
//   rect_tube(
//       size1=100, size2=80, wall=5, h=30,
//       rounding1=10, rounding2=0,
//       irounding1=8, irounding2=0
//   );
// Example: Per Corner Rounding
//   rect_tube(
//       size=100, wall=10, h=30,
//       rounding=[0,5,10,15], irounding=0
//   );
// Example: Per Corner Chamfer
//   rect_tube(
//       size=100, wall=10, h=30,
//       chamfer=[0,5,10,15], ichamfer=0
//   );
// Example: Mixing Chamfer and Rounding
//   rect_tube(
//       size=100, wall=10, h=30,
//       chamfer=[0,10,0,20], 
//       rounding=[10,0,20,0]
//   );
// Example: Really Mixing It Up
//   rect_tube(
//       size1=[100,80], size2=[80,60],
//       isize1=[50,30], isize2=[70,50], h=20,
//       chamfer1=[0,5,0,10], ichamfer1=[0,3,0,8],
//       chamfer2=[5,0,10,0], ichamfer2=[3,0,8,0],
//       rounding1=[5,0,10,0], irounding1=[3,0,8,0],
//       rounding2=[0,5,0,10], irounding2=[0,3,0,8]
//   );
// Example: Some interiors chamfered, others with default rounding
//   rect_tube(
//       size=100, wall=10, h=30,
//       rounding=[0,10,20,30], ichamfer=[8,8,undef,undef]
//   );