function _unique_groups(m) = [
    for (i=[0:1:len(m)-1]) let(
        s = search([m[i]], m, 0)[0]
    ) if (s[0]==i) s
];


// TODO
//
// Use volume info?
// Support choosing a face number down
// Support multiple inspheres/outspheres when appropriate?
// face order for children?
// orient faces so an edge is parallel to the x-axis
//


// Module: regular_polyhedron()
// Synopsis: Creates a regular polyhedron with optional rounding.
// SynTags: Geom
// Topics: Polyhedra, Shapes, Parts
// See Also: regular_polyhedron_info()
// Usage: Selecting a polyhedron
//   regular_polyhedron([name],[index=],[type=],[faces=],[facetype=],[hasfaces=],...) [CHILDREN];
// Usage: Controlling the size and position of the polyhedron
//   regular_polyhedron(..., [or=|r=|d=],[ir=],[mr=],[side=],[facedown=],[anchor=], ...) [CHILDREN];]
// Usage: Other options that change the polyhedron or handling of children
//   regular_polyhedron(..., [draw=], [rounding=], [stellate=], [repeat=], [rotate_children=]) [CHILDREN];
// Usage: options only for the trapezohedron
//   regular_polyhedron("trapezohedron", [longside=],[h=], ...) [CHILDREN];
// Description:
//   Creates a regular polyhedron with optional rounding.  Children are placed on the polyhedron's faces.  (Note that this is not attachable.)
//   The regular_polyhedron module knows about many different regular and semi-regular polyhedra.  You can refer to them
//   by name.  The complete list with their names appears below in the examples.  You can also search the polyhedra
//   for ones that meet various critera using `type=`, `faces=`, `facetype=` or `hasfaces=`.  This will result in a list of polyhedra in a
//   canonical order that might include several options.  By default if you give specifications that produce several polyhedra, the first
//   one will be returned.  You can use the `index=` argument to select others from your list of hits.  Examples of polyhedron selection appear
//   after the full list of polyhedra below.  
//   .
//   **Selecting the polyhedron:**
//   You constrain the polyhedra list by specifying different characteristics, that must all be met
//   * `name`: e.g. `"dodecahedron"` or `"pentagonal icositetrahedron"`.  The name fully identifies the polyhedron, so no other characteristic should be given.
//   * `type`: Options are `"platonic"`, `"archimedean"` and `"catalan"`
//   * `faces`: The required number of faces
//   * `facetype`: The required face type(s).  List of vertex counts for the faces.  Exactly the listed types of faces must appear:
//     * `facetype = 3`: polyhedron with all triangular faces.
//     * `facetype = [5,6]`: polyhedron with only pentagons and hexagons. (Must have both!)
//   * hasfaces: The list of vertex counts for faces; at least one listed type must appear:
//     * `hasfaces = 3`: polygon has at least one triangular face
//     * `hasfaces = [5,6]`: polygon has a hexagonal or a pentagonal face
//   .
//   The result is a list of selected polyhedra.  You then specify `index` to choose which one of the
//   remaining polyhedra you want.  If you don't give `index` the first one on the list is created.
//   Two examples:
//   * `faces=12, index=2`:  Creates the 3rd solid with 12 faces
//   * `type="archimedean", faces=14`: Creates the first archimedean solid with 14 faces (there are 3)
//   .
//   **Choosing the size of your polyhedron:**
//   The default is to create a polyhedron whose smallest edge has length 1.  You can specify the
//   smallest edge length with the size option.  Alternatively you can specify the size of the
//   inscribed sphere, midscribed sphere, or circumscribed sphere using `ir`, `mr` and `cr` respectively.
//   If you specify `cr=3` then the outermost points of the polyhedron will be 3 units from the center.
//   If you specify `ir=3` then the innermost faces of the polyhedron will be 3 units from the center.
//   For the platonic solids every face meets the inscribed sphere and every corner touches the
//   circumscribed sphere.  For the Archimedean solids the inscribed sphere will touch only some of
//   the faces and for the Catalan solids the circumscribed sphere meets only some of the corners.
//   .
//   **Orientation:**
//   Orientation is controled by the facedown parameter.  Set this to false to get the canonical orientation.
//   Set it to true to get the largest face oriented down.  If you set it to a number the module searches for
//   a face with the specified number of vertices and orients that face down.
//   .
//   **Rounding:**
//   If you specify the rounding parameter the module makes a rounded polyhedron by first creating an
//   undersized model and then expanding it with `minkowski()`.  This only produces the correct result
//   if the in-sphere contacts all of the faces of the polyhedron, which is true for the platonic, the
//   catalan solids and the trapezohedra but false for the archimedean solids.
//   .
//   **Children:**
//   The module places children on the faces of the polyhedron.  The child coordinate system is
//   positioned so that the origin is the center of the face.  If `rotate_children` is true (default)
//   then the coordinate system is oriented so the z axis is normal to the face, which lies in the xy
//   plane.  If you give `repeat=true` (default) the children are cycled through to cover all faces.
//   With `repeat=false` each child is used once.  You can specify `draw=false` to suppress drawing of
//   the polyhedron, e.g. to use for `difference()` operations.  The module sets various parameters
//   you can use in your children (see the side effects list below).
//   .
//   **Stellation:**
//   Technically stellation is an operation of shifting the polyhedron's faces to produce a new shape
//   that may have self-intersecting faces.  OpenSCAD cannot handle self-intersecting faces, so we
//   instead erect a pyramid on each face, a process technically referred to as augmentation.  The
//   height of the pyramid is given by the `stellate` argument.  If `stellate` is `false` or `0` then
//   no stellation is performed.  Otherwise stellate gives the pyramid height as a multiple of the
//   edge length.  A negative pyramid height can be used to perform excavation, where a pyramid is
//   removed from each face.
//   .
//   **Special Polyhedra:**
//   These can be selected only by name and may require different parameters, or ignore some standard
//   parameters.
//   * Trapezohedron: a family of solids with an even number of kite shaped sides.
//     One example of a trapezohedron is the d10 die, which is a 10 face trapezohedron.
//     You must specify exactly two of `side`, `longside`, `h` (or `height`), and `r` (or `d`).
//     You cannot create trapezohedron shapes using `mr`, `ir`, or `or`.
//     * `side`: Length of the short side.
//     * `longside`: Length of the long side that extends to the apex.
//     * `h` or `height`: Distance from the center to the apex.
//     * `r`: Radius of the polygon that defines the equatorial vertices.
//     * `d`: Diameter of the polygon that defines the equatorial vertices.
//   .
//   * Named stellations: various polyhedra such as three of the four Kepler-Poinsot solids are stellations with
//    specific pyramid heights.  To make them easier to generate you can specify them by name.
//    This is equivalent to giving the name of the appropriate base solid and the magic stellate
//    parameter needed to produce that shape.  The supported solids are:
//     * `"great dodecahedron"`
//     * `"small stellated dodecahedron"`
//     * `"great stellated dodecahedron"`
//     * `"small triambic icosahedron"` (not a Kepler-Poinsot solid)
//
// Arguments:
//   name = Name of polyhedron to create.
//   ---
//   type = Type of polyhedron: "platonic", "archimedean", "catalan".
//   faces = Number of faces.
//   facetype = Scalar or vector listing required type of faces as vertex count.  Polyhedron must have faces of every type listed and no other types.
//   hasfaces = Scalar of vector list face vertex counts.  Polyhedron must have at least one of the listed types of face.
//   index = Index to select from polyhedron list.  Default: 0.
//   side = Length of the smallest edge of the polyhedron.  Default: 1 (if no radius or diameter is given).  
//   ir = inner radius.  Polyhedron is scaled so it has the specified inner radius. 
//   mr = middle radius.  Polyhedron is scaled so it has the specified middle radius.  
//   or / r / d = outer radius.   Polyhedron is scaled so it has the specified outer radius. 
//   anchor = Side of the origin to anchor to.  The bounding box of the polyhedron is aligned as specified.  Default: `CENTER`
//   facedown = If false display the solid in native orientation.  If true orient it with a largest face down.  If set to a vertex count, orient it so a face with the specified number of vertices is down.  Default: true.
//   rounding = Specify a rounding radius for the shape.  Note that depending on $fn the dimensions of the shape may have small dimensional errors.
//   repeat = If true then repeat the children to fill all the faces.  If false use only the available children and stop.  Default: true.
//   draw = If true then draw the polyhedron.  If false, draw the children but not the polyhedron.  Default: true.
//   rotate_children = If true then orient children normal to their associated face.  If false orient children to the parent coordinate system.  Default: true.
//   stellate = Set to a number to erect a pyramid of that height on every face of your polyhedron.  The height is a multiple of the side length.  Default: false.
//   longside = Specify the long side length for a trapezohedron.  Invalid for other shapes.
//   h = Specify the height of the apex for a trapezohedron.  Invalid for other shapes.
//
// Side Effects:
//   `$faceindex` - Index number of the face
//   `$face` - Coordinates of the face (2d if rotate_children==true, 3d if not)
//   `$center` - Face center in the child coordinate system
//
// Examples: All of the available polyhedra by name in their native orientation
//   regular_polyhedron("tetrahedron", facedown=false);
//   regular_polyhedron("cube", facedown=false);
//   regular_polyhedron("octahedron", facedown=false);
//   regular_polyhedron("dodecahedron", facedown=false);
//   regular_polyhedron("icosahedron", facedown=false);
//   regular_polyhedron("truncated tetrahedron", facedown=false);
//   regular_polyhedron("truncated octahedron", facedown=false);
//   regular_polyhedron("truncated cube", facedown=false);
//   regular_polyhedron("truncated icosahedron", facedown=false);
//   regular_polyhedron("truncated dodecahedron", facedown=false);
//   regular_polyhedron("cuboctahedron", facedown=false);
//   regular_polyhedron("icosidodecahedron", facedown=false);
//   regular_polyhedron("rhombicuboctahedron", facedown=false);
//   regular_polyhedron("rhombicosidodecahedron", facedown=false);
//   regular_polyhedron("truncated cuboctahedron", facedown=false);
//   regular_polyhedron("truncated icosidodecahedron", facedown=false);
//   regular_polyhedron("snub cube", facedown=false);
//   regular_polyhedron("snub dodecahedron", facedown=false);
//   regular_polyhedron("triakis tetrahedron", facedown=false);
//   regular_polyhedron("tetrakis hexahedron", facedown=false);
//   regular_polyhedron("triakis octahedron", facedown=false);
//   regular_polyhedron("pentakis dodecahedron", facedown=false);
//   regular_polyhedron("triakis icosahedron", facedown=false);
//   regular_polyhedron("rhombic dodecahedron", facedown=false);
//   regular_polyhedron("rhombic triacontahedron", facedown=false);
//   regular_polyhedron("deltoidal icositetrahedron", facedown=false);
//   regular_polyhedron("deltoidal hexecontahedron", facedown=false);
//   regular_polyhedron("disdyakis dodecahedron", facedown=false);
//   regular_polyhedron("disdyakis triacontahedron", facedown=false);
//   regular_polyhedron("pentagonal icositetrahedron", facedown=false);
//   regular_polyhedron("pentagonal hexecontahedron", facedown=false);
//   regular_polyhedron("trapezohedron",faces=10, side=1, longside=2.25, facedown=false);
//   regular_polyhedron("great dodecahedron");
//   regular_polyhedron("small stellated dodecahedron");
//   regular_polyhedron("great stellated dodecahedron");
//   regular_polyhedron("small triambic icosahedron");
// Example: Third Archimedean solid
//   regular_polyhedron(type="archimedean", index=2);
// Example(Med): Solids that have at least one face with either 8 vertices or 10 vertices
//   N = len(regular_polyhedron_info("index set", hasfaces=[8,10]));
//   for(i=[0:N-1]) right(3*i)
//     regular_polyhedron(hasfaces=[8,10], index=i, mr=1);
// Example(Big): Solids that include a quadrilateral face
//   N = len(regular_polyhedron_info("index set", hasfaces=4));
//   for(i=[0:N-1]) right(3*i)
//     regular_polyhedron(hasfaces=4, index=i, mr=1);
// Example(Med): Solids with only quadrilateral faces
//   N = len(regular_polyhedron_info("index set", facetype=4));
//   for(i=[0:N-1]) right(3*i)
//     regular_polyhedron(facetype=4, index=i, mr=1);
// Example: Solids that have both pentagons and hexagons and no other face types
//   N = len(regular_polyhedron_info("index set", facetype=[5,6]));
//   for(i=[0:N-1]) right(3*i)
//     regular_polyhedron(facetype=[5,6], index=i, mr=1);
// Example: Rounded octahedron
//   regular_polyhedron("octahedron", side=1, rounding=.2);
// Example: Rounded catalon solid
//   regular_polyhedron("rhombic dodecahedron", side=1, rounding=0.2);
// Example(Med): Rounded Archimedean solid compared to unrounded version.  The small faces are shifted back from their correct position.
//   %regular_polyhedron(type="archimedean", mr=1, rounding=0);
//   regular_polyhedron(type="archimedean", mr=1, rounding=0.3);
// Example: Two children are distributed arbitrarily over the faces
//   regular_polyhedron(faces=12,index=2,repeat=true) {
//     color("red") sphere(r=.1);
//     color("green") sphere(r=.1);
//   }
// Example(FlatSpin,VPD=100): Difference the children from the polyhedron; children depend on $faceindex
//   difference(){
//     regular_polyhedron("tetrahedron", side=25);
//     regular_polyhedron("tetrahedron", side=25,draw=false)
//       down(.3) linear_extrude(height=1)
//         text(str($faceindex),halign="center",valign="center");
//   }
// Example(Big): With `rotate_children` you can control direction of the children.
//   regular_polyhedron(name="tetrahedron", anchor=UP, rotate_children=true)
//     cylinder(r=.1, h=.5);
//   right(2) regular_polyhedron(name="tetrahedron", anchor=UP, rotate_children=false)
//     cylinder(r=.1, h=.5);
// Example(FlatSpin,Med,VPD=15): Using `$face` you can have full control of the construction of your children.  This example constructs the Great Icosahedron, the one Kepler-Poinsot solid that cannot be made directly with {{regular_polyhedron()}}.  
//   module makestar(pts) {    // Make a star from a point list
//       polygon(
//         [
//           for(i=[0:len(pts)-1]) let(
//             p0=select(pts,i),
//             p1=select(pts,i+1),
//             center=(p0+p1)/2,
//             v=sqrt(7/4-PHI)*(p1-p0)
//           ) each [p0, [v.y+center.x, -v.x+center.y]]
//         ]
//       );
//   }
//   regular_polyhedron("dodecahedron", side=1, repeat=true)
//   linear_extrude(scale=0, height=sqrt((5+2*sqrt(5))/5)) makestar($face);
// Example(Med): The spheres are all radius 1 and the octahedra are sized to match the in-sphere, mid-sphere and out-sphere.  The sphere size is slightly adjusted for the in-sphere and out-sphere so you can see the relationship: the sphere is tangent to the faces for the former and the corners poke out for the latter.  Note also the difference in the size of the three octahedra.
//   sphere(r=1.005);
//   %regular_polyhedron("octahedron", ir=1, facedown=false);
//   right(3.5) {
//     sphere(r=1);
//     %regular_polyhedron("octahedron", mr=1, facedown=false);
//   }
//   right(6.5) {
//     %sphere(r=.95);  // Slightly undersized sphere means the points poke out a bit
//     regular_polyhedron("octahedron", or=1,facedown=false);
//   }
// Example(Med): For the Archimdean solids the in-sphere does not touch all of the faces, as shown by this example, but the circumscribed sphere meets every vertex.  (This explains the problem for rounding over these solids because the rounding method uses the in-sphere.)
//   sphere(r=1.005);
//   %regular_polyhedron("snub dodecahedron", ir=1, facedown=false);
//   right(3) {
//     sphere(r=1);
//     %regular_polyhedron("snub dodecahedron", mr=1, facedown=false);
//   }
//   right(6) {
//     %sphere(r=.99);
//     regular_polyhedron("snub dodecahedron", or=1,facedown=false);
//   }
// Example(Med): For a Catalan solid the in-sphere touches every face but the circumscribed sphere only touches some vertices.
//   sphere(r=1.002);
//   %regular_polyhedron("pentagonal hexecontahedron", ir=1, facedown=false);
//   right(3) {
//     sphere(r=1);
//     %regular_polyhedron("pentagonal hexecontahedron", mr=1, facedown=false);
//   }
//   right(6) {
//     %sphere(r=.98);
//     regular_polyhedron("pentagonal hexecontahedron", or=1,facedown=false);
//   }
// Example: Stellate an Archimedian solid, which has mixed faces
//   regular_polyhedron("truncated icosahedron",stellate=1.5,or=1);
// Example: Stellate a Catalan solid where faces are not regular
//   regular_polyhedron("triakis tetrahedron",stellate=0.5,or=1);