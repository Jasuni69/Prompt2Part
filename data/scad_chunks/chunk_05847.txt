function _bt_search(query, r, points, tree) = 
    assert( is_list(tree) 
            && (   ( len(tree)==1 && is_list(tree[0]) )
                || ( len(tree)==4 && is_num(tree[0]) && is_num(tree[1]) ) ), 
            "\nThe tree is invalid.")
    len(tree)==1 
    ?   assert( tree[0]==[] || is_vector(tree[0]), "\nThe tree is invalid." )
        [for(i=tree[0]) if(norm(points[i]-query)<=r) i ]
    :   norm(query-points[tree[0]]) > r+tree[1] ? [] :
        concat( 
            [ if(norm(query-points[tree[0]])<=r) tree[0] ],
            _bt_search(query, r, points, tree[2]),
            _bt_search(query, r, points, tree[3]) ) ;
     

// Function: vector_search_tree()
// Synopsis: Makes a distance search tree for a list of points.
// Topics: Search, Points, Closest
// See Also: vector_nearest(), vector_search()
// Usage:
//    tree = vector_search_tree(points,leafsize);
// Description:
//    Construct a search tree for the given list of points to be used as input
//    to the function `vector_search()`. The use of a tree speeds up the
//    search process. The tree construction stops branching when 
//    a tree node represents a number of points less or equal to `leafsize`.
//    Search trees are ball trees. Constructing the
//    tree should be O(n log n) and searches should be O(log n), although real life
//    performance depends on how the data is distributed, and it deteriorates
//    for high data dimensions.  This data structure is useful when you are
//    performing many searches of the same data, so that the cost of constructing 
//    the tree is justified. (See https://en.wikipedia.org/wiki/Ball_tree)
//    For a small lists of points, the search with a tree may be more expensive
//    than direct comparisons. The argument `treemin` sets the minimum length of 
//    the point set for which a tree search will be done by `vector_search`.
//    For an empty list of points it returns an empty list.
// Arguments:
//    points = list of points to store in the search tree.
//    leafsize = the size of the tree leaves. Default: 25
//    treemin = the minimum size of the point list for which a tree search is done. Default: 400
// Example: A set of four queries to find points within 1 unit of the query.  The circles show the search region and all have radius 1.  
//   $fn=32;
//   k = 2000;
//   points = random_points(k, scale=10, dim=2,seed=13333);
//   queries = [for(i=[3,7],j=[3,7]) [i,j]];
//   search_tree = vector_search_tree(points);
//   search_ind = vector_search(queries,1,search_tree);
//   move_copies(points) circle(r=.08);
//   for(i=idx(queries)){
//       color("blue") stroke(move(queries[i],circle(r=1)), closed=true, width=.08);
//       color("red")  move_copies(select(points, search_ind[i])) circle(r=.08);
//   }