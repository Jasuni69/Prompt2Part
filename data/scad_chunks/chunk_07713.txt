function KnurlP(r=10,h=20,depth=1,e=[10,10],scale=1,scaleZ=1,twist=0,grad=360,delta=[0,0],alt=0,depthCord=depthCord)=[
let(
  //alt=is_list(alt)?alt:[1],
  depth=is_list(depth)?depth:[depth],
  step=grad/e.x,
  stepZ=h/e.y/2,
  scaleRot=scaleZ,
  rot=grad/e.x/2
  )
 for(z=[0:e.y*2])
 let(
 r=scale==1?r:r-r*(1-scale)/e.y/2*z,

 stepZ=scaleZ==1?stepZ:stepZ-stepZ*(1-scaleZ)/e.y/2*z/2,
 depth=scaleZ==1?depth:depth-depth*(1-scaleZ)/e.y/2*z/2,
 delta=scaleZ==1?delta:delta-delta*(1-scaleZ)/e.y/2*z/2,
 stepRot=scaleRot==1?twist/e.y/2*z:twist/e.y/2*z-twist/e.y/2*(1-scaleRot)/e.y/2*z/2,

 )
  if(z%2) for(i=[0:grad==360?(e.x -1):e.x])
    let(
      rot=(i<e.x?rot:0),
      depth=i<e.x?depth:[0],
      deltaRot=gradS(delta.x,r=r+depth[i%len(depth)]-depthCord)
    )
    [cos(i*step+stepRot+rot+deltaRot)*(r+depth[(i+alt*floor(z/2))%len(depth)]-depthCord),sin(i*step+stepRot+rot+deltaRot)*(r+depth[(i+alt*floor(z/2))%len(depth)]-depthCord),z*stepZ+delta.y]
  else    for(i=[0:grad==360?(e.x -1):e.x])[cos(i*step+stepRot)*r,sin(i*step+stepRot)*r,z*stepZ]


];


points=KnurlP(r=r,h=h,depth=size.z,e=e,scale=scale,scaleZ=scaleZ,twist=twist,grad=grad,delta=delta,alt=alt);

fBottom=[[for(i=[0:loopX])i]];
fTop=[[for(i=[loopX:-1:0])e.y*2*(loopX +1)+i]];

fBody=[for(z=[0:e.y-1],i=[0:loopX])each[
[(1+i)%(loopX+1), 0+i, (loopX+1)+i]+[1,1,1]*(loopX+1)*2*z,// bottom
if((i+1)%con)[0+i, (loopX+1)*2+i, (loopX+1)+i]+[1,1,1]*(loopX+1)*2*z,// left
if(i%con)[(loopX+1)*2+(1+i)%(loopX+1), (1+i)%(loopX+1), (loopX+1)+i]+[1,1,1]*(loopX+1)*2*z,// left
[(1+i)%(loopX+1)+(loopX+1)*2, (loopX+1)+i, (loopX+1)*2+i]+[1,1,1]*(loopX+1)*2*z//top
]
];

faces=concat(
  fBottom,
  fTop,
  fBody
);

polyhedron(points,faces,convexity=convexity);
HelpTxt("Knurl",["r",r,"h",h,"size",size,"depth",depth,"e",e,"scale",scale,"scaleZ",scaleZ,"twist",twist,"grad",grad,"delta",delta,"alt",alt,"convexity",convexity,"name",name],help);
}