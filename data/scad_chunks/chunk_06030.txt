function rot_copies(rots=[], v, cp=[0,0,0], n, sa=0, offset=0, delta=[0,0,0], subrot=true, p=_NO_ARG) =
    assert(subrot || norm(delta)>0, "subrot can only be false if delta is not zero")
    let(
        sang = sa + offset,
        angs = !is_undef(n)?
            (n<=0? [] : [for (i=[0:1:n-1]) i/n*360+sang]) :
            rots==[]? [] :
            assert(!is_string(rots), "Argument rots must be an angle, a list of angles, or a range of angles.")
            assert(!is_undef(rots[0]), "Argument rots must be an angle, a list of angles, or a range of angles.")
            [for (a=rots) a],
        mats = [
            for (ang = angs)
            translate(cp) *
                rot(a=ang, v=v) *
                translate(delta) *
                rot(a=subrot? 0 : ang, v=v, reverse=true) *
                translate(-cp)
        ]
    )
    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];


// Function&Module: xrot_copies()
// Synopsis: Rotates copies of children around the X axis.
// SynTags: MatList, Trans
// Topics: Transformations, Distributors, Rotation, Copiers
// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() 
//
// Usage:
//   xrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]) CHILDREN;
//   xrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]) CHILDREN;
// Usage: As a function to translate points, VNF, or Bezier patches
//   copies = xrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=], p=);
//   copies = xrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=], p=);
// Usage: Get Translation Matrices
//   mats = xrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]);
//   mats = xrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]);
// Description:
//   When called as a module:
//   - Given an array of angles, rotates copies of the children to each of those angles around the X axis.
//   - If given a count `n`, makes that many copies, rotated evenly around the X axis.
//   - If given a radius `r` (or diameter `d`), distributes children around a ring of that size around the X axis.
//   - If given a centerpoint `cp`, centers the rotation around that centerpoint.
//   - If `subrot` is true, each child will be rotated in place to keep the same size towards the center when making rings.
//   - The first (unrotated) copy will be placed at the relative starting angle `sa`.
//   .
//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.
//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.
//
// Arguments:
//   rots = Optional array of rotation angles, in degrees, to make copies at.
//   cp = Centerpoint to rotate around.
//   ---
//   n = Optional number of evenly distributed copies to be rotated around the ring.
//   sa = Starting angle, in degrees.  For use with `n`.  Angle is in degrees counter-clockwise from Y+, when facing the origin from X+.  First unrotated copy is placed at that angle.
//   r = If given, makes a ring of child copies around the X axis, at the given radius.  Default: 0
//   d = If given, makes a ring of child copies around the X axis, at the given diameter.
//   subrot = If false, don't sub-rotate children as they are copied around the ring.  Instead maintain their native orientation.  The false setting is only allowed when `d` or `r` is given.  Default: `true`
//   subrot = If false, don't sub-rotate children as they are copied around the ring.
//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.
//
// Side Effects:
//   `$idx` is set to the index value of each child copy.
//   `$ang` is set to the rotation angle of each child copy, and can be used to modify each child individually.
//   `$axis` is set to the axis vector rotated around.
//
//
// Example:
//   xrot_copies([180, 270, 315])
//       cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   xrot_copies(n=6)
//       cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   xrot_copies(n=6, r=10)
//       xrot(-90) cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) xrot(-90) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   xrot_copies(n=6, r=10, sa=45)
//       xrot(-90) cylinder(h=20, r1=5, r2=0);
//   color("red",0.333) xrot(-90) cylinder(h=20, r1=5, r2=0);
//
// Example:
//   xrot_copies(n=6, r=20, subrot=false)
//       xrot(-90) cylinder(h=20, r1=5, r2=0, center=true);
//   color("red",0.333) xrot(-90) cylinder(h=20, r1=5, r2=0, center=true);