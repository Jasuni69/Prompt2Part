function project_plane(plane,p) =
      is_matrix(plane,3,3) && is_undef(p) ? // no data, 3 points given
          assert(!is_collinear(plane),"\nPoints defining the plane must not be collinear.")
          let(
              v = plane[2]-plane[0],
              y = unit(plane[1]-plane[0]),        // y axis goes to point b
              x = unit(v-(v*y)*y)   // x axis 
          )            
          frame_map(x,y) * move(-plane[0])
    : is_vector(plane,4) && is_undef(p) ?            // no data, plane given in "plane"
          assert(_valid_plane(plane), "\nPlane is not valid.")
          let(
               n = point3d(plane),
               cp = n * plane[3] / (n*n)
          )
          rot(from=n, to=UP) * move(-cp)
    : is_path(plane,3) && is_undef(p) ?               // no data, generic point list plane
          assert(len(plane)>=3, "\nNeed three points to define a plane.")
          let(plane = plane_from_points(plane, check_coplanar=true))
          assert(is_def(plane), "\nPoint list is not coplanar.")
          project_plane(plane)
    : assert(is_def(p), str("Invalid plane specification: ",plane))
      is_vnf(p) ? [project_plane(plane,p[0]), p[1]] 
    : is_list(p) && is_list(p[0]) && is_vector(p[0][0],3) ?  // bezier patch or region
           [for(plist=p) project_plane(plane,plist)]
    : assert(is_vector(p,3) || is_path(p,3), str("\nData must be a 3D point, path, region, vnf, or bezier patch."))
      is_matrix(plane,3,3) ?
          assert(!is_collinear(plane),"\nPoints defining the plane must not be collinear.")
          let(
              v = plane[2]-plane[0],
              y = unit(plane[1]-plane[0]),        // y axis goes to point b
              x = unit(v-(v*y)*y)  // x axis 
          ) move(-plane[0],p) * transpose([x,y])
    : is_vector(p) ? point2d(apply(project_plane(plane),p))
    : path2d(apply(project_plane(plane),p));



// Function: lift_plane()
// Synopsis: Map a list of 2D points onto a plane in 3D. 
// SynTags: Path
// Topics: Coordinates, Points, Paths
// See Also: project_plane()
// Usage: 
//   xyz = lift_plane(plane, p);
// Usage: to get transform matrix
//   M =  lift_plane(plane);
// Description:
//   Converts the given 2D point on the plane to 3D coordinates of the specified plane.
//   The parameter p can be a point, path, region, bezier patch or VNF.
//   The plane can be specified as
//   - A list of three points.  The planar coordinate system will have [0,0] at plane[0], with plane[1] lying on the Y+ axis.
//   - A list of non-collinear, coplanar points that define a plane.
//   - A plane definition `[A,B,C,D]` where `Ax+By+CZ=D`.  The closest point on that plane to the origin maps to the origin in the new coordinate system.
//   .
//   If you do not supply `p` then you get a transformation matrix that operates in 3D, assuming that the Z coordinate of the points is zero.
//   This matrix is a rotation, the inverse of the one produced by project_plane.
// Arguments:
//   plane = Plane specification or list of points to define a plane
//   p = points, path, region, VNF, or bezier patch to transform.