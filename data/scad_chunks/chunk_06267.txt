function plot3d(f,x,y,zclip, zspan, base=1, anchor="origin", orient=UP, spin=0, atype="hull", cp="box", style="default") =
   assert(is_finite(base) && base>=0, "base must be a nonnegative number")
   assert(is_vector(x) || valid_range(x), "x must be a vector or nonempty range")
   assert(is_vector(y) || valid_range(y), "y must be a vector or nonempty range")
   assert(is_range(x) || is_increasing(x, strict=true), "x must be strictly increasing")
   assert(is_range(y) || is_increasing(y, strict=true), "y must be strictly increasing")
   assert(num_defined([zclip,zspan])<2, "Cannot give both zclip and zspan")
   assert(is_undef(zclip) || (is_list(zclip) && len(zclip)==2 && is_num(zclip[0]) && is_num(zclip[1])), "zclip must be a list of two values (which may be infinite)")
   assert(is_undef(zspan) || (is_vector(zspan,2) && zspan[0]<zspan[1]) ,"zspan must be a 2-vector whose first entry is smaller than the second")
   let(
       zclip = default(zclip, [-INF,INF]), 
       data = [for(x=x) [for(y=y) [x,y,min(max(f(x,y),zclip[0]),zclip[1])]]],
       dummy=assert(len(data[0])>1 && len(data)>1, "x and y must both provide at least 2 points"),
       minval = min(column(flatten(data),2)),
       maxval = max(column(flatten(data),2)),
       sdata = is_undef(zspan) ? data
             : let(
                    scale = (zspan[1]-zspan[0])/(maxval-minval)
               )
               [for(row=data) [for (entry=row) [entry.x,entry.y,scale*(entry.z-minval)+zspan[0]]]]
   )
   base==0 ? vnf_vertex_array(sdata,style=style)
 : 
   let(
       minval = min(column(flatten(sdata),2)),
       maxval = max(column(flatten(sdata),2)),
       bottom = is_def(zspan) ? zspan[0]-base : minval-base,
       data = [ [for(p=sdata[0]) [p.x,p.y,bottom]],
                each sdata,
                [for(p=last(sdata)) [p.x,p.y,bottom]]
              ],
       vnf = vnf_vertex_array(transpose(data), col_wrap=true, caps=true, style=style)
   )
   reorient(anchor,spin,orient, vnf=vnf, p=vnf);



// Function&Module: plot_revolution()
// Synopsis: Generates a surface by evaluating a of z and theta and putting the result on a surface of revolution
// SynTags: Geom, VNF
// Topics: Function Plotting
// See Also: plot3d()
// Usage: To create a cylinder or cone (by angle)
//   plot_revolution(f, angle, z, [r=/d=] [r1=/d1], [r2=/d2=], [rclip=], [rspan=], [horiz=], [style=], [convexity=], ...) [ATTACHMENTS];
// Usage: To create a cylinder or cone (by arclength)
//   plot_revolution(f, arclength=, z=, [r=/d=] [r1=/d1], [r2=/d2=], [rclip=], [rspan=], [horiz=], [style=], [convexity=], ...) [ATTACHMENTS];
// Usage: To create a surface of revolution
//   plot_revolution(f, [angle], [arclength=], path=, [rclip=], [rspan=], [horiz=], [style=], [convexity=], ...) [ATTACHMENTS];
// Usage: As Function
//   vnf = plot_revolution(...);
// Description:
//   Given a function literal, `f`, sets `r=f(theta,z)` over a range of theta and z values, and uses the
//   computed r values to define the offset from a cylinder or surface of revolution.  You can specify
//   the theta range as a `angle` to give an angle range in degrees or with `arclength` to give an arc length
//   range in distance units.  Your function will receive its parameters in
//   the form you specify, as angle or as arclength.  If you use `angle` then as the radius decreases, the
//   function shrinks in the horizontal direction to fit.  If you use `arclength` distance is preserved for
//   the function and as you move toward the top of a cone, the function will occupy a larger amount
//   of total angle so that the arc length stays the same.  
//   .
//   If the computed value produces a radius smaller than zero it will be rounded up to 0.01.  You can
//   specify a cylinder using the usual length and
//   radius or diameter parameters, or you can give `path`, a path which whose x values are strictly positive
//   to define the textured surface of revolution.  
//   .
//   Your function may have have excessively large values at some points, or you may not know exactly 
//   what its extreme values are.  To manage these situations you can use either the `rclip` or `rspan`
//   parameter (but not both).  The `rclip` parameter is a 2-vector giving a minimum and maximum
//   value, either of which can be infinite.  If the function falls below the minimum it is set
//   equal to the minimum, and if it rises above the maximum it is set equal to the maximum.  The
//   `rspan` parameter is a 2-vector giving a minum and maximum value which must both be finite.
//   The function's values will be scaled and shifted to exactly cover the range you specifiy
//   in `rspan`.
//   .
//   The default is to erect the function normal to the surface.  You can also set `horiz=true` to
//   erect the function perpendicular to the rotation axis.  In the former case, the caps of the
//   model are likely to be irregularly shaped and not exactly the requested size, unless the function
//   evaluates to zero at the top and bottom of the path.  When `horiz=true` the top and bottom will
//   be flat.  
// Arguments:
//   f = function literal accepting two arguments (angle and z) that defines the function to compute
//   angle = a list or range of angle values where the function is calculated
//   z = a list or range of z values to where the function is calculated, used only with cylinders and cones, not allowed with `path`.
//   ---
//   r / d = radius or diameter of cylinder (not allowed with `path`)
//   r1 / d1 = radius or diameter of bottom end (not allowed with `path`)
//   r2 / d2 = radius or diameter of top end (not allowed with `path`)
//   arclength = list or range of arc length values where the function is calculated 
//   path = path to revolve to produce the shape.  (If omitted you must supply cylinder parameters.)
//   rclip = A vector `[rmin,rmax]' that constrains the output of function to these bounds, which may be infinite. Cannot be used with `rspan`.
//   rspan = Rescale and shift the function values so the minimum value of f appears at rspan[0] and the maximum at rspan[1].  Cannot be used with `rclip`.
//   style = {{vnf_vertex_array()}} style used to triangulate heightfield textures.  Default: "default"
//   convexity = Max number of times a line could intersect a wall of the surface being formed. Module only.  Default: 10
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`
//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top toward, after spin. See [orient](attachments.scad#subsection-orient).  Default: `UP`
//   atype = Select "hull" or "intersect" anchor type.  Default: "hull"
//   cp = Centerpoint for determining intersection anchors or centering the shape.  Determines the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
// Anchor Types:
//   "hull" = Anchors to the virtual convex hull of the shape.
//   "intersect" = Anchors to the surface of the shape.
// Named Anchors:
//   "origin" = Anchor at the origin, oriented UP.
// Example(3D,NoScale,VPR=[85.10,0.00,127.90],VPD=292.71,VPT=[21.15,13.27,0.90): 
//   f = function (x,y) 5*cos(5*norm([x*180/50,y*180/50]))+5;
//   plot_revolution(f, arclength=[-50:1:50], z=[-50:1:50], r=30); 
// Example(3D,NoScale,VPR=[69.00,0.00,96.40],VPD=361.36,VPT=[14.10,5.03,4.53]): When specifying angle, the pattern shrinks at the top of the cone. 
//   g = function (x,y) 5*sin(4*x)*cos(6*y)+5;
//   plot_revolution(g, z=[-60:2:60], angle=[-180:4:180], r1=30, r2=16);
// Example(3D,NoScale,VPR=[69.00,0.00,96.40],VPD=361.36,VPT=[14.10,5.03,4.53]): When specifying arc length, the shape wraps around more cone at the top
//   g = function (x,y) 5*sin(8*x)*cos(6*y)+5;
//   plot_revolution(g, z=[-60:.5:60], arclength=[-45:.5:45],r1=30,r2=16);
// Example(3D,VPR=[60.60,0.00,100.60],VPD=100.87,VPT=[-1.84,-1.70,5.63]): Here we place a simple ridge function onto a cone using angle.  Note how the ribs narrow with the radius.  
//   f = function(x,y) cos(20*x)+1;
//   plot_revolution(f,z=[0:.1:20], angle=[-45:.1:45], r1=20,r2=10, horiz=true);
//   cyl(h=20, r1=20,r2=10,anchor=BOT,$fn=64);
// Example(3D,VPR=[60.60,0.00,100.60],VPD=100.87,VPT=[-1.84,-1.70,5.63]): Here using arc length to put the function on the cone results in relatively straight ridges that do not narrow at the top of the cone.  Note that we had to adjust the function to be properly scaled for the arc length parameter instead of angle.  
//   f = function(x,y) cos(60*x)+1;
//   plot_revolution(f,z=[0:.1:20], arclength=[-15:.1:15], r1=20,r2=10, horiz=true);
//   cyl(h=20, r1=20,r2=10,anchor=BOT,$fn=64);
// Example(3D,VPR=[57.10,0.00,148.90],VPD=100.87,VPT=[-1.40,-0.72,4.63]): Changing the arc length range position changes how the function maps onto the surface.  
//   f = function(x,y) cos(60*x)+1;
//   plot_revolution(f,z=[0:.1:20], arclength=[0:.1:30], r1=20,r2=10, horiz=true);
//   cyl(h=20, r1=20,r2=10,anchor=BOT,$fn=64);
// Example(3D,Med,NoAxes,VPR=[73.90,0.00,17.30],VPD=124.53,VPT=[-10.15,31.37,-9.82]): Here we construct a model using a circular arc for the path, resulting in a spherical shape.  The left model has `horiz=false` and the right hand one has `horiz=true`.  
//   hcount=4;        // Number of ribs to create
//   vcount=2;        // How periods of oscillation for each rib
//   stretch_ang=200; // Angle extent of oscillations
//   g = function(x,y) sin(hcount * x + stretch_ang * sin(18 * vcount * y));
//   xcopies(spacing=30)
//     plot_revolution(g, [0:3:360], path=arc(200, r=10, angle=[-89,89]),style="min_edge", horiz=$idx==1);