function arc(n, r, angle, d, cp, points, corner, width, thickness, start, wedge=false, long=false, cw=false, ccw=false, endpoint=true, rounding) =
    assert(is_bool(endpoint))
    !endpoint ?
        assert(!wedge, "endpoint cannot be false if wedge is true")
        list_head(arc(u_add(n,1),r,angle,d,cp,points,corner,width,thickness,start,wedge,long,cw,ccw,true,rounding))
  :
    assert(is_undef(start) || is_def(angle), "start requires angle")
    assert(is_undef(angle) || !any_defined([thickness,width,points,corner]), "Cannot give angle with points, corner, width or thickness")
    assert(is_undef(n) || (is_integer(n) && n>=2), "Number of points must be an integer 2 or larger")
    assert(is_undef(points) || is_path(points, [2,3]), "Points must be a list of 2d or 3d points")
    assert((is_def(points) && len(points)==2) || !any([cw,ccw,long]), "cw, ccw, and long are only allowed when points is a list of length 2")
    // First try for 2D arc specified by width and thickness
    is_def(width) && is_def(thickness)? 
        assert(!any_defined([r,cp,points,angle,start]),"Conflicting or invalid parameters to arc")
        assert(width>0, "Width must be postive")
        assert(thickness>0, "Thickness must be positive")
        arc(n,points=[[width/2,0], [0,thickness], [-width/2,0]],wedge=wedge,rounding=rounding)
  : is_def(angle)? 
        let(
            parmok = !any_defined([points,width,thickness]) &&
                ((is_vector(angle,2) && is_undef(start)) || is_finite(angle))
        )
        assert(parmok,"Invalid parameters in arc")
        let(
            cp = first_defined([cp,[0,0]]),
            start = is_def(start)? start : is_vector(angle) ? angle[0] : 0,
            angle = is_vector(angle)? angle[1]-angle[0] : angle,
            r = get_radius(r=r, d=d)
        )
        assert(is_vector(cp,2),"Centerpoint must be a 2d vector")
        assert(angle!=0, "Arc has zero length")
        assert(is_def(r) && r>0, "Arc radius invalid")
        is_def(rounding) ? assert(wedge,"rounding is only supportd with wedge=true") move(cp,zrot(start,_rounded_arc(r, rounding, angle, n)))
     :
        let(
            n = is_def(n) ? n : max(3, ceil(segs(r)*abs(angle)/360)),
            arcpoints = [for(i=[0:n-1]) let(theta = start + i*angle/(n-1)) r*[cos(theta),sin(theta)]+cp]
        )
        [
          if (wedge) cp,
          each arcpoints
        ]
  : is_def(corner)? 
        assert(is_path(corner,[2,3]) && len(corner)==3,str("Point list is invalid"))
        assert(is_undef(cp) && !any([long,cw,ccw]), "Cannot use cp, long, cw, or ccw with corner")
        // Arc is 3D, so transform corner to 2D and make a recursive call, then remap back to 3D
        len(corner[0]) == 3? (
            let(
                plane = [corner[2], corner[0], corner[1]],
                points2d = project_plane(plane, corner)
            )
            lift_plane(plane,arc(n,corner=points2d,wedge=wedge,r=r, d=d,rounding=rounding))
        ) :
        assert(is_path(corner) && len(corner) == 3)
        let(col = is_collinear(corner[0],corner[1],corner[2]))
        assert(!col, "Collinear inputs do not define an arc")
        let( r = get_radius(r=r, d=d) )
        assert(is_finite(r) && r>0, "Must specify r= or d= when corner= is given.")
        let(
            ci = circle_2tangents(r, corner[0], corner[1], corner[2], tangents=true),
            cp = ci[0], nrm = ci[1], tp1 = ci[2], tp2 = ci[3],
            dir = det2([corner[1]-corner[0],corner[2]-corner[1]]) > 0,
            corner = dir? [tp1,tp2] : [tp2,tp1],
            theta_start = atan2(corner[0].y-cp.y, corner[0].x-cp.x),
            theta_end = atan2(corner[1].y-cp.y, corner[1].x-cp.x),
            angle = posmod(theta_end-theta_start, 360),
            ang_range = dir ? [theta_start, theta_start+angle]
                            : [theta_start+angle, theta_start]
        )
        arc(n,cp=cp,r=r,angle=ang_range,wedge=wedge,rounding=rounding)
  : assert(is_def(points), "Arc not specified: must give points, angle, or width and thickness")
    assert(is_path(points,[2,3]),"Point list is invalid")
         // If arc is 3D, transform points to 2D and make a recursive call, then remap back to 3D
    len(points[0]) == 3? 
        assert(!(cw || ccw), "(Counter)clockwise isn't meaningful in 3d, so `cw` and `ccw` must be false")
        assert(is_undef(cp) || is_vector(cp,3),"points are 3d so cp must be 3d")
        let(
            plane = [is_def(cp) ? cp : points[2], points[0], points[1]],
            center2d = is_def(cp) ? project_plane(plane,cp) : undef,
            points2d = project_plane(plane, points)
        )
        lift_plane(plane,arc(n,cp=center2d,points=points2d,wedge=wedge,long=long,rounding=rounding))
  : len(points)==2?  
        // Arc defined by center plus two points, will have radius defined by center and points[0]
        // and extent defined by direction of point[1] from the center
        assert(is_vector(cp,2), "Centerpoint is required when points has length 2 and it must be a 2d vector")
        assert(len(points)==2, "When pointlist has length 3 centerpoint is not allowed")
        assert(points[0]!=points[1], "Arc endpoints are equal")
        assert(cp!=points[0]&&cp!=points[1], "Centerpoint equals an arc endpoint")
        assert(num_true([long,cw,ccw])<=1, str("Only one of `long`, `cw` and `ccw` can be true",cw,ccw,long))
        let(    
            angle = vector_angle(points[0], cp, points[1]),
            v1 = points[0]-cp,
            v2 = points[1]-cp,
            prelim_dir = sign(det2([v1,v2])),  // z component of cross product
            dir = prelim_dir != 0 ? prelim_dir :
                assert(cw || ccw, "Collinear inputs don't define a unique arc")
                1,
            r = norm(v1),
            final_angle = long || (ccw && dir<0) || (cw && dir>0) ?
                -dir*(360-angle) :
                dir*angle,
            sa = atan2(v1.y,v1.x)
        )
        arc(n,cp=cp,r=r,start=sa,angle=final_angle,wedge=wedge,rounding=rounding)
  : // Final case is arc passing through three points, starting at point[0] and ending at point[3]
        let(col = is_collinear(points[0],points[1],points[2]))
        assert(!col, "Collinear inputs do not define an arc")
        let(
            cp = line_intersection(_normal_segment(points[0],points[1]),_normal_segment(points[1],points[2])),
            // select order to be counterclockwise
            dir = det2([points[1]-points[0],points[2]-points[1]]) > 0,
            points = dir? select(points,[0,2]) : select(points,[2,0]),
            r = norm(points[0]-cp),
            theta_start = atan2(points[0].y-cp.y, points[0].x-cp.x),
            theta_end = atan2(points[1].y-cp.y, points[1].x-cp.x),
            angle = posmod(theta_end-theta_start, 360),
            // Specify endpoints exactly; skip those endpoints when producing arc points
            // Generating the whole arc and clipping ends is the easiest way to ensure that we
            // generate the proper number of points.
            ang_range = dir ? [theta_start, theta_start+angle]
                            : [theta_start+angle, theta_start],
            arcpts = is_def(rounding)? arc(n,cp=cp,r=r,angle=ang_range,wedge=wedge,rounding=rounding)
                   : [
                       if (wedge) cp, 
                       points[dir ? 0 : 1],
                       each select(arc(n,cp=cp,r=r,angle=ang_range),1,-2),
                       points[dir ? 1 : 0]
                     ]
        )
        arcpts;