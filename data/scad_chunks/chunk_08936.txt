function gyroid_points(pp, w)=
	let(
		res=90/(pp-2),                                          // resolution of points = distance between two adjacent points
		p= [											        // coordinates of points
			for (i = [-w, w], j = [0:pp])						    // for both wall directions (up/down), for every row
			let(
				jj = min(max(j, 1), pp - 1) -1,
				x = 90 - jj * res - (j==pp ? abs(w)/2 : 0),     // x and y coordinate of start of current row
				start = [(x^2 / 90 + x) / 2, x],                        // starting point of current row
				z = gyroid_point(pp, start.x, start.y),           // z coordinate of start of current row
				end = [180 - z, 180 - start.x]                        // ending point of current row
			)    			  	    
			for(k=[0:2*j])							            // for every line in row
				let(
					p_xy=
						(j == 0)				? [90 + w / 2, 90]         :
						(k == 0)				? start - [0, abs(w) / 2]  :
						(k == 2*j)			    ? end + [0, abs(w) / 2]    :
						(j == 1) && (k == 1)	? [90, 90]                 :
											      start + (end - start) / (2 * (j - 1)) * (k - 1),
					wall=(k == 0 || k == 2 * j || j == pp) ? 0 : i
				)
				wall_gyroid(p_xy.x, p_xy.y, gyroid_point(pp, p_xy.x, p_xy.y), wall)	// calculate point in row, line within gyroid wall
		]
	)														
	// matrix of points for all primitives of a gyroid micro cell
	[	p,									            // copy of p
		[for(i=p) [180,180,180]-i],						// diagonally oposing part of p
		[for(i=p) [i.y,i.z,i.x]],						// first cyclic permutation of coordinates
		[for(i=p) [180-i.y,180-i.z,180-i.x]],			// diagonally oposing part of permutation
		[for(i=p) [i.z,i.x,i.y]],						// second cyclic permutation of coordinates
		[for(i=p) [180-i.z,180-i.x,180-i.y]]			// diagonally oposing part of permutation
	];

// Calculates faces index matrix for gyroid polyhedron
// pp=number of rows