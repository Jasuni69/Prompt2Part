function bezier_patch_normals(patch, u, v) =
    assert(is_range(u) || is_vector(u) || is_finite(u), "\nInput u is invalid.")
    assert(is_range(v) || is_vector(v) || is_finite(v), "\nInput v is invalid.")
      !is_num(u) && !is_num(v) ?
          let(
              vbezes = [for (i = idx(patch[0])) bezier_points(column(patch,i), u)],
              dvbezes = [for (i = idx(patch[0])) bezier_derivative(column(patch,i), u)],
              v_tangent = [for (i = idx(vbezes[0])) bezier_derivative(column(vbezes,i), v)],
              u_tangent = [for (i = idx(vbezes[0])) bezier_points(column(dvbezes,i), v)]
          )
          [for(i=idx(u_tangent)) [for(j=idx(u_tangent[0])) unit(cross(u_tangent[i][j],v_tangent[i][j]),undef)]]
    : is_num(u) && is_num(v)?
          let(
                du = bezier_derivative([for (bez = patch) bezier_points(bez, v)], u),
                dv = bezier_points([for (bez = patch) bezier_derivative(bez, v)], u)
          )
          unit(cross(du,dv),undef)
    : is_num(u) ? bezier_patch_normals(patch,force_list(u),v)[0]
    :             column(bezier_patch_normals(patch,u,force_list(v)),0);


// Function: bezier_sheet()
// Synopsis: Creates a thin sheet from a bezier patch by extruding in normal to the patch
// SynTags: VNF
// Topics: Bezier Patches
// See Also: bezier_patch_normals(), vnf_sheet()
// Usage:
//   vnf = bezier_sheet(patch, delta, [splinesteps=], [style=]);
// Description:
//   Constructs a thin sheet from a bezier patch by offsetting the given patch along the normal vectors
//   to the patch surface.
//   The `delta` parameter is a 2-vector specifying the offset distances for both surfaces that form the
//   final sheet. The values for each offset must be small enough so that no points cross each other
//   when the offset is computed, because that results in invalid geometry and rendering errors.
//   Rendering errors may not manifest until you add other objects to your model.  
//   **It is your responsibility to avoid invalid geometry!**
//   .
//   Once the offset surfaces from the bezier patch are computed, they are connected by filling
//   in the boundary strips between them.
//   .
//   A negative offset value extends the patch toward its "inside", which is the side that appears purple
//   in the "thrown together" view when the patch is viewed by itself. Extending only toward the inside with a delta of `[0,-value]` or
//   `[-value,0]` (the order doesn't matter) means that your original bezier patch surface remains unchanged in the output.
//   Both offset surfaces may be extended in the same direction as long as the offset values are different.
// Arguments:
//   patch = bezier patch to process
//   delta = a 2-vector specifying two different offsets from the bezier patch, in any order. Positive values offset the patch from its "exterior" side, and negative values offset from the "interior" side.
//   ---
//   splinesteps = Number of segments on the border edges of the bezier surface.  You can specify [USTEPS,VSTEPS].  Default: 16
//   style = {{vnf_vertex_array()}} style to use.  Default: "default"
// Example(3D): A negative delta extends downward from the "inside" surface of the bezier patch, leaving the original bezier patch unchanged on the top surface.
//   patch = [
//        // u=0,v=0                                         u=1,v=0
//        [[-50,-50,  0], [-16,-50,  20], [ 16,-50, -20], [50,-50,  0]],
//        [[-50,-16, 20], [-16,-16,  20], [ 16,-16, -20], [50,-16, 20]],
//        [[-50, 16, 20], [-16, 16, -20], [ 16, 16,  20], [50, 16, 20]],
//        [[-50, 50,  0], [-16, 50, -20], [ 16, 50,  20], [50, 50,  0]],
//        // u=0,v=1                                         u=1,v=1
//   ];
//   vnf_polyhedron(bezier_sheet(patch, [0,-10]));
// Example(3D): Using the previous example, setting two positive offsets results in a sheet above the original bezier patch. The original bezier patch is shown in green for comparison.
//   patch = [
//        // u=0,v=0                                         u=1,v=0
//        [[-50,-50,  0], [-16,-50,  20], [ 16,-50, -20], [50,-50,  0]],
//        [[-50,-16, 20], [-16,-16,  20], [ 16,-16, -20], [50,-16, 20]],
//        [[-50, 16, 20], [-16, 16, -20], [ 16, 16,  20], [50, 16, 20]],
//        [[-50, 50,  0], [-16, 50, -20], [ 16, 50,  20], [50, 50,  0]],
//        // u=0,v=1                                         u=1,v=1
//   ];
//   color("lime") vnf_polyhedron(bezier_vnf(patch));
//   vnf_polyhedron(bezier_sheet(patch, [10,15]));