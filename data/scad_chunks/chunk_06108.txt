function sweep(shape, transforms, closed=false, caps, style="min_edge",
               anchor="origin", cp="centroid", spin=0, orient=UP, atype="hull",
               texture, tex_reps, tex_size, tex_samples, tex_inset=false, tex_rot=0, 
               tex_depth=1, tex_extra, tex_skip, _closed_for_normals=false, normals) =
    assert(is_consistent(transforms, ident(4)), "Input transforms must be a list of numeric 4x4 matrices in sweep")
    assert(is_path(shape,2) || is_region(shape), "Input shape must be a 2d path or a region.")
    let(
        caps = is_list(caps) && select(caps,0,1)==["for","offset_sweep"] ? [caps,caps]
             : is_bool(caps) || is_num(caps) ? [caps,caps]
             : is_undef(caps) ? closed ? [false,false] : [true,true]
             : caps, 
        capsOK = is_list(caps) && len(caps)==2
                    &&
                      [] == [for(cap=caps)
                               if (!(is_bool(cap) || is_num(cap) || select(cap,0,1)==["for","offset_sweep"])) 1],
        flatcaps = [for(cap=caps) is_bool(cap) ? cap : false],
        fancycaps = [for(cap=caps) is_bool(cap) ? false
                                 : is_num(cap) ? os_circle(r=cap,steps=ceil(segs(cap)/4))
                                 : cap]
    )
    assert(len(transforms)>=2, "transformation must be length 2 or more")
    assert(capsOK, "caps must be boolean, number, an offset_sweep specification, or a list of two of those")
    assert(!closed || caps==[false,false], "Cannot make closed shape with caps")
    is_region(shape)?
        assert(fancycaps==[false,false], "rounded caps are not supported for regions")
        assert(is_undef(texture), "textures are not supported for regions, only paths")
        let(
            regions = region_parts(shape),
            rtrans = reverse(transforms),
            vnfs = [
                for (rgn=regions) each [
                    for (path=rgn)
                        sweep(path, transforms, closed=closed, caps=false, style=style),
                    if (flatcaps[0]) vnf_from_region(rgn, transform=transforms[0], reverse=true),
                    if (flatcaps[1]) vnf_from_region(rgn, transform=last(transforms)),
                ],
            ],
            vnf = vnf_join(vnfs)
        )
        vnf
  :
    assert(len(shape)>=3, "shape must be a path of at least 3 non-colinear points")
    let(
         points = [for(i=[0:len(transforms)-(closed?0:1)]) apply(transforms[i%len(transforms)],path3d(shape))],
         normals = is_def(normals) ? normals
                 : (!(is_def(texture) && (closed || _closed_for_normals))) ? undef
                 : let(
                        n = surface_normals(select(points,0,-2), col_wrap=true, row_wrap=true)
                   )
                   [each n, n[0]],
         vva_result = vnf_vertex_array(points, normals=normals, 
                               cap1=flatcaps[0],cap2=flatcaps[1],col_wrap=true,style=style, return_edges=fancycaps!=[false,false],
                               texture=texture, tex_reps=tex_reps, tex_size=tex_size, tex_samples=tex_samples,
                               tex_inset=tex_inset, tex_rot=tex_rot, tex_depth=tex_depth, tex_extra=tex_extra, tex_skip=tex_skip),
         vnf = fancycaps==[false,false] ? vva_result
             : vnf_join(
                   [ vva_result[0], 
                     for(ind=[0,1]) 
                          if (fancycaps[ind]) let(
                              polygon = vva_result[1][ind+2],
                              plane = plane_from_polygon(ind==0? reverse(polygon) : polygon)
                          )
                          apply(lift_plane(plane),offset_sweep(project_plane(plane, polygon), top=fancycaps[ind], caps=[false,true]))
                    ])
    ) vnf;