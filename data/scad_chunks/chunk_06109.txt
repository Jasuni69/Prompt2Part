module sweep(shape, transforms, closed=false, caps, style="min_edge", convexity=10,
             anchor="origin",cp="centroid",spin=0, orient=UP, atype="hull",
             texture, tex_reps, tex_size, tex_samples, tex_inset=false, tex_rot=0, 
             tex_depth=1, tex_extra, tex_skip, normals)
{
    $sweep_transforms=transforms;
    $sweep_shape=shape;
    $sweep_closed=closed;
    vnf = sweep(shape, transforms, closed, caps, style,
                texture=texture, tex_reps=tex_reps, tex_size=tex_size, tex_samples=tex_samples,
                tex_inset=tex_inset, tex_rot=tex_rot, tex_depth=tex_depth, tex_extra=tex_extra, tex_skip=tex_skip, normals=normals);
    vnf_polyhedron(vnf, convexity=convexity, anchor=anchor, spin=spin, orient=orient, atype=atype, cp=cp)
        children();
}



// Section: Attaching children to sweeps


// Module: sweep_attach()
// Synopsis: Attach children to sides of a path_sweep parent object
// SynTags: Geom
// Topics: Extrusion, Sweep, Paths
// See Also: path_sweep()
// Usage:
//   path_sweep(...) { sweep_attach(parent, [child], [frac], [idx=], [len=], [spin=], [overlap=], [atype=]) CHILDREN; }
//   sweep(...) { sweep_attach(parent, [child], [frac], [idx=], [len=], [spin=], [overlap=], [atype=]) CHILDREN; }
// Description:
//   Attaches children to the sides of a {{path_sweep()}} or {{sweep()}} object.  You supply a position along the path,
//   either by path fraction, length, or index.  In the case of `sweep()` objects the path is defined as the path traced out
//   by the origin of the shape under the transformation list.  Objects are attached with their UP direction aligned with
//   the anchor for the profile and their BACK direction pointing in the direction of the sweep.
//   .
//   Like {{attach()}} this module has a parent-child anchor mode where you specify the child anchor and it is
//   aligned with the anchor on the sweep.  As with {{attach()}}, the child `anchor` and `orient` parameters are ignored.
//   Alternative you can use parent anchor mode where give only the parent anchor and the child appears at its
//   child-specified (default) anchor point.  The spin parameter spins the child around the attachment anchor axis.  
//   .
//   For a path_sweep() with no scaling, if you give a location or index that is exactly at one of the sections, the normal is in the plane
//   of the section.  In the general case if you give a location in between sections the normal is normal to the facet.  If you
//   give a location at a section in the general case the normal is the average of the normals of the two adjacent facets.  
//   For twisted or other complicated sweeps the normals may not be accurate.  If you need accurate normals for such shapes, you must
//   use the anchors for the VNF swept shape directly&mdash;it is a tradeoff between easy specification of the anchor location on the
//   swept object, which may be difficult with direct anchors, and accuracy of the normal.
//   .
//   For closed sweeps the index wraps around and can be positive or negative.  For sweeps that are not closed the index must
//   be positive and no longer than the length of the path.  In some cases for closed path_sweeps the shape can be a Möbius strip
//   and it may take more than one cycle to return to the starting point.  The extra twist will be properly handled in this case.
//   If you construct a Möbius strip using the generic {{sweep()}} then information about the amount of twist is not available
//   to `sweep_attach()` so it will not be handled automatically.  
//   .
//   The anchor you give acts as a 2D anchor to the path or region used by the sweep, in the XY plane as that shape appears
//   before it is transformed to form the swept object.  As with {{region()}}, you can control the anchor using `cp` and `atype`, 
//   and you can check the anchors by using the same anchors with {{region()}} in a two dimensional test case.
//   .
//   Note that {{path_sweep2d()}} does not support `sweep_attach()` because it doesn't compute the transform list, which is
//   the input used to calculate the attachment transform.  
// Arguments:
//   parent = 2d anchor to the shape used in the path_sweep parent
//   child = optional 3d anchor for anchoring the child to the parent
//   frac = position along the path_sweep path as a fraction of total length
//   ---
//   idx = index into the path_sweep path (use instead of frac)
//   len = absolute length along the path_sweep path (use instead of frac)
//   spin = spin the child this amount around the anchor axis.  Default: 0
//   overlap = Amount to lower the shape into the parent.  Default: 0
//   cp = Centerpoint for determining intersection anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 2D point.  Default: "centroid"
//   atype = Set to "hull" or "intersect" to select anchor type.  Default: "hull"
// Anchor Types:
//   "hull" = Anchors to the virtual convex hull of the region.
//   "intersect" = Anchors to the outer edge of the region.
// Example(Med,NoAxes,VPT=[4.75027,0.805639,-3.50893],VPR=[66.9,0,219.6],VPD=213.382): This example shows several children positioned at different places on the parent.  The blue cone is positioned using its TOP anchor and is sunk into the parent with overlay.  The three orange cubes show how they rotate to follow the local sweep direction.  
//   function a(h) = arc(points=[[-20,0],[0,h],[20,0]],n=24);
//   shape = concat(
//                  a(2), // bottom
//                  back(6,reverse(a(4))) // top
//           );
//   path = xrot(90,path3d(arc(points=[[-40,0],[0,5],[40,-20]],n=36)));
//   path_sweep(shape,path) {
//       sweep_attach(BACK,BOT,0.2) recolor("red") cyl(d1=5,d2=0,h=8,$fn=12);
//       sweep_attach(BACK,TOP,0.5,overlap=3) recolor("blue") cyl(d1=5,d2=0,h=8,$fn=12);
//       sweep_attach(RIGHT,BOT,idx=15) recolor("orange") cuboid([3,3,5]);
//       sweep_attach(RIGHT,BOT,idx=1) recolor("orange") cuboid([3,3,5]);
//       sweep_attach(RIGHT,BOT,idx=32) recolor("orange") cuboid([3,3,5]);        
//   }
// Example(VPT=[20.7561,8.89872,0.901718],VPR=[32.6,0,338.8],VPD=66.9616,NoAxes): In this example with scaling the objects' normals are not in the plane of the path_sweep sections.  
//   shape = hexagon(r=4);
//   path = xscale(2,arc(r=15, angle=[0,75],n=10));
//   path_sweep(shape,path,scale=3)
//   {  
//      sweep_attach(RIGHT,BOT,0)
//         color_this("red")cuboid([1,1,4]);
//      sweep_attach(RIGHT,BOT,0.5)
//         color_this("blue")cuboid([1,1,4]);
//      sweep_attach(BACK,BOT,1/3)
//         color_this("lightblue")prismoid(3,1,3);
//   }
// Example(Med): This pentagonal torus is a mobius strip.  It takes five times around to return to your starting point.  Here the red box has gone 4.4 times around.  
//   ellipse = xscale(2, p=circle($fn=64, r=3));
//   pentagon = subdivide_path(pentagon(r=1), 30);
//   path_sweep(pentagon, path3d(ellipse),
//              closed=true, twist=360*2/5,symmetry=5)
//     sweep_attach(RIGHT,BOT,4.4) color("red") cuboid([.25,.25,3]);
// Example(VPT=[17.1585,9.05454,50.69],VPR=[67.6,0,64.9],VPD=292.705,NoAxes): Example using {{sweep()}}
//   function f(x) = 3 - 2.5 * x;
//   function r(x) = 2 * 180 * x * x * x;
//   pathstep = 1;
//   height = 100;
//   shape_points = subdivide_path(square(10),40,closed=true);
//   path_transforms = [for (i=[0:pathstep:height]) let(t=i/height) up(i) * scale([f(t),f(t),i]) * zrot(r(t))];
//   sweep(shape_points, path_transforms){
//     sweep_attach(RIGHT,BOT,idx=33)
//           color_this("red")cuboid([5,5,5]);
//     sweep_attach(FWD,BOT,idx=65)
//           color_this("red")cuboid([5,5,5]);
//   }