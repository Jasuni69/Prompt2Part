function _clipfacevertices(vcube, fld, bbface, isovalmin, isovalmax) =
    let(
        vi = _MCFaceVertexIndices[bbface], // four voxel face vertex indices
        vface = [ for(i=vi) vcube[i] ], // four voxel face vertex coordinates
        f = [ for(i=vi) fld[i] ],   // four corner field values
        idx = _clipfacindex(f, isovalmin, isovalmax)
    ) [
        if(idx>0 && idx<80)
            let(tri = _MCClipTriangleTable[idx])
                for(i=[0:2:len(tri)-1]) let(
                    cpath = tri[i],
                    epath = tri[i+1]
                ) each [
                    for(corner=cpath) vface[corner],
                    for(edge=epath) let(
                        iso = edge>3 ? isovalmax : isovalmin,
                        e = edge>3 ? edge-4 : edge,
                        v0 = e,
                        v1 = (e+1)%4,
                        denom = f[v1]-f[v0],
                        u = abs(denom)<0.00001 ? 0.5 : (iso-f[v0]) / denom
                    ) vface[v0] + u*(vface[v1]-vface[v0])
                ]
    ];


//////////////////// 2D initializations and support functions ////////////////////

/*
"Marching triangles" algorithm

A square pixel has 5 vertices, four on each corner and one in the center. Vertices and edges are numbered as follows:

(1)                 (3)
   +-------1-------+
   | \           / |
   |   5       6   |
   |     \   /     |
   0      (4)      2
   |     /   \     |
   |   4       7   |
   | /           \ |
   +-------3-------+
(0)                 (2)

The vertices are assigned a value 1 if greater than or equal to the isovalue, or 0 if less than the isovalue.

These ones and zeros, when arranged as a binary number with vertex (0) being the least significant bit and vertex (4) the most significant, forms an address ranging from 0 to 31.

This address is used as an index in _MTriSegmentTable to get the order of edges that are crossed.
*/

// vertices that make each edge
_MTEdgeVertexIndices = [
    [0, 1],
    [1, 3],
    [3, 2],
    [2, 0],
    [0, 4],
    [1, 4],
    [3, 4],
    [2, 4]
];

// edge order for drawing a contour (or two contours) through a pixel, for all 32 possibilities of vertices being higher or lower than isovalue
_MTriSegmentTable = [ // marching triangle segment table
    [[], []],            // 0 - 00000
    [[0,4,3], []],       // 1 - 00001
    [[1,5,0], []],       // 2 - 00010
    [[1,5,4,3], []],     // 3 - 00011
    [[3,7,2], []],       // 4 - 00100
    [[0,4,7,2], []],     // 5 - 00101
    [[1,5,0], [3,7,2]],  // 6 - 00110 - 2 corners
    [[1,5,4,7,2], []],   // 7 - 00111
    [[2,6,1], []],       // 8 - 01000
    [[0,4,3], [2,6,1]],  // 9 - 01001 - 2 corners
    [[2,6,5,0], []],     //10 - 01010
    [[2,6,5,4,3], []],   //11 - 01011
    [[3,7,6,1], []],     //12 - 01100
    [[0,4,7,6,1], []],   //13 - 01101
    [[3,7,6,5,0], []],   //14 - 01110
    [[7,6,5,4,7], []],   //15 - 01111 low center - pixel encloses contour
    [[4,5,6,7,4], []],   //16 - 10000 high center - pixel encloses contour
    [[0,5,6,7,3], []],   //17 - 10001
    [[1,6,7,4,0], []],   //18 - 10010
    [[1,6,7,3], []],     //19 - 10011
    [[3,4,5,6,2], []],   //20 - 10100
    [[0,5,6,2], []],     //21 - 10101
    [[1,6,2], [3,4,0]],  //22 - 10110 - 2 corners
    [[1,6,2], []],       //23 - 10111
    [[2,7,4,5,1], []],   //24 - 11000
    [[0,5,1], [2,7,3]],  //25 - 11001 - 2 corners
    [[2,7,4,0], []],     //26 - 11010
    [[2,7,3], []],       //27 - 11011
    [[3,4,5,1], []],     //28 - 11100
    [[0,5,1], []],       //29 - 11101
    [[3,4,0], []],       //30 - 11110
    [[], []]             //31 - 11111
];

_MTriSegmentTable_reverse = [
    [[],[]],
    [[3,4,0],[]],
    [[0,5,1],[]],
    [[3,4,5,1],[]],
    [[2,7,3],[]],
    [[2,7,4,0],[]],
    [[0,5,1],[2,7,3]],
    [[2,7,4,5,1],[]],
    [[1,6,2],[]],
    [[3,4,0],[1,6,2]],
    [[0,5,6,2],[]],
    [[3,4,5,6,2],[]],
    [[1,6,7,3],[]],
    [[1,6,7,4,0],[]],
    [[0,5,6,7,3],[]],
    [[7,4,5,6,7],[]],
    [[4,7,6,5,4],[]],
    [[3,7,6,5,0],[]],
    [[0,4,7,6,1],[]],
    [[3,7,6,1],[]],
    [[2,6,5,4,3],[]],
    [[2,6,5,0],[]],
    [[2,6,1],[0,4,3]],
    [[2,6,1],[]],
    [[1,5,4,7,2],[]],
    [[1,5,0],[3,7,2]],
    [[0,4,7,2],[]],
    [[3,7,2],[]],
    [[1,5,4,3],[]],
    [[1,5,0],[]],
    [[0,4,3],[]],
    [[],[]]
];
/*
Low-res "marching squares" case has the same labeling but without the center vertex
and extra edges. In the two ambiguous cases with two opposite corners above and the
other two below the isovalue, it is assumed that the high values connect, to make
contours compatible with isosurface() at pixel boundaries.

(1)           (3)
   +----1----+
   |         |
   0         2
   |         |
   +----3----+
(0)           (2)
*/
_MSquareSegmentTable = [ // marching square segment table (lower res)
    [[], []],       // 0 - 0000
    [[0,3], []],    // 1 - 0001
    [[1,0], []],    // 2 - 0010
    [[1,3], []],    // 3 - 0011
    [[3,2], []],    // 4 - 0100
    [[0,2], []],    // 5 - 0101
    [[1,2], [3,0]], // 6 - 0110 - 2 opposite corners
    [[1,2], []],    // 7 - 0111
    [[2,1], []],    // 8 - 1000
    [[0,1], [2,3]], // 9 - 1001 - 2 opposite corners
    [[2,0], []],    //10 - 1010
    [[2,3], []],    //11 - 1011
    [[3,1], []],    //12 - 1100
    [[0,1], []],    //13 - 1101
    [[3,0], []],    //14 - 1110
    [[], []]        //15 - 1111
];

_MSquareSegmentTable_reverse = [
    [[],[]],
    [[3,0],[]],
    [[0,1],[]],
    [[3,1],[]],
    [[2,3],[]],
    [[2,0],[]],
    [[2,1],[0,3]],
    [[2,1],[]],
    [[1,2],[]],
    [[1,0],[3,2]],
    [[0,2],[]],
    [[3,2],[]],
    [[1,3],[]],
    [[1,0],[]],
    [[0,3],[]],
    [[],[]]
];

/// _mctrindex() - private function
/// Return the index ID of a pixel depending on the field strength at each vertex exceeding isoval.