module pcb(type) { //! Draw specified PCB
    grid = pcb_grid(type);
    t = pcb_thickness(type);
    w = pcb_width(type);
    l = pcb_length(type);

    $fs = fs; $fa = fa;

    module pcb_shape()
        if(Len(pcb_polygon(type)))
            polygon(pcb_polygon(type));
        else
            rounded_square([l, w], r = pcb_radius(type));

    if(pcb_name(type))
        vitamin(str("pcb(", type[0], "): ", pcb_name(type)));

    for(part = pcb_accessories(type))
        vitamin(part);

    color(pcb_colour(type))
        linear_extrude(t)
            difference() {
                pcb_shape();

                pcb_hole_positions(type)
                    offset(eps)
                        circle4n(d = pcb_hole_d(type));

                if(Len(grid))
                    pcb_grid_positions(type)
                        circle(d = 1 + eps);
            }

    land = pcb_land_d(type);
    land_r = Len(land) > 2 ? land[2] : 0;
    hole = pcb_hole_d(type);
    color(Len(land) > 3 ? land[3] : silver)
        translate_z(t / 2)
            linear_extrude(t + 2 * plating, center = true)
                difference() {
                    intersection() {
                        pcb_hole_positions(type)
                            if(is_list(land)) {
                                p = pcb_holes(type)[$i];  // If edge SMT pad then make it rectangular to overlap without gaps
                                edge = abs(p.x) < eps || abs(p.x - l) < eps || abs(p.y) < eps || abs(p.y - w) < eps;
                                rounded_square([land.x, land.y], edge ? 0 : land_r);
                            }
                            else
                                circle(d = max(land, 1));

                        offset(eps)
                            pcb_shape();   // Handle half holes on the edge of PCBs such as ESP8266
                    }

                    pcb_hole_positions(type)
                        circle4n(d = hole);
                }

    fr4 = pcb_colour(type) != "sienna";
    pcb_colour = pcb_colour(type);
    plating_colour = is_undef(grid[4]) ? ((pcb_colour == "green" || pcb_colour == "#2140BE") ? silver : pcb_colour == "sienna" ? copper : gold) : grid[4];
    color(plating_colour)
        translate_z(-plating)
            linear_extrude(fr4 ? t + 2 * plating : plating)
                if(Len(grid)) {
                    pcb_grid_positions(type)
                        difference() {
                            circle(d = 2);

                            circle(d = 1);
                        }
                    if(fr4 && len(grid) < 3 && pcb_holes(type)) { // oval lands at the ends
                        screw_x = pcb_coord(type, pcb_holes(type)[0]).x;
                        both_ends = len(pcb_holes(type)) > 2;
                        y0 = pcb_grid(type).y;
                        rows = round((pcb_width(type) - 2 * y0) / inch(0.1));
                        for(end = both_ends ? [-1, 1] : [1], y = [1 : rows - 1])
                            translate([end * screw_x, y0 + y * inch(0.1) - pcb_width(type) / 2])
                                hull()
                                    for(x = [-1, 1])
                                        translate([x * 1.6 / 2, 0])
                                            circle(d = 2);
                    }
                }

   let($solder = is_undef($solder) ? undef : pcb_solder(type)) // Handle PCB sub assembly on perfoard
        pcb_components(type);
}