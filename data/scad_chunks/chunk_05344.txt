function _bezier_rectangle(patch, splinesteps=16, style="default") =
    let(
        uvals = lerpn(0,1,splinesteps.x+1),
        vvals = lerpn(1,0,splinesteps.y+1),
        pts = bezier_patch_points(patch, uvals, vvals)
    )
    vnf_vertex_array(pts, style=style, reverse=false);


// Function: bezier_vnf()
// Synopsis: Generates a (probably non-manifold) VNF for one or more bezier surface patches.
// SynTags: VNF
// Topics: Bezier Patches
// See Also: bezier_patch_points(), bezier_patch_flat()
// Usage:
//   vnf = bezier_vnf(patches, [splinesteps], [style]);
// Description:
//   Convert a patch or list of patches into the corresponding Bezier surface, representing the
//   result as a [VNF structure](vnf.scad).  The `splinesteps` argument specifies the sampling grid of
//   the surface for each patch by specifying the number of segments on the borders of the surface.
//   It can be a scalar, which gives a uniform grid, or
//   it can be [USTEPS, VSTEPS], which gives difference spacing in the U and V parameters. 
//   Note that the surface you produce may be disconnected and is not necessarily a valid manifold in OpenSCAD.
//   The patches must mate exactly along their edges to ensure a valid VNF.  
// Arguments:
//   patches = The bezier patch or list of bezier patches to convert into a vnf.
//   splinesteps = Number of segments on the border of the bezier surface.  You can specify [USTEPS,VSTEPS].  Default: 16
//   style = The style of subdividing the quads into faces.  Valid options are "default", "alt", "min_edge", "quincunx", "convex" and "concave".  See {{vnf_vertex_array()}}.  Default: "default"
// Example(3D):
//   patch = [
//       // u=0,v=0                                         u=1,v=0
//       [[-50,-50,  0], [-16,-50,  20], [ 16,-50, -20], [50,-50,  0]],
//       [[-50,-16, 20], [-16,-16,  20], [ 16,-16, -20], [50,-16, 20]],
//       [[-50, 16, 20], [-16, 16, -20], [ 16, 16,  20], [50, 16, 20]],
//       [[-50, 50,  0], [-16, 50, -20], [ 16, 50,  20], [50, 50,  0]],
//       // u=0,v=1                                         u=1,v=1
//   ];
//   vnf = bezier_vnf(patch, splinesteps=16);
//   vnf_polyhedron(vnf);
// Example(3D,FlatSpin,VPD=444): Combining multiple patches
//   patch = 100*[
//       // u=0,v=0                                u=1,v=0
//       [[0,  0,0], [1/3,  0,  0], [2/3,  0,  0], [1,  0,0]],
//       [[0,1/3,0], [1/3,1/3,1/3], [2/3,1/3,1/3], [1,1/3,0]],
//       [[0,2/3,0], [1/3,2/3,1/3], [2/3,2/3,1/3], [1,2/3,0]],
//       [[0,  1,0], [1/3,  1,  0], [2/3,  1,  0], [1,  1,0]],
//       // u=0,v=1                                u=1,v=1
//   ];
//   fpatch = bezier_patch_flat([100,100]);
//   tpatch = translate([-50,-50,50], patch);
//   flatpatch = translate([0,0,50], fpatch);
//   vnf = bezier_vnf([
//                     tpatch,
//                     xrot(90, tpatch),
//                     xrot(-90, tpatch),
//                     xrot(180, tpatch),
//                     yrot(90, flatpatch),
//                     yrot(-90, tpatch)]);
//   vnf_polyhedron(vnf);
// Example(3D):
//   patch1 = [
//       [[18,18,0], [33,  0,  0], [ 67,  0,  0], [ 82, 18,0]],
//       [[ 0,40,0], [ 0,  0,100], [100,  0, 20], [100, 40,0]],
//       [[ 0,60,0], [ 0,100,100], [100,100, 20], [100, 60,0]],
//       [[18,82,0], [33,100,  0], [ 67,100,  0], [ 82, 82,0]],
//   ];
//   patch2 = [
//       [[18,82,0], [33,100,  0], [ 67,100,  0], [ 82, 82,0]],
//       [[ 0,60,0], [ 0,100,-50], [100,100,-50], [100, 60,0]],
//       [[ 0,40,0], [ 0,  0,-50], [100,  0,-50], [100, 40,0]],
//       [[18,18,0], [33,  0,  0], [ 67,  0,  0], [ 82, 18,0]],
//   ];
//   vnf = bezier_vnf(patches=[patch1, patch2], splinesteps=16);
//   vnf_polyhedron(vnf);
// Example(3D): Connecting Patches with asymmetric splinesteps.  Note it is fastest to join all the VNFs at once, which happens in vnf_polyhedron, rather than generating intermediate joined partial surfaces.  
//   steps = 8;
//   edge_patch = [
//       // u=0, v=0                    u=1,v=0
//       [[-60, 0,-40], [0, 0,-40], [60, 0,-40]],
//       [[-60, 0,  0], [0, 0,  0], [60, 0,  0]],
//       [[-60,40,  0], [0,40,  0], [60,40,  0]],
//       // u=0, v=1                    u=1,v=1
//   ];
//   corner_patch = [
//       // u=0, v=0                    u=1,v=0
//       [[ 0, 40,-40], [ 0,  0,-40], [40,  0,-40]],
//       [[ 0, 40,  0], [ 0,  0,  0], [40,  0,  0]],
//       [[40, 40,  0], [40, 40,  0], [40, 40,  0]],
//       // u=0, v=1                    u=1,v=1
//   ];
//   face_patch = bezier_patch_flat([120,120],orient=LEFT);
//   edges = [
//       for (axrot=[[0,0,0],[0,90,0],[0,0,90]], xang=[-90:90:180])
//           bezier_vnf(
//               splinesteps=[steps,1],
//               rot(a=axrot,
//                   p=rot(a=[xang,0,0],
//                       p=translate(v=[0,-100,100],p=edge_patch)
//                   )
//               )
//           )
//   ];
//   corners = [
//       for (xang=[0,180], zang=[-90:90:180])
//           bezier_vnf(
//               splinesteps=steps,
//               rot(a=[xang,0,zang],
//                   p=translate(v=[-100,-100,100],p=corner_patch)
//               )
//           )
//   ];
//   faces = [
//       for (axrot=[[0,0,0],[0,90,0],[0,0,90]], zang=[0,180])
//           bezier_vnf(
//               splinesteps=1,
//               rot(a=axrot,
//                   p=zrot(zang,move([-100,0,0], face_patch))
//               )
//           )
//   ];
//   vnf_polyhedron(concat(edges,corners,faces));