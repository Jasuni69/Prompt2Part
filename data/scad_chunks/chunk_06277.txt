module sparse_cuboid(size, dir=RIGHT, strut=5, maxang=30, max_bridge=20,
    chamfer,
    rounding,
    edges=EDGES_ALL,
    except=[],
    except_edges,
    trimcorners=true,
    teardrop=false,
    anchor=CENTER, spin=0, orient=UP)
{
  size = force_list(size,3);
  dummy1= assert(is_vector(size,3) && all_positive(size), "size must be a positive number or 3-vector")
          assert(in_list(dir,["X","Y","Z"]) || is_vector(dir,3), "dir must be a 3-vector or one of \"X\", \"Y\", or \"Z\"");
  count = len([for(d=dir) if (d!=0) d]);
  dummy2=assert(is_string(dir) || (count==1 && len(dir)<=3), "vector valued dir must have exactly one non-zero component");
  dir = is_string(dir) ? dir
      : dir.x ? "X"
      : dir.y ? "Y"
      : "Z";
  attachable(anchor,spin,orient,size=size){
    intersection(){
      if (dir=="X")
         sparse_wall(size.z,size.y,size.x,strut=strut,maxang=maxang, max_bridge=max_bridge);
      else if (dir=="Y")
         zrot(90)
           sparse_wall(size.z,size.x,size.y,strut=strut,maxang=maxang, max_bridge=max_bridge);
      else
         yrot(90)
           sparse_wall(size.x,size.y,size.z,strut=strut,maxang=maxang, max_bridge=max_bridge);
      cuboid(size=size, chamfer=chamfer, rounding=rounding,edges=edges, except=except, except_edges=except_edges,
           trimcorners=trimcorners, teardrop=teardrop);
    }
    children();
  }    
}


// Module: hex_panel()
// Synopsis: Create a hexagon braced panel of any shape
// SynTags: Geom
// Topics: FDM Optimized, Walls
// See Also: sparse_wall(), hex_panel(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()
// Usage:
//   hex_panel(shape, wall, spacing, [frame=], [bevel=], [bevel_frame=], [h=|height=|l=|length=], [anchor=], [orient=], [spin=])
// Description:
//   Produces a panel with a honeycomb interior that can be rectangular with optional beveling, or
//   an arbitrary polygon shape without beveling. The panel consists of a frame containing
//   a honeycob interior. The frame is laid out in the XY plane with the honeycob interior 
//   and then extruded to the height h. The shape argument defines the outer bounderies of
//   the frame.
//   .
//   The simplest way to define the frame shape is to give a cuboid size as a 3d vector for
//   the shape argument.  The h argument is not allowed in this case.  With rectangular frames you can supply the
//   bevel argument which applies a 45 deg bevel on the specified list of edges.  These edges
//   can be LEFT, RIGHT, FRONT, or BACK to place a bevel the edge facing upward.  You can add
//   BOTTOM, as in LEFT+BOT, to get a bevel that faces down.  When beveling a separate beveled frame
//   is added to the model.  You can independently control its thickness by setting `bevel_frame`, which
//   defaults to the frame thickness.  Note also that `frame` and `bevel_frame` can be set to zero
//   to produce just the honeycomb.  
//   . 
//   The other option is to provide a 2D path as the shape argument. The path must not intersect
//   itself.  You must give the height argument in this case and you cannot give the bevel argument.
//   The panel is made from a linear extrusion of the specified shape.  In this case, anchoring
//   is done as usual for linear sweeps.  The shape appears by default on its base and you can
//   choose "hull" or "intersect" anchor types.  
// Arguments:
//   shape = 3D size vector or a 2D path
//   strut = thickness of hexagonal bracing
//   spacing = center-to-center spacing of hex cells in the honeycomb.
//   ---
//   frame = width of the frame around the honeycomb.  Default: same as strut
//   bevel = list of edges to bevel on rectangular case when shape is a size vector; allowed options are RIGHT, LEFT, BACK, or FRONT, or those directions with BOTTOM added.  Default: []
//   bevel_frame = width of the frame applied at bevels.  Default: same as frame
//   h / height / l / length = thickness of the panel when shape is a path 
//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER` for rectangular panels, `"zcenter"` for extrusions.  
//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`
//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`
//   atype = Select "hull", "intersect" anchor types.  Default: "hull"
//   cp = Centerpoint for determining "intersect" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be "centroid", "mean", "box" or a 3D point.  Default: "centroid"
// Named Anchors:
//   "base" = Anchor to the base of the shape in its native position
//   "top" = Anchor to the top of the shape in its native position
//   "zcenter" = Center shape in the Z direction in the native XY position (default)
// Anchor Types:
//   hull = Anchors to the convex hull of the linear sweep of the path, ignoring any end roundings. 
//   intersect = Anchors to the surface of the linear sweep of the path, ignoring any end roundings.
// Examples:
//     hex_panel([50, 100, 5], strut=1.5, spacing=10);
//     hex_panel([50, 100, 5], 1.5, 10, frame = 5);
//     hex_panel([50, 100, 5], 5, 10.05);
//     hex_panel([50, 100, 5], 1.5, 20, frame = 5);
//     hex_panel([50, 100, 5], 1.5, 12, frame = 0);
//     hex_panel([50, 100, 5], frame = 10, spacing = 20, strut = 4);
//     hex_panel([50, 100, 10], 1.5, 10, frame = 5, bevel = [LEFT, RIGHT]);
//     hex_panel([50, 100, 10], 1.5, 10, frame = 5, bevel = [FWD,  BACK]);
//     hex_panel([50, 100, 10], 1.5, 10, frame = 3, bevel = [LEFT, RIGHT, FWD, BACK]);
//     hex_panel([50, 100, 10], 1.5, 10, frame = 1, bevel = [LEFT, RIGHT, FWD+BOTTOM, BACK+BOTTOM]);
//     hex_panel([50, 100, 10], 1.5, 10, frame=2, bevel_frame=0, bevel = [FWD, BACK+BOT, RIGHT, LEFT]);
// Example: Triangle
//     s = [[0, -40], [0, 40], [60, 0]];
//     hex_panel(s, strut=1.5, spacing=10, h = 10, frame = 5); 
// Example: Concave polygon
//     s = [[0, -40], [0, 70], [60, 0], [80, 20], [70, -20]];
//     hex_panel(s, 1.5, 10, h = 10, frame = 5); 
// Example: Another concave example
//     s = [[0, -40], [0, 40], [30, 20], [60, 40], [60, -40], [30, -20]];
//     hex_panel(s, 1.5, 10, h = 10, frame = 5); 
// Example: Circular panel
//     hex_panel(circle(30), 1.5, 10, h = 10, frame = 5);
// Example: More complicated shape
//     s = glued_circles(d=50, spread=50, tangent=30);
//     hex_panel(s, 1.5, 10, h = 10, frame = 5);
// Example: Care is required when arranging panels vertically for 3d printability.  Setting `orient=RIGHT` produces the correct result. 
//     hex_panel([50, 100, 10], 1.5, 10, frame = 5, bevel = [FWD, BACK], anchor = BACK + RIGHT + BOTTOM, orient = RIGHT);
//     zrot(-90)hex_panel([50, 100, 10], 1.5, 10, frame = 5,  bevel = [FWD, BACK], anchor = FWD + RIGHT + BOTTOM, orient = RIGHT);
// Example: In this example panels one of the panels is positioned with `orient=FWD` which produces hexagons with 60 deg overhang edges that may not be 3d printable.  This example alsu uses `bevel_frame` to thin the material at the corner.  
//     hex_panel([50, 100, 10], 1.5, 10, frame = 5, bevel_frame=1, bevel = [FWD,  BACK], anchor = BACK + RIGHT + BOTTOM, orient = RIGHT);
//     hex_panel([100, 50, 10], 1.5, 10, frame = 5, bevel_frame=1, bevel = [LEFT, RIGHT], anchor = FWD + LEFT + BOTTOM, orient = FWD);
// Example: Joining panels with {{attach()}}.  In this case panels were joined front beveled edge to back beveled edge, which means the hex structure doesn't align at the joint
//     hex_panel([50, 100, 10], 1.5, 10, frame = 5, bevel_frame=0, bevel = [FWD, BACK], anchor = BACK + RIGHT + BOTTOM, orient = RIGHT)
//       attach(BACK,FRONT) 
//          hex_panel([50, 100, 10], 1.5, 10, frame = 5, bevel_frame=0, bevel = [FWD, BACK]);
// Example: Joining panels with {{attach()}}.  Attaching BACK to BACK aligns the hex structure which looks better.  
//     hex_panel([50, 100, 10], 1.5, 10, frame = 1, bevel = [FWD, BACK], anchor = BACK + RIGHT + BOTTOM, orient = RIGHT)
//       attach(BACK,BACK) 
//          hex_panel([50, 100, 10], 1.5, 10, frame = 1, bevel = [FWD, BACK]);