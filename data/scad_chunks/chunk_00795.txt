module smd_soic(type, value) { //! Draw an SMD SOIC
    vitamin(str("smd_soic(", type[0], ", \"", value, "\"): ", type[0], " package ", value));

    size = smd_soic_size(type);
    z0 = smd_soic_z(type);
    z2 = z0 + size.z;
    z1 = z2 - smd_soic_lead_z(type);
    slant = 5;                              //! 5 degree body draft angle
    pitch = smd_soic_lead_pitch(type);
    span = (smd_soic_lead_span(type) / 2);
    ls = smd_soic_lead_size(type);
    leads = floor((size.x - ls.x) / pitch) + 1;

    r = ls.z;
    gullwing = rounded_path([
        [0, 0,                          ls.z / 2],
        [0, ls.y - r,                   ls.z / 2], r,
        [0, span - size.y / 2 - r, z1 - ls.z / 2], r,
        [0, span,                  z1 - ls.z / 2]
    ], $fn = fn);

    color(grey(20))
        hull()
            for(z = [z0, z1, z2], inset = abs(z - z1) * tan(slant))
                translate_z(z)
                    cube([size.x - 2 * inset, size.y - 2 * inset, eps], center = true);

    color(silver) {
        for(i = [0 : leads - 1]) {
            translate([i * pitch - size.x / 2 + (size.x - (leads - 1) * pitch) / 2, -span])
                sweep(gullwing, rectangle_points(ls.x, ls.z));

        rotate(180)
            translate([i * pitch - size.x / 2 + (size.x - (leads - 1) * pitch) / 2, -span])
                sweep(gullwing, rectangle_points(ls.x, ls.z));
        }

    }

    color("white")
        translate_z(z0 + size.z)
            linear_extrude(eps)
                resize([size.x * 0.9, size.y / 2])
                    text(value, halign = "center", valign = "center");

}