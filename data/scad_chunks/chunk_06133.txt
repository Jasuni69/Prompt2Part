function _textured_linear_sweep(
    region, texture, tex_size=[5,5],
    h, counts, inset=false, rot=0,
    tex_scale=1, twist, scale, shift,
    style="min_edge", l, caps=true, 
    height, length, samples,
    anchor=CENTER, spin=0, orient=UP
) =
    assert(is_path(region,[2]) || is_region(region))
    assert(is_undef(samples) || is_int(samples))
    assert(counts==undef || is_int(counts) || (all_integer(counts) && len(counts)==2), "tex_reps must be an integer or list of two integers")
    assert(tex_size==undef || is_vector(tex_size,2) || is_finite(tex_size))
    assert(is_bool(rot) || in_list(rot,[0,90,180,270]))
    assert(is_bool(caps) || is_bool_list(caps,2))
    let(
        counts = is_undef(counts) ? undef : force_list(counts,2),
        tex_size = force_list(tex_size,2),
        transform_pt = function(tileind,tilex,tilez,samples,inset,scale,bases,norms) 
               let(
                   pos = (tileind + tilex) * samples,    // tileind is which tile, tilex is position in a tile
                   ind = floor(pos),
                   frac = pos-ind,
                   texh = scale<0 ? -(1-tilez - inset) * scale
                                  : (tilez - inset) * scale,
                   base = lerp(select(bases,ind), select(bases,ind+1), frac),
                   norm = unit(lerp(select(norms,ind), select(norms,ind+1), frac))
              )
              base + norm * texh,
        
        caps = is_bool(caps) ? [caps,caps] : caps,
        regions = is_path(region,2)? [[region]] : region_parts(region),
        texture = _get_texture(texture, rot),
        dummy = assert(is_undef(samples) || is_vnf(texture), "You gave the tex_samples argument with a heightfield texture, which is not permitted.  Use the n= argument to texture() instead"),
        h = first_defined([h, l, height, length, 1]),
        inset = is_num(inset)? inset : inset? 1 : 0,
        twist = default(twist, 0),
        shift = default(shift, [0,0]),
        scale = scale==undef? [1,1,1] :
            is_num(scale)? [scale,scale,1] : scale,
        samples = !is_vnf(texture)? len(texture[0]) :
            is_num(samples)? samples : 8,
        vnf_tile =
            !is_vnf(texture) || samples==1 ? texture
          :
            let(
                s = 1 / max(1, samples),
                slice_us = list([s:s:1-s/2]),
                vnf_x = vnf_slice(texture, "X", slice_us),
                vnf_xy = twist? vnf_slice(vnf_x, "Y", slice_us) : vnf_x
            ) vnf_quantize(vnf_xy,1e-4), 
        edge_paths = is_vnf(texture) ? _tile_edge_path_list(vnf_tile,1) : undef,
        tpath = is_def(edge_paths) 
            ? len(edge_paths[0])==0 ? [] : hstack([column(edge_paths[0][0],0), column(edge_paths[0][0],2)])
            : let(
                  row = texture[0],
                  rlen = len(row)
              ) [for (i = [0:1:rlen]) [i/rlen, row[i%rlen]]],
        edge_closed_paths = is_def(edge_paths) ? edge_paths[1] : [],
        tmat = scale(scale) * zrot(twist) * up(h/2),
        texcnt = is_vnf(texture) ? undef
               : [len(texture[0]), len(texture)],
        pre_skew_vnf = vnf_join([
            for (rgn = regions) let(
                walls_vnf = vnf_join([
                    for (path = rgn) let(
                        path = reverse(path),
                        plen = path_length(path, closed=true),
                        counts = is_def(counts) ? counts : [round(plen/tex_size.x), max(1,round(h/tex_size.y)) ],
                        bases = resample_path(path, n=counts.x * samples, closed=true),
                        norms = path_normals(bases, closed=true),
                        vnf = is_vnf(texture)
                          ? vnf_join( // VNF tile texture
                                let(
                                    row_vnf = vnf_join([
                                        for (i = [0:1:(scale==1?0:counts.y-1)], j = [0:1:counts.x-1]) [
                                            [
                                              for (vert=vnf_tile[0])
                                                   let(
                                                        xy = transform_pt(j,vert.x,vert.z,samples, inset, tex_scale, bases, norms),
                                                        pt = point3d(xy,vert.y),
                                                        v = vert.y / counts.y,
                                                        vv = i / counts.y,
                                                        sc = lerp([1,1,1], scale, vv+v),
                                                        mat =
                                                            up((vv-0.5)*h) *
                                                            scale(sc) *
                                                            zrot(twist*(v+vv)) *
                                                            zscale(h/counts.y)
                                                    ) apply(mat, pt)
                                            ],
                                            vnf_tile[1]
                                        ]
                                    ])
                                ) [
                                    for (i = [0:1:0*(scale!=1?0:counts.y-1)])
                                    let(
                                        v = i / (scale==1?counts.y:1),
                                        sc = lerp([1,1,1], scale, v),
                                        mat =
                                            up((v)*h) *
                                            scale(sc) *
                                            zrot(twist*v)
                                    )
                                    apply(mat, row_vnf)
                                ]
                            )
                          : let( // Heightfield texture
                                tile_rows = [
                                    for (ti = [0:1:texcnt.y-1])
                                      path3d([
                                          for (j = [0:1:counts.x], tj = [0:1:texcnt.x-1])
                                            if (j != counts.x || tj == 0)
                                              transform_pt(j, tj/texcnt.x, texture[ti][tj], samples, inset, tex_scale, bases, norms)
                                    ])
                                ],
                                tiles = [
                                    for (i = [0:1:counts.y], ti = [0:1:texcnt.y-1])
                                    if (i != counts.y || ti == 0)
                                    let(
                                        v = (i + (ti/texcnt.y)) / counts.y,
                                        sc = lerp([1, 1, 1], scale, v),
                                        mat = up((v-0.5)*h) *
                                              scale(sc) *
                                              zrot(twist*v)
                                    ) apply(mat, tile_rows[(texcnt.y-ti)%texcnt.y])
                                ]
                            ) vnf_vertex_array(
                                tiles, caps=false, style=style,
                                col_wrap=true, row_wrap=false,
                                reverse=true
                            )
                    ) vnf
                ]),
                brgn = [
                    for (path = rgn) let(
                        path = reverse(path),
                        plen = path_length(path, closed=true),
                        counts = is_def(counts) ? counts : [round(plen/tex_size.x), max(1,round(h/tex_size.y)) ],
                        bases = resample_path(path, n=counts.x * samples, closed=true),
                        norms = path_normals(bases, closed=true),
                        nupath = [
                            for (j = [0:1:counts.x-1], vert = tpath)
                                transform_pt(j,vert.x,vert.y,samples,inset,tex_scale,bases,norms)
                        ]
                    ) nupath
                ],
                extra_edge_paths = edge_closed_paths==[] ? []
                 : [
                    for (path=rgn)
                      let(
                          path = reverse(path),
                          plen = path_length(path, closed=true),
                          counts = is_def(counts) ? counts : [round(plen/tex_size.x), max(1,round(h/tex_size.y))],
                          bases = resample_path(path, n=counts.x * samples, closed=true),
                          norms = path_normals(bases, closed=true),
                          modpaths = [for (j = [0:1:counts.x-1], cpath = edge_closed_paths)
                                        [for(vert = cpath)
                                           transform_pt(j,vert.x,vert.z,samples,inset,tex_scale,bases, norms)]
                                     ]
                      )
                      each modpaths
                    ],
                brgn_empty = [for(item=brgn) if(item!=[]) 1]==[],
                bot_vnf = !caps[0] || brgn_empty ? EMPTY_VNF
                    : vnf_from_region(brgn, down(h/2), reverse=true),
                top_vnf = !caps[1] || brgn_empty ? EMPTY_VNF
                    : vnf_from_region(brgn, tmat, reverse=false),
                extra_vnfs = [
                   if (caps[0] && len(extra_edge_paths)>0) for(path=extra_edge_paths) [path3d(path,-h/2),[count(len(path))]], 
                   if (caps[1] && len(extra_edge_paths)>0) for(path=extra_edge_paths) [apply(tmat,path3d(path,0)),[count(len(path), reverse=true)]]
                ]
            ) vnf_join([walls_vnf, bot_vnf, top_vnf,each extra_vnfs])
        ]),
        skmat = down(h/2) * skew(sxz=shift.x/h, syz=shift.y/h) * up(h/2),
        final_vnf = apply(skmat, pre_skew_vnf),
        cent = centroid(region),
        anchors = [
            named_anchor("centroid_top", point3d(cent, h/2), UP),
            named_anchor("centroid",     point3d(cent),      UP),
            named_anchor("centroid_bot", point3d(cent,-h/2), DOWN)
        ]
    ) reorient(anchor,spin,orient, vnf=final_vnf, extent=true, anchors=anchors, p=final_vnf);



// Given a VNF texture tile finds the paths on either the x=0 (axis=0) or the y=0 (axis=1) cases.
// Would also find the z=0 paths if you gave axis=2.
//
// It returns two lists, a list of open paths and a list of closed paths.  By default a max of
// one open path is permitted; either list can be empty.  The paths go in the direction of the segments
// in the VNF.