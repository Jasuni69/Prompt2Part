module rd_cm_choke(type, value) { //! Draw specified common mode choke.
    vitamin(str("rd_cm_choke(", type[0], " ,\"", value, "\"): Common mode choke ", value));
    core = rd_cm_choke_core(type);
    seam = rd_cm_choke_seam(type);
    slot = rd_cm_choke_slot(type);
    csep = rd_cm_choke_csep(type);
    wire = rd_cm_choke_wire(type);
    or = core.x / 2;
    ir = core.y / 2;
    core_w = core.z;
    core_r = core[3];
    z = seam.y + or;
    wire_r = wire[3] / 2;
    w = or - ir;
    $fs = fs; $fa = fa;

    color(grey(90))
        translate_z(z) {
            rotate([90, 0, 0]) {
                rotate_extrude()
                    translate([(ir + or) / 2, 0])
                        rounded_square([w, core_w], core_r, center = true);

                for(h = [true, false])
                    hflip(h)
                        rotate(-90)
                            rotate_extrude(angle = 180)
                                translate([or, 0])
                                    square([seam.y, seam.x]);
            }
            r = sqrt(sqr(or * cos(180 / r2sides(or))) - sqr(slot.z + csep.x / 2));
            for(x = [-1, 1], z = [-1, 1])
                translate([x * (csep.x / 2 + slot.z / 2), 0, z * (r - slot.y / 2)])
                    rotate([0, 90, 0])
                        rounded_rectangle([slot.y, slot.x, slot.z], core_r, center = true);

            rotate([0, 90, 0]) {
                rounded_rectangle([2 * ir, slot.x, csep.x], core_r, center = true);

                rounded_rectangle([csep.z, slot.x, csep.y], core_r, center = true);
            }
        }

     color(silver)
        for(x = [-1, 1], y = [-1, 1])
            translate([x * wire.x / 2, y * wire.y / 2]) {
                solder(wire_r);

                vflip()
                    cylinder(r = wire_r, h = wire.z, $fn = fn);
            }

     color(copper) {
        wire_d = 2 * wire_r;
        r = ir - wire_r;
        cr = core_r + wire_r;
        points = [
            [-core_w / 2 + core_r, 0, 0],
            [ core_w / 2 + wire_r, 0, 0],                       cr,
            [ core_w / 2 + wire_r, w + wire_r, 0],              cr,
            [ 0,                   w + wire_d + seam.y * 2, 0], 7,
            [-core_w / 2 - wire_r, w + wire_r, 0],              cr,
            [-core_w / 2 - wire_r, 0, 0],                       cr - eps,
            [-core_w / 2 + core_r, 0, 0],
        ];
        profile = segmented_path(rounded_path(points, $fn = fn), fs);
        min_gap_angle = 2 * asin((slot.z + csep.x / 2 + wire_r) / r);
        turns = floor((r * PI * (180 - min_gap_angle) / 180) / wire_d);
        turn_angle = wire_d / (r * PI) * 180;
        //turns = floor(((or + wire_r) * PI * (180 - min_gap_angle) / 180) / wire_d / 2);
        //turn_angle = 2 * asin(wire_d / (or + wire_r));
        gap_angle = 180 - turns * turn_angle;
        path = arc_points(r, a =  [90,  180 + gap_angle / 2, 180], al = 180 - gap_angle, $fn = turns * len(profile));
        spiral = spiral_wrap(path, profile, path_length(path) / turns, turns);
        tail = bezier_join([[wire.x / 2, wire.y / 2, -z - eps], [wire.x / 2, wire.y / 2, -z]], spiral, 1.5);
        tilt = turn_angle * (or + wire_r) / 120;

        outer_points = [
            [ core_w / 2 - core_r - wire_d,    -wire_d, 0],
            [-core_w / 2 - wire_r - wire_d,    -wire_d, 0],              cr + wire_d,
            [-core_w / 2 - wire_r,          w + wire_r, tilt / 2],       cr,
            [ 0,                            w + wire_d + seam.y * 2, -tilt / 4], 7, // No idea why -tilt / 2.5 and not zero.
            [ core_w / 2 + wire_r,          w + wire_r, -tilt / 1.5],    cr,
            [ core_w / 2 + wire_r + wire_d,    -wire_d, 0],              cr + wire_d,
            [ core_w / 2 - core_r - wire_d,    -wire_d, 0],
         ];

        outer_profile = segmented_path(rounded_path(outer_points, $fn = fn), fs);
        outer_path = arc_points(r, a =  [90,  180 + gap_angle / 2 + turn_angle / 2, 180], al = 180 - gap_angle, $fn = (turns - 1) * len(outer_profile));
        outer_spiral = concat(spiral_wrap(outer_path, outer_profile, path_length(outer_path) / turns, turns), [spiral[len(spiral) - 1]]);
        outer_tail = bezier_join([[wire.x / 2, -wire.y / 2, -z - eps], [wire.x / 2, -wire.y / 2, -z]], outer_spiral, 3);

        wire_points = circle_points(wire_r, $fn = fn);
        translate_z(z)
            for(side = [-1, 1]) mirror([side < 0 ? 1 : 0, 0]){
                color(copper)sweep(tail, wire_points);

                sweep(outer_tail, wire_points);
            }
     }
}