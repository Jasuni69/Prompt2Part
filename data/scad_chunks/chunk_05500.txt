function rounded_prism(bottom, top, joint_bot=0, joint_top=0, joint_sides=0, k_bot, k_top, k_sides, k=0.5, splinesteps=16,
                       h, length, l, height, debug=false, _full_info=false) =
   let(
       bottom = force_path(bottom,"bottom"),
       top = force_path(top,"top")
   )
   assert(is_path(bottom,[2,3]) && len(bottom)>=3, "bottom must be a 2D or 3D path")
   assert(is_num(k) && k>=0 && k<=1, "Curvature parameter k must be in interval [0,1]")
   let(
     N=len(bottom),
     k_top = default(k_top, k),
     k_bot = default(k_bot, k),
     k_sides = default(k_sides, k),
     height = one_defined([h,l,height,length],"height,length,l,h", dflt=undef),
     shapedimok = (len(bottom[0])==3 && is_path(top,3)) || (len(bottom[0])==2 && (is_undef(top) || is_path(top,2)))
   )
   assert(is_num(k_top) && k_top>=0 && k_top<=1, "Curvature parameter k_top must be in interval [0,1]")
   assert(is_num(k_bot) && k_bot>=0 && k_bot<=1, "Curvature parameter k_bot must be in interval [0,1]")
   assert(shapedimok,"bottom and top must be 2d or 3d paths with the same dimension")
   assert(len(bottom[0])==3 || is_num(height),"Must give height/length with 2d polygon input")
   let(
     // Determine which points are concave by making bottom 2d if necessary
     bot_proj = len(bottom[0])==2 ? bottom :  project_plane(select(bottom,0,2),bottom),
     bottom_sign = is_polygon_clockwise(bot_proj) ? 1 : -1,
     concave = [for(i=[0:N-1]) bottom_sign*sign(_point_left_of_line2d(select(bot_proj,i+1), select(bot_proj, i-1,i)))>0],
     top = is_undef(top) ? path3d(bottom,height/2) :
           len(top[0])==2 ? path3d(top,height/2) :
           top,
     bottom = len(bottom[0])==2 ? path3d(bottom,-height/2) : bottom,
     jssingleok = (is_num(joint_sides) && joint_sides >= 0) || (is_vector(joint_sides,2) && joint_sides[0]>=0 && joint_sides[1]>=0),
     jsvecok = is_list(joint_sides) && len(joint_sides)==N && []==[for(entry=joint_sides) if (!(is_num(entry) || is_vector(entry,2))) entry]
   )
   assert(is_num(joint_top) || is_vector(joint_top,2))
   assert(is_num(joint_bot) || is_vector(joint_bot,2))
   assert(is_num(joint_top) || (joint_top[0]>=0 ||joint_top[1]>=0), "Both entries in joint_top cannot be negative")
   assert(is_num(joint_bot) || (joint_bot[0]>=0 ||joint_bot[1]>=0), "Both entries in joint_bot cannot be negative")
   assert(jsvecok || jssingleok,
          str("Argument joint_sides is invalid.  All entries must be nonnegative, and it must be a number, 2-vector, or a length ",N," list those."))
   assert(is_num(k_sides) || is_vector(k_sides,N), str("Curvature parameter k_sides must be a number or length ",N," vector"))
   assert(is_coplanar(bottom))
   assert(is_coplanar(top))
   assert(!is_num(k_sides) || (k_sides>=0 && k_sides<=1), "Curvature parameter k_sides must be in interval [0,1]")
   let(
     non_coplanar=[for(i=[0:N-1]) if (!is_coplanar(concat(select(top,i,i+1), select(bottom,i,i+1)))) [i,(i+1)%N]],
     k_sides_vec = is_num(k_sides) ? repeat(k_sides, N) : k_sides,
     kbad = [for(i=[0:N-1]) if (k_sides_vec[i]<0 || k_sides_vec[i]>1) i],
     joint_sides_vec = jssingleok ? repeat(joint_sides,N) : joint_sides,
     top_collinear = [for(i=[0:N-1]) if (is_collinear(select(top,i-1,i+1))) i],
     bot_collinear = [for(i=[0:N-1]) if (is_collinear(select(bottom,i-1,i+1))) i]
   )
   assert(non_coplanar==[], str("Side faces are non-coplanar at edges: ",non_coplanar))
   assert(top_collinear==[], str("Top has collinear or duplicated points at indices: ",top_collinear))
   assert(bot_collinear==[], str("Bottom has collinear or duplicated points at indices: ",bot_collinear))
   assert(kbad==[], str("k_sides parameter outside interval [0,1] at indices: ",kbad))
   let(
     top_patch = _rp_compute_patches(top, bottom, joint_top, joint_sides_vec, k_top, k_sides_vec, concave),
     bot_patch = _rp_compute_patches(bottom, top, joint_bot, joint_sides_vec, k_bot, k_sides_vec, concave),

     vertbad = [for(i=[0:N-1])
                   if (norm(top[i]-top_patch[i][4][2]) + norm(bottom[i]-bot_patch[i][4][2]) > EPSILON + norm(bottom[i]-top[i])) i],
     // Check that the patch fits on the polygon edge
     topbad = [for(i=[0:N-1])
                   if (norm(top_patch[i][2][4]-top_patch[i][2][2]) + norm(select(top_patch,i+1)[2][0]-select(top_patch,i+1)[2][2])
                  > EPSILON + norm(top_patch[i][2][2] - select(top_patch,i+1)[2][2]))   [i,(i+1)%N]],
     botbad = [for(i=[0:N-1])
                   if (norm(bot_patch[i][2][4]-bot_patch[i][2][2]) + norm(select(bot_patch,i+1)[2][0]-select(bot_patch,i+1)[2][2])
                  > EPSILON + norm(bot_patch[i][2][2] - select(bot_patch,i+1)[2][2]))   [i,(i+1)%N]],
     // If top/bot is L-shaped, check that arms of L from adjacent patches don't cross
     topLbad = [for(i=[0:N-1])
                   if (norm(top_patch[i][0][2]-top_patch[i][0][4]) + norm(select(top_patch,i+1)[0][0]-select(top_patch,i+1)[0][2])
                          > EPSILON + norm(top_patch[i][0][2]-select(top_patch,i+1)[0][2])) [i,(i+1)%N]],
     botLbad = [for(i=[0:N-1])
                   if (norm(bot_patch[i][0][2]-bot_patch[i][0][4]) + norm(select(bot_patch,i+1)[0][0]-select(bot_patch,i+1)[0][2])
                          > EPSILON + norm(bot_patch[i][0][2]-select(bot_patch,i+1)[0][2])) [i,(i+1)%N]],
     // Check that the inner edges of the patch don't cross
     topinbad = [for(i=[0:N-1]) 
                     let(
                          line1 = project_plane(top,[top_patch[i][2][0],top_patch[i][0][0]]),
                          line2 = project_plane(top,[select(top_patch,i+1)[2][4],select(top_patch,i+1)[0][4]])
                     )
                     if (!approx(line1[0],line1[1]) && !approx(line2[0],line2[1]) &&
                         line_intersection(line1,line2, SEGMENT,SEGMENT))
                          [i,(i+1)%N]],
     botinbad = [for(i=[0:N-1])
                     let(
                          line1 = project_plane(bottom,[bot_patch[i][2][0],bot_patch[i][0][0]]),
                          line2 = project_plane(bottom,[select(bot_patch,i+1)[2][4],select(bot_patch,i+1)[0][4]])
                     )
                     if (!approx(line1[0],line1[1]) && !approx(line2[0],line2[1]) &&
                         line_intersection(line1,line2, SEGMENT,SEGMENT))
                          [i,(i+1)%N]]
   )
   assert(debug || vertbad==[], str("Top and bottom joint lengths are too large; they interfere with each other at vertices: ",vertbad))
   assert(debug || topbad==[], str("Joint lengths too large at top or side edges: ",topbad))
   assert(debug || botbad==[], str("Joint lengths too large at bottom or side edges: ",botbad))
   assert(debug || topLbad==[], str("Joint length too large on the top face or side at edges: ", topLbad))
   assert(debug || botLbad==[], str("Joint length too large on the bottom face or side at edges: ", botLbad))
   assert(debug || topinbad==[], str("Joint length too large on the top face at edges: ", topinbad))
   assert(debug || botinbad==[], str("Joint length too large on the bottom face at edges: ", botinbad))
   let(
     // Entries in the next two lists have the form [edges, vnf] where
     // edges is a list [leftedge, rightedge, topedge, botedge]
     top_samples = [for(patch=top_patch) bezier_vnf_degenerate_patch(patch,splinesteps,reverse=false,return_edges=true) ],
     bot_samples = [for(patch=bot_patch) bezier_vnf_degenerate_patch(patch,splinesteps,reverse=true,return_edges=true) ],
     leftidx=0,
     rightidx=1,
     topidx=2,
     botidx=3,
     edge_points =
       [for(i=[0:N-1])
            let(
               top_edge  = [ top_samples[i][1][rightidx], select(top_samples, i+1)[1][leftidx]],
               bot_edge  = [ select(bot_samples, i+1)[1][leftidx], bot_samples[i][1][rightidx]],
               vert_edge = [ bot_samples[i][1][botidx], top_samples[i][1][botidx]]
               )
               each [top_edge, bot_edge, vert_edge] ],
     faces = [
              [for(i=[0:N-1]) each top_samples[i][1][topidx]],
              [for(i=[N-1:-1:0]) each reverse(bot_samples[i][1][topidx])],
              for(i=[0:N-1]) [
                                 bot_patch[i][4][4],
                                 select(bot_patch,i+1)[4][0],
                                 select(top_patch,i+1)[4][0],
                                 top_patch[i][4][4]
                             ]
             ],
     top_collinear = is_collinear(faces[0]),
     bot_collinear = is_collinear(faces[1]),
     top_degen_ok = top_collinear && len(deduplicate(faces[0]))<=2,
     bot_degen_ok = bot_collinear && len(deduplicate(faces[1]))<=2,
     top_simple = top_degen_ok || (!top_collinear && is_path_simple(project_plane(faces[0],faces[0]),closed=true)),
     bot_simple = bot_degen_ok || (!bot_collinear && is_path_simple(project_plane(faces[1],faces[1]),closed=true)),                                   
     // verify vertical edges
     verify_vert =
       [for(i=[0:N-1],j=[0:4])
         let(
               vline = concat(select(column(top_patch[i],j),2,4),
                              select(column(bot_patch[i],j),2,4))
             )
         if (!is_collinear(vline)) [i,j]],
     //verify horiz edges
     verify_horiz=[for(i=[0:N-1], j=[0:4])
         let(
             hline_top = concat(select(top_patch[i][j],2,4), select(select(top_patch, i+1)[j],0,2)),
             hline_bot = concat(select(bot_patch[i][j],2,4), select(select(bot_patch, i+1)[j],0,2))
         )
         if (!is_collinear(hline_top) || !is_collinear(hline_bot)) [i,j]]
    )
    assert(debug || top_simple,
          "Roundovers interfere with each other on top face: either input is self intersecting or top joint length is too large")
    assert(debug || bot_simple,
          "Roundovers interfere with each other on bottom face: either input is self intersecting or top joint length is too large")
    assert(debug || (verify_vert==[] && verify_horiz==[]), "Curvature continuity failed")
    let( 
        vnf = vnf_join([ each column(top_samples,0),
                          each column(bot_samples,0),
                          for(pts=edge_points) vnf_vertex_array(pts),
                          debug ? vnf_from_polygons(faces,fast=true) 
                                : vnf_triangulate(vnf_from_polygons(faces))
                       ]),

        topnormal = unit(cross(top[0]-top[1],top[2]-top[1])),
        botnormal = -unit(cross(bottom[0]-bottom[1],bottom[2]-bottom[1])),
        sidenormal = [for(i=idx(top))
                         unit(cross(select(top,i+1)-top[i], bottom[i]-top[i]))],

        //pos, orient, spin, info=...
        
        anchors = [
            for(i=idx(top))
              let(
                   face = concat(select(top,[i+1,i]), select(bottom,i,i+1)),
                   face_ctr = mean(concat(select(top,[i+1,i]), select(bottom,i,i+1))),
                   bot_edge = bottom[i]-select(bottom,i+1), 
                   bot_edge_ctr = mean(select(bottom,i,i+1)),
                   bot_edge_normal = unit(mean([sidenormal[i],botnormal])),
                   top_edge_normal = unit(mean([sidenormal[i],topnormal])),
                   top_edge = select(top,i+1)-top[i],
                   top_edge_ctr = mean(select(top,i,i+1)),
                   top_edge_dir = select(top,i+1)-top[i],
                   edge = [top[i],bottom[i]],
                   edge_ctr = mean([top[i],bottom[i]]),
                   edge_normal = unit(mean(select(sidenormal,[i,i-1]))),
                   top_corner_dir = _three_edge_corner_dir([select(sidenormal,i-1),sidenormal[i],topnormal],
                                                           [top[i]-select(top,i-1), top_edge]),
                   bot_corner_dir = _three_edge_corner_dir([select(sidenormal,i-1),sidenormal[i],botnormal],
                                                           [bottom[i]-select(bottom,i-1), bot_edge])
              )
              each[
                named_anchor(EDGE(i),edge_ctr,edge_normal, _compute_spin(edge_normal,top[i]-bottom[i]),
                             info=[["edge_angle",180-vector_angle(sidenormal[i],select(sidenormal,i-1))], ["edge_length",norm(top[i]-bottom[i])]]),
                named_anchor(EDGE(UP,i),top_edge_ctr, top_edge_normal, _compute_spin(top_edge_normal,  top_edge),
                             info=[["edge_angle",180-vector_angle(topnormal,sidenormal[i])], ["edge_length",norm(top_edge)]]),
                named_anchor(EDGE(DOWN,i),bot_edge_ctr, bot_edge_normal, _compute_spin(bot_edge_normal,  bot_edge),
                             info=[["edge_angle",180-vector_angle(botnormal,sidenormal[i])], ["edge_length",norm(bot_edge)]]), 
                named_anchor(FACE(i),mean(face), sidenormal[i], _compute_spin(sidenormal[i],UP)),
                named_anchor(str("top_corner",i),top[i], top_corner_dir, _compute_spin(top_corner_dir,UP)), 
                named_anchor(str("bot_corner",i),bottom[i], bot_corner_dir, _compute_spin(bot_corner_dir,UP)) 
              ],
            named_anchor("top", mean(top), topnormal, _compute_spin(topnormal, approx(v_abs(topnormal),UP)?BACK:UP)),
            named_anchor("bot", mean(bottom), botnormal, _compute_spin(botnormal, approx(v_abs(botnormal),UP)?BACK:UP)),
        ],
        override = len(top)!=4 ? undef
           :
            let(
                stddir = [RIGHT,FWD,LEFT,BACK],
                getanch = function(name) search([name], anchors, num_returns_per_match=1)[0],
                dir_angle = [for(i=[0:3])  vector_angle(anchors[6*i+3][2],RIGHT)],
                ofs = search([min(dir_angle)], dir_angle, num_returns_per_match=1)[0]
            )
            [
              [UP, select(anchors[24],1,3)],
              [DOWN, select(anchors[25],1,3)],
              for(i=[0:3])
                let(
                    edgeanch=anchors[((i+ofs)%4)*6],
                    upedge=anchors[((i+ofs)%4)*6+1],
                    downedge=anchors[((i+ofs)%4)*6+2],                    
                    faceanch=anchors[((i+ofs)%4)*6+3],
                    upcorner=anchors[((i+ofs)%4)*6+4],
                    downcorner=anchors[((i+ofs)%4)*6+5]
                )    
                each [
                      [stddir[i],select(faceanch,1,3)],
                      [stddir[i]+select(stddir,i-1), select(edgeanch,1,3)],
                      [stddir[i]+UP, select(upedge,1,3)], 
                      [stddir[i]+DOWN, select(downedge,1,3)],
                      [stddir[i]+select(stddir,i-1)+UP, select(upcorner,1,3)],
                      [stddir[i]+select(stddir,i-1)+DOWN, select(downcorner,1,3)],
                     ] 
           ]
    )
    !debug && !_full_info ? vnf
  : _full_info ? [concat(top_patch, bot_patch), vnf, anchors, override]
  : [concat(top_patch, bot_patch), vnf];



// Converts a 2d path to a path on a cylinder at radius r