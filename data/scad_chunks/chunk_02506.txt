module thread(dia, pitch, length, profile, center = true, top = -1, bot = -1, starts = 1, solid = true, female = false, colour = undef) { //! Create male or female thread, ends can be tapered, chamfered or square
    assert(is_undef(colour) || is_list(colour), "Thread colour must be in [r, g, b] form");
    //
    // Apply colour if defined
    //
    module colour(factor) if(is_undef(colour)) children(); else color(colour * factor) children();
    //
    // Compress the profile to compensate for it being tilted by the helix angle
    //
    scale = cos(atan(pitch / (PI * dia)));
    sprofile = [for(p = profile) [p.x * scale, p.y, p.z]];
    //
    // Extract some properties from the profile, perhaps they should be stored in it.
    //
    h = max([for(p = sprofile) p.y]);
    xs = [for(p = sprofile) p.x];
    maxx = max(xs);
    minx = min(xs);
    crest_xs = [for(p = sprofile) if(p.y == h) p.x];
    crest_xmax = max(crest_xs);
    crest_xmin = min(crest_xs);
    //
    // If the ends don't taper we need an extra half turn past the ends to be cropped horizontally.
    //
    extra_top = top < 0 ? 0 : -minx / pitch;
    extra_bot = bot < 0 ? 0 :  maxx / pitch;
    turns = length / pitch + extra_top + extra_bot;
    //
    // Generate the helix path, possibly with tapered ends
    //
    dir = female ? 1 : -1;
    r = dia / 2;
    sides = r2sides4n(r);
    step_angle = 360 / sides;
    segs = ceil(turns * sides);
    leadin = min(ceil(sides / starts), floor(turns * sides / 2));
    final = floor(turns * sides) - leadin;
    path = [for(i = [0 : segs],
                R = i < leadin && bot < 0 ? r + dir * (h - h * i / leadin)
                  : i > final  && top < 0 ? r + dir * h * (i - final) / leadin : r,
                a = i * step_angle - 360 * extra_bot)
                    [R * cos(a), R * sin(a), a * pitch / 360]];
    //
    // Generate the skin vertices
    //
    facets = len(profile);
    twist  = helical_twist_per_segment(r, pitch, sides);
    //
    // For female threads we need to invert the profile
    //
    iprofile = female ? reverse([for(p = sprofile) [p.x, -p.y, 0]]) : sprofile;
    //
    // If the bottom is tapered then the twist will be greater, so pre-twist the profile to get the straight bit at the correct angle
    //
    rprofile = bot < 0 ? transform_points(iprofile, rotate(-dir * (helical_twist_per_segment(r - h, pitch, sides) - twist) * sides / PI))
                       : iprofile;
    points = skin_points(rprofile, path, false, twist * segs);
    //
    // To form the ends correctly we need to use intersection but it is very slow with the full thread so we just
    // intersect the start and the end and sweep the rest outside of the intersection.
    //
    top_chamfer_h = (top > 0 ? h * tan(top) : 0);
    bot_chamfer_h = (bot > 0 ? h * tan(bot) : 0);
    top_overlap = max( maxx, top_chamfer_h - crest_xmin) / pitch;
    bot_overlap = max(-minx, bot_chamfer_h + crest_xmax) / pitch;
    start =      ceil(sides * (bot_overlap + extra_bot));
    end = segs - ceil(sides * (top_overlap + extra_top));

    start_skin_faces  = skin_faces(points, start + 1,            facets, false);
    middle_skin_faces = skin_faces(points, end - start + 1,      facets, false, start);
    end_skin_faces    = skin_faces(points, segs - end + 1,       facets, false, end);

    start_faces  = concat([cap(facets)              ], start_skin_faces,  [cap(facets, start)]);
    middle_faces = concat([cap(facets, start, false)], middle_skin_faces, [cap(facets, end)]);
    end_faces    = concat([cap(facets, end,   false)], end_skin_faces,    [cap(facets, segs)]);

    overlap = - profile[0].y;
    translate_z((center ? -length / 2 : 0)) {
        ends_faces = concat(start_faces, end_faces);
        for(i = [0 : starts - 1])
            colour(thread_colour_factor)
                rotate(360 * i / starts + (female ? 180 / starts : 0)) {
                    render() intersection() {
                        polyhedron(points, ends_faces);

                        shorten = !is_undef(colour);
                        len = shorten ? length - 2 * eps : length;
                        offset = shorten ? eps : 0;
                        rotate_extrude()
                            if(female) {
                                difference() {
                                    translate([0, offset])
                                        square([r + h + overlap, len]);

                                    if(top_chamfer_h)
                                        polygon([[0, length], [r, length], [r - h, length - top_chamfer_h], [0, length - top_chamfer_h]]);

                                    if(bot_chamfer_h)
                                        polygon([[0, 0], [r, 0], [r - h, bot_chamfer_h], [0, bot_chamfer_h]]);
                               }
                            }
                            else
                                difference() {
                                    hull() {
                                        translate([0, offset])
                                            square([r, len]);

                                        translate([0, offset + bot_chamfer_h])
                                            square([r + h + overlap, len - top_chamfer_h - bot_chamfer_h]);
                                    }
                                    if(!solid)
                                        square([r - overlap, length]);
                                }
                    }

                    polyhedron(points, middle_faces);
                }

        if(solid)
            colour(1)
                rotate(90)
                    if(female)
                        tube(or = r + (top < 0 || bot < 0 ? h : 0) + 2 * overlap, ir = r, h = length, center = false);
                    else
                        cylinder(d = dia, h = length);
    }
}